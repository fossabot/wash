<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rflow [
<!ENTITY lt "&#38;#60;">
<!ENTITY gt "&#62;">
<!ENTITY amp "&#38;#38;">
<!ENTITY apos "&#39;">
<!ENTITY quot "&#34;">
]>
<rflow>
	<graph version="0.8" width="1079" height="419" locationtype="a" offsetx="510" offsety="-408">
		<setting>
			<entry key="USE_GRID">true</entry>
			<entry key="FOLDER">wsupSurvey</entry>
			<entry key="GRID_DISTANCE2">10</entry>
		</setting>
<properties>
<v key="packages"/>
</properties>
		<node id="0" date="1510899093927" uid="ef2cdd356a6e9ef1" x="-90" y="790">
			<command>
################################################################################
#                                                                              #
# Step 5a: Estimate indicators                                                 #
#                                                                              #
#      This step performs the blocked weighted bootstrap analysis on the       #
#      indicator set using the number of replicates specified by the user      #
#      in the previous step and across three stratifications namely:           #
#                                                                              #
#        a. survey area                                                        #
#        b. wealth quintile                                                    #
#        c. overall                                                            #
#                                                                              #
#      The output of this step produces three results table in comma-separated #
#      value (CSV) format which is saved in the &apos;outputTables&apos; folder in the   #
#      current working directory. The files are named:                         #
#                                                                              #
#        a. surveyResultsBootXYZMMMYYYY.csv        - per survey area results   #
#        b. surveyResultsBootWealthXYZMMMYYYY.csv  - per wealth quintile       #
#        c. surveyResultsBootOverallZYZMMMYYYY.csv - overall                   #
#                                                                              #
#      where                                                                   #
#                                                                              #
#      XYZ   - is the three character country code of the country to which     #
#              the results are from.                                           #
#                                                                              #
#      MMM   - is the three character abbreviation of the month in which       #
#              survey was conducted (month of the starting day)                #
#                                                                              #
#      YYYY  - is the 4 digits corresponding to the year in which survey       #
#              was conducted (year of the starting day)                        #
#                                                                              #
################################################################################</command>
			<property title="Run STEP 4b" shape="STAR">
				<comment state="opened" x="60" y="-10">STEP 4b: Estimate        </comment>
			</property>
			<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
		</node>
		<node id="1" date="1510899093929" uid="b91eaf1a6479dd9a" x="-190" y="190">
			<command>################################################################################
#
# Configure R
#
################################################################################
#
# Clear workspace
#
rm(list = ls())
#
# Garbage collection
#
gc()
#
# Set options
#
options(stringsAsFactors = FALSE)
#
# Set seed for pseudo-random number generator
#
set.seed(1977)


################################################################################
#
# Load libraries
#
################################################################################

library(maptools)          # library for reading map data
library(maps)              # library for other map functions e.g., scale bar
library(rgeos)             # library for geospatial data manipulation and analysis
library(rgdal)             # library for geospatial data manipulation and analysis
library(gstat)             # library for geospatial modelling and interpolation
library(ggmap)             # library for plotting maps using ggplot
library(ggplot2)           # library for creating plots using ggplot
library(raster)            # library for working with raster data
library(FNN)               # library for finding nearest neighbour algorithm
library(grid)              # library for map-based grids
library(scales)            # library for scaling values
library(stringr)           # library for character manipulation/handling
library(classInt)          # library for creating class intervals for vector values
library(tcltk2)            # library for TCL/TK properties
library(Hmisc)             # library for miscellaneous R functions on top of base


################################################################################
#
# Function to add alpha parameter to colours
#
################################################################################

addAlpha &lt;- function(col, alpha)
  {
  apply(X = sapply(col, col2rgb)/255, 
	   MARGIN = 2,
	   FUN = function(x) { rgb(x[1], x[2], x[3], alpha = alpha) })
  }


############################################################
#
# Function to scale values for mapping
#
############################################################

scaleValue &lt;- function(x, n, style = &quot;quantile&quot;, digits = 0)
  {
  y &lt;- cut(x, 
		 breaks = unique(classIntervals(x, 
		                                n = n, 
		                                style = style,
		                                dataPrecision = digits)$brks),
	      labels = FALSE, 
	      include.lowest = TRUE)
  return(y)
  }


################################################################################
#
# bootBW function (blocked weighted bootstrap function)
#
################################################################################
#
#  Returns :
#
#    A data.frame with :
#
#      ncol  = length(outputColumns)
#      nrow  = replicates
#      names = outputColumns
#
################################################################################
#
#  Example :
#
#    Example function (estimate a proportion for a binary (0/1) variable) :
#
#      oneP &lt;- function(x, params)
#        {
#        v1 &lt;- params[1]
#        v1Data &lt;- x[[v1]]
#        oneP &lt;- mean(v1Data, na.rm = TRUE)
#        return(oneP)
#        }
#
#  Example call to bootBW function:
#
#    bootP &lt;- bootBW(x = data,
#                    w = pops,
#                    statistic = oneP,
#                    params = &quot;nameOfVariable&quot;,
#                    outputColumns = &quot;p&quot;,
#                    replicates = 1999)
#
#  Example estimate with 95% CI :
#
#    quantile(bootP, probs = c(0.500, 0.025, 0.975), na.rm = TRUE)
#
################################################################################
#
#  Version : 21/03/2014
#
################################################################################

bootBW &lt;- function(x, w, statistic, params, outputColumns, replicates = 400)
  {
  #
  # Scale weights and accumulate weights
  #
  w$weight &lt;- w$pop / sum(w$pop)
  w$cumWeight &lt;- cumsum(w$weight)
  #
  # Create data.frame with named columns for output
  #
  boot &lt;- data.frame(matrix(ncol = length(outputColumns), nrow = replicates))
  names(boot) &lt;- outputColumns
  #
  # Create an empty data.frame with same structure of &apos;x&apos; with sufficient rows
  # to hold the largest possible survey replicates (i.e. number of clusters
  # multiplied by the size of the largest cluster)
  #
  nClusters &lt;- nrow(w)
  maxRows &lt;- nClusters * max(table(x$psu))
  emptyDF &lt;- rbind(as.data.frame(lapply(x, function(x) rep.int(NA, maxRows))))
  #
  # Vector to hold clusters to be included in a survey replicate
  #
  sampledClusters &lt;- vector(mode = mode(x$psu), length = nClusters)
  #
  # And now ... resample!
  #
  for(i in 1:replicates)
    {
    #
    # Create a dataframe to hold a survey replicate
    #
    xBW &lt;- emptyDF
    #
    # Blocking Bootstrap from &apos;x&apos; (blocking on x$psu = cluster identifier)
    #
    for(j in 1:nClusters)
      {
      #
      # &quot;Roulette Wheel&quot; algorithm (to select a weighted sample of clusters)
      #
	 sampledClusters[j] &lt;- w$psu[which.max(w$cumWeight &gt;= runif(n = 1, min = 0, max = 1))]
	 }
    #
    # Pointer for inserting selected clusters into the survey replicate
    #
    rowIndex &lt;- 1
    #
    # Build a (blocking weighted) bootstrap replicate from the selected clusters
    #
    for(k in 1:nClusters)
      {
      #
      # Extract data for cluster and resample within the cluster
      #
	 y &lt;- subset(x, psu == sampledClusters[k])
	 clusterN &lt;- nrow(y)
	 y &lt;- y[sample(1:clusterN, replace = TRUE), ]
	 #
	 # Insert cluster replicate into survey replicate
	 #
	 endRow &lt;- rowIndex + clusterN
	 xBW[rowIndex:(endRow - 1), ] &lt;- y
	 #
	 # Update pointer
	 #
	 rowIndex &lt;- endRow
	 }
    #
    # Select data for analysis
    #
    xBW &lt;- xBW[1:(rowIndex - 1), ]
    #
    # Apply statistic
    #
    boot[i, ] &lt;- statistic(xBW, params)
    }
  return(boot)
  }


################################################################################
#
# Statistic function for use with bootBW
#
#   This function returns a mean of the first item in &apos;params&apos;. If a binary
#   variable is coded 1 / 0 then this is a proportion.
#
################################################################################

oneMean &lt;- function(x, params)
  {
  v1 &lt;- params[1]
  v1Data &lt;- x[[v1]]
  oneMean &lt;- mean(v1Data, na.rm = TRUE)
  return(oneMean)
  }


################################################################################
#
#  Pyramid plot 
#
################################################################################
#
#  Parameters :
#
#    x     A vector (numeric, factor, character) holding age-groups
#
#    g     A binary categorical variable (usually sex)
#
#    main  Plot title
# 
#    xlab  x-axis label
#
#    ylab  y-axis label
#
################################################################################
#
#  Returns :
#
#    Axis tick positions (of limited use)
#
################################################################################

pyramid.plot &lt;- function(x, 
	                    g,
	                    main = paste(&quot;Pyramid plot of&quot;, deparse(substitute(x)), &quot;by&quot;, deparse(substitute(g))),
	                    xlab = paste(deparse(substitute(g)), &quot;(&quot;, levels(g)[1], &quot;/&quot;, levels(g)[2],&quot;)&quot;),
	                    ylab = deparse(substitute(x)))
  {
  tab &lt;- table(x, g); tab[ ,1] &lt;- -tab[ ,1]
  barplot(tab,
  horiz = TRUE,
  beside = TRUE,
  space = c(0, -nrow(tab)),
  names.arg = c(dimnames(tab)$x, dimnames(tab)$x),
  xlim = c(min(tab) * 1.2, max(tab) * 1.2),
  col = &quot;white&quot;,
  main = main,
  xlab = xlab,
  ylab = ylab,
  axes = FALSE)
  axis(side = 1, labels = abs(axTicks(side = 1)), at = (axTicks(side = 1)))
  }


################################################################################
#
#  Pareto plot 
#
################################################################################
#
#  Parameters :
#
#    x     A vector (numeric, factor, character)
#
#    main  Plot title
# 
#    xlab  x-axis label
#
#    ylab  y-axis label
#
################################################################################
#
#  Returns :
#
#    Bar positions
#
################################################################################

pareto.plot &lt;- function(x, 
	                   main = paste(&quot;Pareto Chart of&quot;, deparse(substitute(x))),
	                   xlab = deparse(substitute(x)),
	                   ylab = &quot;Count&quot;)
  {
  barplot(rev(sort(table(x))), xlab = xlab, ylab = ylab, main = main, col = &quot;white&quot;)
  }



 


################################################################################
#
# Create directories within current directory for organising outputs
#
################################################################################
#
# Create first level directories for outputs
#
dir.create(&quot;outputLists&quot;, showWarnings = FALSE)
dir.create(&quot;outputTables&quot;, showWarnings = FALSE)
dir.create(&quot;data&quot;, showWarnings = FALSE)



################################################################################
#                                                                              #
#                ASSEMBLE COLOUR VECTORS FOR CHARTS AND MAPS                   #
#                                                                              #
################################################################################

################################################################################
#
# Create WSUP-specific and WASH-specific colour schemes
#
################################################################################
#
# WSUP blue colour fill
#
wsupFill   &lt;- &quot;#c6dbef&quot;
#
# WSUP blue colour border
#
wsupColour &lt;- &quot;#3182bd&quot;
#
# WASH ladder indicators colour schemes
#
waterLadder &lt;- c(&quot;#4575b4&quot;, &quot;#74add1&quot;, &quot;#ffffbf&quot;, &quot;#feb24c&quot;, &quot;#ec7014&quot;)
sanitationLadder &lt;- c(&quot;#1a9850&quot;, &quot;#a6d96a&quot;, &quot;#ffffbf&quot;, &quot;#feb24c&quot;, &quot;#ec7014&quot;)
handwashLadder &lt;- c(&quot;#cab2d6&quot;, &quot;#ffffbf&quot;, &quot;#ec7014&quot;)
#
# Colour for water collector plots
#
collectColour &lt;- c(&quot;#fbb4ae&quot;, &quot;#b3cde3&quot;, &quot;#ccebc5&quot;, &quot;#decbe4&quot;, &quot;#fed9a6&quot;)
#
# Colour for formal/informal plots
#
formalColour &lt;- c(&quot;#a6cee3&quot;, &quot;#1f78b4&quot;)
#
# Overall indicators colour schemes
#
overallColour &lt;- c(&quot;#fdbf6f&quot;, &quot;#b2df8a&quot;, &quot;#a6cee3&quot;, &quot;#e78ac3&quot;)
#
# Seven colour water palette scheme
#
water7 &lt;- c(&quot;#eff3ff&quot;, &quot;#c6dbef&quot;, &quot;#9ecae1&quot;, &quot;#6baed6&quot;, 
	       &quot;#4292c6&quot;, &quot;#2171b5&quot;, &quot;#084594&quot;)



################################################################################
#
#
#
# PPI LOOK-UP TABLES
#
#
#
################################################################################

################################################################################
#
# Bangladesh PPI look-up table
#
################################################################################
#
#
#
score   &lt;- c(0:100)
nl      &lt;- c(0.762, 0.762, 0.762, 0.762, 0.762, 0.706, 0.706, 0.706, 0.706, 0.706, 
             0.636, 0.636, 0.636, 0.636, 0.636, 0.464, 0.464, 0.464, 0.464, 0.464, 
             0.371, 0.371, 0.371, 0.371, 0.371, 0.266, 0.266, 0.266, 0.266, 0.266, 
             0.191, 0.191, 0.191, 0.191, 0.191, 0.150, 0.150, 0.150, 0.150, 0.150, 
             0.127, 0.127, 0.127, 0.127, 0.127, 0.066, 0.066, 0.066, 0.066, 0.066, 
             0.039, 0.039, 0.039, 0.039, 0.039, 0.015, 0.015, 0.015, 0.015, 0.015, 
             0.009, 0.009, 0.009, 0.009, 0.009, 0.004, 0.004, 0.004, 0.004, 0.004, 
             0.002, 0.002, 0.002, 0.002, 0.002, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
nu100   &lt;- c(0.873, 0.873, 0.873, 0.873, 0.873, 0.846, 0.846, 0.846, 0.846, 0.846, 
             0.821, 0.821, 0.821, 0.821, 0.821, 0.680, 0.680, 0.680, 0.680, 0.680, 
             0.627, 0.627, 0.627, 0.627, 0.627, 0.504, 0.504, 0.504, 0.504, 0.504, 
             0.409, 0.409, 0.409, 0.409, 0.409, 0.360, 0.360, 0.360, 0.360, 0.360, 
             0.267, 0.267, 0.267, 0.267, 0.267, 0.196, 0.196, 0.196, 0.196, 0.196, 
             0.147, 0.147, 0.147, 0.147, 0.147, 0.071, 0.071, 0.071, 0.071, 0.071, 
             0.053, 0.053, 0.053, 0.053, 0.053, 0.044, 0.044, 0.044, 0.044, 0.044, 
             0.023, 0.023, 0.023, 0.023, 0.023, 0.012, 0.012, 0.012, 0.012, 0.012, 
             0.005, 0.005, 0.005, 0.005, 0.005, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
nu150   &lt;- c(0.984, 0.984, 0.984, 0.984, 0.984, 0.977, 0.977, 0.977, 0.977, 0.977, 
             0.976, 0.976, 0.976, 0.976, 0.976, 0.962, 0.962, 0.962, 0.962, 0.962, 
             0.961, 0.961, 0.961, 0.961, 0.961, 0.887, 0.887, 0.887, 0.887, 0.887, 
             0.843, 0.843, 0.843, 0.843, 0.843, 0.808, 0.808, 0.808, 0.808, 0.808, 
             0.761, 0.761, 0.761, 0.761, 0.761, 0.658, 0.658, 0.658, 0.658, 0.658, 
             0.550, 0.550, 0.550, 0.550, 0.550, 0.426, 0.426, 0.426, 0.426, 0.426, 
             0.348, 0.348, 0.348, 0.348, 0.348, 0.286, 0.286, 0.286, 0.286, 0.286, 
             0.246, 0.246, 0.246, 0.246, 0.246, 0.214, 0.214, 0.214, 0.214, 0.214, 
             0.170, 0.170, 0.170, 0.170, 0.170, 0.083, 0.083, 0.083, 0.083, 0.083, 
             0.039, 0.039, 0.039, 0.039, 0.039, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
nu200   &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 0.995, 0.995, 0.995, 0.995, 0.995, 
             0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 
             0.995, 0.995, 0.995, 0.995, 0.995, 0.979, 0.979, 0.979, 0.979, 0.979, 
             0.960, 0.960, 0.960, 0.960, 0.960, 0.936, 0.936, 0.936, 0.936, 0.936, 
             0.919, 0.919, 0.919, 0.919, 0.919, 0.866, 0.866, 0.866, 0.866, 0.866, 
             0.813, 0.813, 0.813, 0.813, 0.813, 0.756, 0.756, 0.756, 0.756, 0.756, 
             0.649, 0.649, 0.649, 0.649, 0.649, 0.525, 0.525, 0.525, 0.525, 0.525, 
             0.510, 0.510, 0.510, 0.510, 0.510, 0.403, 0.403, 0.403, 0.403, 0.403, 
             0.320, 0.320, 0.320, 0.320, 0.320, 0.249, 0.249, 0.249, 0.249, 0.249, 
             0.099, 0.099, 0.099, 0.099, 0.099, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
extreme &lt;- c(0.658, 0.658, 0.658, 0.658, 0.658, 0.656, 0.656, 0.656, 0.656, 0.656, 
             0.572, 0.572, 0.572, 0.572, 0.572, 0.425, 0.425, 0.425, 0.425, 0.425, 
             0.327, 0.327, 0.327, 0.327, 0.327, 0.229, 0.229, 0.229, 0.229, 0.229, 
             0.169, 0.169, 0.169, 0.169, 0.169, 0.138, 0.138, 0.138, 0.138, 0.138, 
             0.111, 0.111, 0.111, 0.111, 0.111, 0.054, 0.054, 0.054, 0.054, 0.054, 
             0.045, 0.045, 0.045, 0.045, 0.045, 0.018, 0.018, 0.018, 0.018, 0.018, 
             0.010, 0.010, 0.010, 0.010, 0.010, 0.001, 0.001, 0.001, 0.001, 0.001, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
ppp125  &lt;- c(0.979, 0.979, 0.979, 0.979, 0.979, 0.893, 0.893, 0.893, 0.893, 0.893, 
             0.888, 0.888, 0.888, 0.888, 0.888, 0.816, 0.816, 0.816, 0.816, 0.816, 
             0.780, 0.780, 0.780, 0.780, 0.780, 0.658, 0.658, 0.658, 0.658, 0.658, 
             0.570, 0.570, 0.570, 0.570, 0.570, 0.503, 0.503, 0.503, 0.503, 0.503, 
             0.408, 0.408, 0.408, 0.408, 0.408, 0.335, 0.335, 0.335, 0.335, 0.335, 
             0.242, 0.242, 0.242, 0.242, 0.242, 0.145, 0.145, 0.145, 0.145, 0.145, 
             0.109, 0.109, 0.109, 0.109, 0.109, 0.087, 0.087, 0.087, 0.087, 0.087, 
             0.056, 0.056, 0.056, 0.056, 0.056, 0.043, 0.043, 0.043, 0.043, 0.043, 
             0.027, 0.027, 0.027, 0.027, 0.027, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
ppp175  &lt;- c(0.988, 0.988, 0.988, 0.988, 0.988, 0.982, 0.982, 0.982, 0.982, 0.982, 
             0.982, 0.982, 0.982, 0.982, 0.982, 0.969, 0.969, 0.969, 0.969, 0.969, 
             0.963, 0.963, 0.963, 0.963, 0.963, 0.916, 0.916, 0.916, 0.916, 0.916, 
             0.879, 0.879, 0.879, 0.879, 0.879, 0.836, 0.836, 0.836, 0.836, 0.836, 
             0.796, 0.796, 0.796, 0.796, 0.796, 0.688, 0.688, 0.688, 0.688, 0.688, 
             0.603, 0.603, 0.603, 0.603, 0.603, 0.504, 0.504, 0.504, 0.504, 0.504, 
             0.404, 0.404, 0.404, 0.404, 0.404, 0.322, 0.322, 0.322, 0.322, 0.322, 
             0.315, 0.315, 0.315, 0.315, 0.315, 0.258, 0.258, 0.258, 0.258, 0.258, 
             0.197, 0.197, 0.197, 0.197, 0.197, 0.107, 0.107, 0.107, 0.107, 0.107, 
             0.051, 0.051, 0.051, 0.051, 0.051, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
ppp200  &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 0.987, 0.987, 0.987, 0.987, 0.987, 
             0.987, 0.987, 0.987, 0.987, 0.987, 0.986, 0.986, 0.986, 0.986, 0.986, 
             0.984, 0.984, 0.984, 0.984, 0.984, 0.953, 0.953, 0.953, 0.953, 0.953, 
             0.935, 0.935, 0.935, 0.935, 0.935, 0.907, 0.907, 0.907, 0.907, 0.907, 
             0.874, 0.874, 0.874, 0.874, 0.874, 0.796, 0.796, 0.796, 0.796, 0.796, 
             0.742, 0.742, 0.742, 0.742, 0.742, 0.652, 0.652, 0.652, 0.652, 0.652, 
             0.546, 0.546, 0.546, 0.546, 0.546, 0.445, 0.445, 0.445, 0.445, 0.445, 
             0.429, 0.429, 0.429, 0.429, 0.429, 0.340, 0.340, 0.340, 0.340, 0.340, 
             0.267, 0.267, 0.267, 0.267, 0.267, 0.146, 0.146, 0.146, 0.146, 0.146, 
             0.066, 0.066, 0.066, 0.066, 0.066, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
ppp250  &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 0.997, 0.997, 0.997, 0.997, 0.997, 
             0.997, 0.997, 0.997, 0.997, 0.997, 0.997, 0.997, 0.997, 0.997, 0.997, 
             0.997, 0.997, 0.997, 0.997, 0.997, 0.987, 0.987, 0.987, 0.987, 0.987, 
             0.982, 0.982, 0.982, 0.982, 0.982, 0.969, 0.969, 0.969, 0.969, 0.969, 
             0.949, 0.949, 0.949, 0.949, 0.949, 0.915, 0.915, 0.915, 0.915, 0.915, 
             0.879, 0.879, 0.879, 0.879, 0.879, 0.843, 0.843, 0.843, 0.843, 0.843, 
             0.732, 0.732, 0.732, 0.732, 0.732, 0.633, 0.633, 0.633, 0.633, 0.633, 
             0.604, 0.604, 0.604, 0.604, 0.604, 0.507, 0.507, 0.507, 0.507, 0.507, 
             0.409, 0.409, 0.409, 0.409, 0.409, 0.333, 0.333, 0.333, 0.333, 0.333, 
             0.123, 0.123, 0.123, 0.123, 0.123, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
#
#
#
ppiMatrixBGD &lt;- data.frame(score, nl, nu100, nu150, nu200, extreme, 
                           ppp125, ppp175, ppp200, ppp250)
#
# Clean-up
#
rm(nu100, nu150, nu200, extreme, ppp125, ppp175, ppp200, ppp250)



################################################################################
#
# Ghana PPI look-up table
#
################################################################################
#
#
#
nlFood  &lt;- c(0.704, 0.704, 0.704, 0.704, 0.704, 0.704, 0.704, 0.704, 0.704, 0.704, 
             0.507, 0.507, 0.507, 0.507, 0.507, 0.384, 0.384, 0.384, 0.384, 0.384, 
             0.310, 0.310, 0.310, 0.310, 0.310, 0.215, 0.215, 0.215, 0.215, 0.215, 
             0.151, 0.151, 0.151, 0.151, 0.151, 0.081, 0.081, 0.081, 0.081, 0.081, 
             0.054, 0.054, 0.054, 0.054, 0.054, 0.022, 0.022, 0.022, 0.022, 0.022, 
             0.013, 0.013, 0.013, 0.013, 0.013, 0.012, 0.012, 0.012, 0.012, 0.012, 
             0.004, 0.004, 0.004, 0.004, 0.004, 0.001, 0.001, 0.001, 0.001, 0.001, 
             0.001, 0.001, 0.001, 0.001, 0.001, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
nl100   &lt;- c(0.890, 0.890, 0.890, 0.890, 0.890, 0.890, 0.890, 0.890, 0.890, 0.890, 
             0.744, 0.744, 0.744, 0.744, 0.744, 0.623, 0.623, 0.623, 0.623, 0.623, 
             0.587, 0.587, 0.587, 0.587, 0.587, 0.480, 0.480, 0.480, 0.480, 0.480, 
             0.339, 0.339, 0.339, 0.339, 0.339, 0.242, 0.242, 0.242, 0.242, 0.242, 
             0.166, 0.166, 0.166, 0.166, 0.166, 0.101, 0.101, 0.101, 0.101, 0.101, 
             0.050, 0.050, 0.050, 0.050, 0.050, 0.036, 0.036, 0.036, 0.036, 0.036, 
             0.017, 0.017, 0.017, 0.017, 0.017, 0.007, 0.007, 0.007, 0.007, 0.007, 
             0.007, 0.007, 0.007, 0.007, 0.007, 0.002, 0.002, 0.002, 0.002, 0.002, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
nl150   &lt;- c(0.979, 0.979, 0.979, 0.979, 0.979, 0.979, 0.979, 0.979, 0.979, 0.979, 
             0.882, 0.882, 0.882, 0.882, 0.882, 0.855, 0.855, 0.855, 0.855, 0.855, 
             0.849, 0.849, 0.849, 0.849, 0.849, 0.758, 0.758, 0.758, 0.758, 0.758, 
             0.655, 0.655, 0.655, 0.655, 0.655, 0.537, 0.537, 0.537, 0.537, 0.537, 
             0.392, 0.392, 0.392, 0.392, 0.392, 0.309, 0.309, 0.309, 0.309, 0.309, 
             0.211, 0.211, 0.211, 0.211, 0.211, 0.145, 0.145, 0.145, 0.145, 0.145, 
             0.085, 0.085, 0.085, 0.085, 0.085, 0.049, 0.049, 0.049, 0.049, 0.049, 
             0.037, 0.037, 0.037, 0.037, 0.037, 0.009, 0.009, 0.009, 0.009, 0.009, 
             0.002, 0.002, 0.002, 0.002, 0.002, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
nl200   &lt;- c(0.991, 0.991, 0.991, 0.991, 0.991, 0.991, 0.991, 0.991, 0.991, 0.991, 
             0.963, 0.963, 0.963, 0.963, 0.963, 0.942, 0.942, 0.942, 0.942, 0.942, 
             0.918, 0.918, 0.918, 0.918, 0.918, 0.891, 0.891, 0.891, 0.891, 0.891, 
             0.819, 0.819, 0.819, 0.819, 0.819, 0.739, 0.739, 0.739, 0.739, 0.739, 
             0.652, 0.652, 0.652, 0.652, 0.652, 0.534, 0.534, 0.534, 0.534, 0.534, 
             0.408, 0.408, 0.408, 0.408, 0.408, 0.304, 0.304, 0.304, 0.304, 0.304, 
             0.227, 0.227, 0.227, 0.227, 0.227, 0.154, 0.154, 0.154, 0.154, 0.154, 
             0.097, 0.097, 0.097, 0.097, 0.097, 0.046, 0.046, 0.046, 0.046, 0.046, 
             0.011, 0.011, 0.011, 0.011, 0.011, 0.004, 0.004, 0.004, 0.004, 0.004, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
ppp125  &lt;- c(0.839, 0.839, 0.839, 0.839, 0.839, 0.839, 0.839, 0.839, 0.839, 0.839, 
             0.596, 0.596, 0.596, 0.596, 0.596, 0.473, 0.473, 0.473, 0.473, 0.473, 
             0.394, 0.394, 0.394, 0.394, 0.394, 0.311, 0.311, 0.311, 0.311, 0.311, 
             0.203, 0.203, 0.203, 0.203, 0.203, 0.106, 0.106, 0.106, 0.106, 0.106, 
             0.078, 0.078, 0.078, 0.078, 0.078, 0.035, 0.035, 0.035, 0.035, 0.035, 
             0.015, 0.015, 0.015, 0.015, 0.015, 0.015, 0.015, 0.015, 0.015, 0.015, 
             0.007, 0.007, 0.007, 0.007, 0.007, 0.001, 0.001, 0.001, 0.001, 0.001, 
             0.001, 0.001, 0.001, 0.001, 0.001, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
ppp250  &lt;- c(0.979, 0.979, 0.979, 0.979, 0.979, 0.979, 0.979, 0.979, 0.979, 0.979, 
             0.935, 0.935, 0.935, 0.935, 0.935, 0.882, 0.882, 0.882, 0.882, 0.882, 
             0.861, 0.861, 0.861, 0.861, 0.861, 0.794, 0.794, 0.794, 0.794, 0.794, 
             0.694, 0.694, 0.694, 0.694, 0.694, 0.549, 0.549, 0.549, 0.549, 0.549, 
             0.420, 0.420, 0.420, 0.420, 0.420, 0.313, 0.313, 0.313, 0.313, 0.313, 
             0.225, 0.225, 0.225, 0.225, 0.225, 0.155, 0.155, 0.155, 0.155, 0.155, 
             0.090, 0.090, 0.090, 0.090, 0.090, 0.056, 0.056, 0.056, 0.056, 0.056, 
             0.037, 0.037, 0.037, 0.037, 0.037, 0.008, 0.008, 0.008, 0.008, 0.008, 
             0.005, 0.005, 0.005, 0.005, 0.005, 0.002, 0.002, 0.002, 0.002, 0.002, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
ppp375  &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
             0.979, 0.979, 0.979, 0.979, 0.979, 0.964, 0.964, 0.964, 0.964, 0.964, 
             0.963, 0.963, 0.963, 0.963, 0.963, 0.944, 0.944, 0.944, 0.944, 0.944, 
             0.875, 0.875, 0.875, 0.875, 0.875, 0.796, 0.796, 0.796, 0.796, 0.796, 
             0.745, 0.745, 0.745, 0.745, 0.745, 0.643, 0.643, 0.643, 0.643, 0.643, 
             0.494, 0.494, 0.494, 0.494, 0.494, 0.417, 0.417, 0.417, 0.417, 0.417, 
             0.313, 0.313, 0.313, 0.313, 0.313, 0.224, 0.224, 0.224, 0.224, 0.224, 
             0.155, 0.155, 0.155, 0.155, 0.155, 0.077, 0.077, 0.077, 0.077, 0.077, 
             0.022, 0.022, 0.022, 0.022, 0.022, 0.007, 0.007, 0.007, 0.007, 0.007, 
             0.002, 0.002, 0.002, 0.002, 0.002, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
#
#
#
ppiMatrixGHA &lt;- data.frame(score, nlFood, nl100, nl150, nl200, ppp125, ppp250, ppp375)
#
# Clean-up
#
rm(nlFood, nl100, nl150, nl200, ppp125, ppp250, ppp375)

             
################################################################################
#
# Kenya PPI look-up table
#
################################################################################
#
#
#                          
nlFood  &lt;- c(0.954, 0.954, 0.954, 0.954, 0.954, 0.726, 0.726, 0.726, 0.726, 0.726, 
             0.571, 0.571, 0.571, 0.571, 0.571, 0.474, 0.474, 0.474, 0.474, 0.474, 
             0.378, 0.378, 0.378, 0.378, 0.378, 0.328, 0.328, 0.328, 0.328, 0.328, 
             0.235, 0.235, 0.235, 0.235, 0.235, 0.127, 0.127, 0.127, 0.127, 0.127, 
             0.099, 0.099, 0.099, 0.099, 0.099, 0.047, 0.047, 0.047, 0.047, 0.047, 
             0.019, 0.019, 0.019, 0.019, 0.019, 0.009, 0.009, 0.009, 0.009, 0.009, 
             0.005, 0.005, 0.005, 0.005, 0.005, 0.009, 0.009, 0.009, 0.009, 0.009, 
             0.002, 0.002, 0.002, 0.002, 0.002, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.004, 0.004, 0.004, 0.004, 0.004, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
nl150   &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
             0.965, 0.965, 0.965, 0.965, 0.965, 0.957, 0.957, 0.957, 0.957, 0.957, 
             0.932, 0.932, 0.932, 0.932, 0.932, 0.891, 0.891, 0.891, 0.891, 0.891, 
             0.833, 0.833, 0.833, 0.833, 0.833, 0.757, 0.757, 0.757, 0.757, 0.757, 
             0.648, 0.648, 0.648, 0.648, 0.648, 0.643, 0.643, 0.643, 0.643, 0.643, 
             0.494, 0.494, 0.494, 0.494, 0.494, 0.418, 0.418, 0.418, 0.418, 0.418, 
             0.323, 0.323, 0.323, 0.323, 0.323, 0.204, 0.204, 0.204, 0.204, 0.204, 
             0.111, 0.111, 0.111, 0.111, 0.111, 0.041, 0.041, 0.041, 0.041, 0.041, 
             0.067, 0.067, 0.067, 0.067, 0.067, 0.041, 0.041, 0.041, 0.041, 0.041, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
extreme &lt;- c(0.915, 0.915, 0.915, 0.915, 0.915, 0.739, 0.739, 0.739, 0.739, 0.739, 
             0.579, 0.579, 0.579, 0.579, 0.579, 0.469, 0.469, 0.469, 0.469, 0.469, 
             0.463, 0.463, 0.463, 0.463, 0.463, 0.365, 0.365, 0.365, 0.365, 0.365, 
             0.276, 0.276, 0.276, 0.276, 0.276, 0.168, 0.168, 0.168, 0.168, 0.168, 
             0.154, 0.154, 0.154, 0.154, 0.154, 0.074, 0.074, 0.074, 0.074, 0.074, 
             0.025, 0.025, 0.025, 0.025, 0.025, 0.023, 0.023, 0.023, 0.023, 0.023, 
             0.003, 0.003, 0.003, 0.003, 0.003, 0.012, 0.012, 0.012, 0.012, 0.012, 
             0.002, 0.002, 0.002, 0.002, 0.002, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.004, 0.004, 0.004, 0.004, 0.004, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000,
             0.000)
ppp125  &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 0.972, 0.972, 0.972, 0.972, 0.972, 
             0.837, 0.837, 0.837, 0.837, 0.837, 0.876, 0.876, 0.876, 0.876, 0.876, 
             0.811, 0.811, 0.811, 0.811, 0.811, 0.707, 0.707, 0.707, 0.707, 0.707, 
             0.631, 0.631, 0.631, 0.631, 0.631, 0.484, 0.484, 0.484, 0.484, 0.484, 
             0.351, 0.351, 0.351, 0.351, 0.351, 0.254, 0.254, 0.254, 0.254, 0.254, 
             0.087, 0.087, 0.087, 0.087, 0.087, 0.078, 0.078, 0.078, 0.078, 0.078, 
             0.010, 0.010, 0.010, 0.010, 0.010, 0.011, 0.011, 0.011, 0.011, 0.011, 
             0.002, 0.002, 0.002, 0.002, 0.002, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.004, 0.004, 0.004, 0.004, 0.004, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
ppp250  &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
             0.993, 0.993, 0.993, 0.993, 0.993, 0.991, 0.991, 0.991, 0.991, 0.991, 
             0.962, 0.962, 0.962, 0.962, 0.962, 0.954, 0.954, 0.954, 0.954, 0.954, 
             0.910, 0.910, 0.910, 0.910, 0.910, 0.827, 0.827, 0.827, 0.827, 0.827, 
             0.755, 0.755, 0.755, 0.755, 0.755, 0.755, 0.755, 0.755, 0.755, 0.755, 
             0.611, 0.611, 0.611, 0.611, 0.611, 0.440, 0.440, 0.440, 0.440, 0.440, 
             0.290, 0.290, 0.290, 0.290, 0.290, 0.200, 0.200, 0.200, 0.200, 0.200, 
             0.094, 0.094, 0.094, 0.094, 0.094, 0.060, 0.060, 0.060, 0.060, 0.060, 
             0.022, 0.022, 0.022, 0.022, 0.022, 0.041, 0.041, 0.041, 0.041, 0.041, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
#
#
#
ppiMatrixKEN &lt;- data.frame(score, nlFood, nl150, extreme, ppp125, ppp250)
#
#
#
rm(nlFood, nl150, extreme, ppp125, ppp250)


################################################################################
#
# Madagascar PPI look-up table
#
################################################################################
#
#
#
nlFood  &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
             0.958, 0.958, 0.958, 0.958, 0.958, 0.882, 0.882, 0.882, 0.882, 0.882, 
             0.822, 0.822, 0.822, 0.822, 0.822, 0.770, 0.770, 0.770, 0.770, 0.770, 
             0.637, 0.637, 0.637, 0.637, 0.637, 0.524, 0.524, 0.524, 0.524, 0.524, 
             0.360, 0.360, 0.360, 0.360, 0.360, 0.230, 0.230, 0.230, 0.230, 0.230, 
             0.107, 0.107, 0.107, 0.107, 0.107, 0.044, 0.044, 0.044, 0.044, 0.044, 
             0.029, 0.029, 0.029, 0.029, 0.029, 0.015, 0.015, 0.015, 0.015, 0.015, 
             0.007, 0.007, 0.007, 0.007, 0.007, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
nl100   &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
             0.990, 0.990, 0.990, 0.990, 0.990, 0.983, 0.983, 0.983, 0.983, 0.983, 
             0.972, 0.972, 0.972, 0.972, 0.972, 0.946, 0.946, 0.946, 0.946, 0.946, 
             0.891, 0.891, 0.891, 0.891, 0.891, 0.833, 0.833, 0.833, 0.833, 0.833, 
             0.689, 0.689, 0.689, 0.689, 0.689, 0.519, 0.519, 0.519, 0.519, 0.519, 
             0.385, 0.385, 0.385, 0.385, 0.385, 0.185, 0.185, 0.185, 0.185, 0.185, 
             0.118, 0.118, 0.118, 0.118, 0.118, 0.086, 0.086, 0.086, 0.086, 0.086, 
             0.023, 0.023, 0.023, 0.023, 0.023, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
nl150   &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
             1.000, 1.000, 1.000, 1.000, 1.000, 0.998, 0.998, 0.998, 0.998, 0.998, 
             0.996, 0.996, 0.996, 0.996, 0.996, 0.988, 0.988, 0.988, 0.988, 0.988, 
             0.980, 0.980, 0.980, 0.980, 0.980, 0.971, 0.971, 0.971, 0.971, 0.971, 
             0.912, 0.912, 0.912, 0.912, 0.912, 0.846, 0.846, 0.846, 0.846, 0.846, 
             0.739, 0.739, 0.739, 0.739, 0.739, 0.530, 0.530, 0.530, 0.530, 0.530, 
             0.371, 0.371, 0.371, 0.371, 0.371, 0.289, 0.289, 0.289, 0.289, 0.289, 
             0.151, 0.151, 0.151, 0.151, 0.151, 0.066, 0.066, 0.066, 0.066, 0.066, 
             0.016, 0.016, 0.016, 0.016, 0.016, 0.008, 0.008, 0.008, 0.008, 0.008, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
nl200   &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
             1.000, 1.000, 1.000, 1.000, 1.000, 0.999, 0.999, 0.999, 0.999, 0.999, 
             0.999, 0.999, 0.999, 0.999, 0.999, 0.996, 0.996, 0.996, 0.996, 0.996, 
             0.991, 0.991, 0.991, 0.991, 0.991, 0.991, 0.991, 0.991, 0.991, 0.991, 
             0.969, 0.969, 0.969, 0.969, 0.969, 0.943, 0.943, 0.943, 0.943, 0.943, 
             0.892, 0.892, 0.892, 0.892, 0.892, 0.767, 0.767, 0.767, 0.767, 0.767, 
             0.609, 0.609, 0.609, 0.609, 0.609, 0.542, 0.542, 0.542, 0.542, 0.542, 
             0.348, 0.348, 0.348, 0.348, 0.348, 0.190, 0.190, 0.190, 0.190, 0.190, 
             0.061, 0.061, 0.061, 0.061, 0.061, 0.023, 0.023, 0.023, 0.023, 0.023, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
median100 &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
               0.829, 0.829, 0.829, 0.829, 0.829, 0.701, 0.701, 0.701, 0.701, 0.701, 
               0.563, 0.563, 0.563, 0.563, 0.563, 0.488, 0.488, 0.488, 0.488, 0.488, 
               0.369, 0.369, 0.369, 0.369, 0.369, 0.299, 0.299, 0.299, 0.299, 0.299, 
               0.191, 0.191, 0.191, 0.191, 0.191, 0.133, 0.133, 0.133, 0.133, 0.133, 
               0.047, 0.047, 0.047, 0.047, 0.047, 0.022, 0.022, 0.022, 0.022, 0.022, 
               0.013, 0.013, 0.013, 0.013, 0.013, 0.008, 0.008, 0.008, 0.008, 0.008, 
               0.005, 0.005, 0.005, 0.005, 0.005, 0.000, 0.000, 0.000, 0.000, 0.000, 
               0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
               0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
               0.000)
ppp125   &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
              1.000, 1.000, 1.000, 1.000, 1.000, 0.998, 0.998, 0.998, 0.998, 0.998, 
              0.995, 0.995, 0.995, 0.995, 0.995, 0.984, 0.984, 0.984, 0.984, 0.984, 
              0.970, 0.970, 0.970, 0.970, 0.970, 0.954, 0.954, 0.954, 0.954, 0.954, 
              0.887, 0.887, 0.887, 0.887, 0.887, 0.813, 0.813, 0.813, 0.813, 0.813, 
              0.689, 0.689, 0.689, 0.689, 0.689, 0.457, 0.457, 0.457, 0.457, 0.457, 
              0.307, 0.307, 0.307, 0.307, 0.307, 0.252, 0.252, 0.252, 0.252, 0.252, 
              0.119, 0.119, 0.119, 0.119, 0.119, 0.063, 0.063, 0.063, 0.063, 0.063, 
              0.014, 0.014, 0.014, 0.014, 0.014, 0.007, 0.007, 0.007, 0.007, 0.007, 
              0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
              0.000)
ppp200   &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
              1.000, 1.000, 1.000, 1.000, 1.000, 0.999, 0.999, 0.999, 0.999, 0.999, 
              0.999, 0.999, 0.999, 0.999, 0.999, 0.996, 0.996, 0.996, 0.996, 0.996, 
              0.994, 0.994, 0.994, 0.994, 0.994, 0.993, 0.993, 0.993, 0.993, 0.993, 
              0.977, 0.977, 0.977, 0.977, 0.977, 0.960, 0.960, 0.960, 0.960, 0.960, 
              0.924, 0.924, 0.924, 0.924, 0.924, 0.817, 0.817, 0.817, 0.817, 0.817, 
              0.721, 0.721, 0.721, 0.721, 0.721, 0.653, 0.653, 0.653, 0.653, 0.653, 
              0.418, 0.418, 0.418, 0.418, 0.418, 0.235, 0.235, 0.235, 0.235, 0.235, 
              0.129, 0.129, 0.129, 0.129, 0.129, 0.053, 0.053, 0.053, 0.053, 0.053, 
              0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
              0.000)  
ppp250   &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
              1.000, 1.000, 1.000, 1.000, 1.000, 0.999, 0.999, 0.999, 0.999, 0.999, 
              0.999, 0.999, 0.999, 0.999, 0.999, 0.998, 0.998, 0.998, 0.998, 0.998, 
              0.997, 0.997, 0.997, 0.997, 0.997, 0.997, 0.997, 0.997, 0.997, 0.997, 
              0.991, 0.991, 0.991, 0.991, 0.991, 0.978, 0.978, 0.978, 0.978, 0.978, 
              0.962, 0.962, 0.962, 0.962, 0.962, 0.918, 0.918, 0.918, 0.918, 0.918, 
              0.864, 0.864, 0.864, 0.864, 0.864, 0.800, 0.800, 0.800, 0.800, 0.800, 
              0.597, 0.597, 0.597, 0.597, 0.597, 0.341, 0.341, 0.341, 0.341, 0.341, 
              0.265, 0.265, 0.265, 0.265, 0.265, 0.104, 0.104, 0.104, 0.104, 0.104, 
              0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
              0.000)
ppp500   &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
              1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
              1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
              1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
              0.998, 0.998, 0.998, 0.998, 0.998, 0.994, 0.994, 0.994, 0.994, 0.994, 
              0.992, 0.992, 0.992, 0.992, 0.992, 0.987, 0.987, 0.987, 0.987, 0.987, 
              0.983, 0.983, 0.983, 0.983, 0.983, 0.970, 0.970, 0.970, 0.970, 0.970, 
              0.946, 0.946, 0.946, 0.946, 0.946, 0.851, 0.851, 0.851, 0.851, 0.851, 
              0.706, 0.706, 0.706, 0.706, 0.706, 0.537, 0.537, 0.537, 0.537, 0.537, 
              0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
              0.000)
#
#
#
ppiMatrixMDG &lt;- data.frame(score, nlFood, nl100, nl150, nl200, 
                           median100, ppp125, ppp200, ppp250, ppp500)
#
#
#
rm(nlFood, nl100, nl150, nl200, median100, ppp125, ppp200, ppp250, ppp500)                           
                   
################################################################################
#
# Mozambique PPI look-up table
#
################################################################################
#
#
#
nl100   &lt;- c(0.971, 0.971, 0.971, 0.971, 0.971, 0.930, 0.930, 0.930, 0.930, 0.930, 
             0.899, 0.899, 0.899, 0.899, 0.899, 0.794, 0.794, 0.794, 0.794, 0.794, 
             0.761, 0.761, 0.761, 0.761, 0.761, 0.720, 0.720, 0.720, 0.720, 0.720, 
             0.608, 0.608, 0.608, 0.608, 0.608, 0.508, 0.508, 0.508, 0.508, 0.508, 
             0.317, 0.317, 0.317, 0.317, 0.317, 0.288, 0.288, 0.288, 0.288, 0.288, 
             0.214, 0.214, 0.214, 0.214, 0.214, 0.085, 0.085, 0.085, 0.085, 0.085, 
             0.072, 0.072, 0.072, 0.072, 0.072, 0.032, 0.032, 0.032, 0.032, 0.032, 
             0.006, 0.006, 0.006, 0.006, 0.006, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
nl150   &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 0.986, 0.986, 0.986, 0.986, 0.986, 
             0.975, 0.975, 0.975, 0.975, 0.975, 0.934, 0.934, 0.934, 0.934, 0.934, 
             0.918, 0.918, 0.918, 0.918, 0.918, 0.911, 0.911, 0.911, 0.911, 0.911, 
             0.882, 0.882, 0.882, 0.882, 0.882, 0.784, 0.784, 0.784, 0.784, 0.784, 
             0.671, 0.671, 0.671, 0.671, 0.671, 0.521, 0.521, 0.521, 0.521, 0.521, 
             0.451, 0.451, 0.451, 0.451, 0.451, 0.306, 0.306, 0.306, 0.306, 0.306, 
             0.249, 0.249, 0.249, 0.249, 0.249, 0.156, 0.156, 0.156, 0.156, 0.156, 
             0.048, 0.048, 0.048, 0.048, 0.048, 0.013, 0.013, 0.013, 0.013, 0.013, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
nl200   &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
             0.996, 0.996, 0.996, 0.996, 0.996, 0.977, 0.977, 0.977, 0.977, 0.977, 
             0.973, 0.973, 0.973, 0.973, 0.973, 0.973, 0.973, 0.973, 0.973, 0.973, 
             0.969, 0.969, 0.969, 0.969, 0.969, 0.892, 0.892, 0.892, 0.892, 0.892, 
             0.843, 0.843, 0.843, 0.843, 0.843, 0.738, 0.738, 0.738, 0.738, 0.738, 
             0.678, 0.678, 0.678, 0.678, 0.678, 0.507, 0.507, 0.507, 0.507, 0.507, 
             0.435, 0.435, 0.435, 0.435, 0.435, 0.271, 0.271, 0.271, 0.271, 0.271, 
             0.156, 0.156, 0.156, 0.156, 0.156, 0.099, 0.099, 0.099, 0.099, 0.099, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
extreme &lt;- c(0.777, 0.777, 0.777, 0.777, 0.777, 0.656, 0.656, 0.656, 0.656, 0.656, 
             0.629, 0.629, 0.629, 0.629, 0.629, 0.523, 0.523, 0.523, 0.523, 0.523, 
             0.429, 0.429, 0.429, 0.429, 0.429, 0.350, 0.350, 0.350, 0.350, 0.350, 
             0.270, 0.270, 0.270, 0.270, 0.270, 0.199, 0.199, 0.199, 0.199, 0.199, 
             0.129, 0.129, 0.129, 0.129, 0.129, 0.097, 0.097, 0.097, 0.097, 0.097, 
             0.057, 0.057, 0.057, 0.057, 0.057, 0.032, 0.032, 0.032, 0.032, 0.032, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
ppp125  &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 0.969, 0.969, 0.969, 0.969, 0.969, 
             0.926, 0.926, 0.926, 0.926, 0.926, 0.841, 0.841, 0.841, 0.841, 0.841, 
             0.816, 0.816, 0.816, 0.816, 0.816, 0.783, 0.783, 0.783, 0.783, 0.783, 
             0.685, 0.685, 0.685, 0.685, 0.685, 0.593, 0.593, 0.593, 0.593, 0.593, 
             0.415, 0.415, 0.415, 0.415, 0.415, 0.330, 0.330, 0.330, 0.330, 0.330, 
             0.263, 0.263, 0.263, 0.263, 0.263, 0.119, 0.119, 0.119, 0.119, 0.119, 
             0.101, 0.101, 0.101, 0.101, 0.101, 0.050, 0.050, 0.050, 0.050, 0.050, 
             0.014, 0.014, 0.014, 0.014, 0.014, 0.000, 0.000, 0.000, 0.000, 0.000,
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
ppp250  &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
             1.000, 1.000, 1.000, 1.000, 1.000, 0.985, 0.985, 0.985, 0.985, 0.985, 
             0.981, 0.981, 0.981, 0.981, 0.981, 0.981, 0.981, 0.981, 0.981, 0.981, 
             0.978, 0.978, 0.978, 0.978, 0.978, 0.918, 0.918, 0.918, 0.918, 0.918, 
             0.880, 0.880, 0.880, 0.880, 0.880, 0.782, 0.782, 0.782, 0.782, 0.782, 
             0.734, 0.734, 0.734, 0.734, 0.734, 0.586, 0.586, 0.586, 0.586, 0.586, 
             0.516, 0.516, 0.516, 0.516, 0.516, 0.317, 0.317, 0.317, 0.317, 0.317, 
             0.210, 0.210, 0.210, 0.210, 0.210, 0.135, 0.135, 0.135, 0.135, 0.135, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
#
#
#
ppiMatrixMOZ &lt;- data.frame(score, nl100, nl150, nl200, extreme, ppp125, ppp250)
#
#
#
rm(nl100, nl150, nl200, extreme, ppp125, ppp250)                                                       


################################################################################
#
# Zambia PPI look-up table
#
################################################################################
#
#
#
nlFood  &lt;- c(0.916, 0.916, 0.916, 0.916, 0.916, 0.828, 0.828, 0.828, 0.828, 0.828, 
             0.756, 0.756, 0.756, 0.756, 0.756, 0.697, 0.697, 0.697, 0.697, 0.697, 
             0.583, 0.583, 0.583, 0.583, 0.583, 0.526, 0.526, 0.526, 0.526, 0.526, 
             0.388, 0.388, 0.388, 0.388, 0.388, 0.253, 0.253, 0.253, 0.253, 0.253, 
             0.188, 0.188, 0.188, 0.188, 0.188, 0.076, 0.076, 0.076, 0.076, 0.076, 
             0.028, 0.028, 0.028, 0.028, 0.028, 0.004, 0.004, 0.004, 0.004, 0.004, 
             0.003, 0.003, 0.003, 0.003, 0.003, 0.002, 0.002, 0.002, 0.002, 0.002, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.00, 
             0.000)
nu100   &lt;- c(0.983, 0.983, 0.983, 0.983, 0.983, 0.968, 0.968, 0.968, 0.968, 0.968, 
             0.943, 0.943, 0.943, 0.943, 0.943, 0.922, 0.922, 0.922, 0.922, 0.922, 
             0.881, 0.881, 0.881, 0.881, 0.881, 0.817, 0.817, 0.817, 0.817, 0.817, 
             0.710, 0.710, 0.710, 0.710, 0.710, 0.600, 0.600, 0.600, 0.600, 0.600, 
             0.487, 0.487, 0.487, 0.487, 0.487, 0.328, 0.328, 0.328, 0.328, 0.328, 
             0.193, 0.193, 0.193, 0.193, 0.193, 0.106, 0.106, 0.106, 0.106, 0.106, 
             0.053, 0.053, 0.053, 0.053, 0.053, 0.034, 0.034, 0.034, 0.034, 0.034, 
             0.014, 0.014, 0.014, 0.014, 0.014, 0.003, 0.003, 0.003, 0.003, 0.003, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
nu150   &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 0.999, 0.999, 0.999, 0.999, 0.999, 
             0.983, 0.983, 0.983, 0.983, 0.983, 0.979, 0.979, 0.979, 0.979, 0.979, 
             0.970, 0.970, 0.970, 0.970, 0.970, 0.956, 0.956, 0.956, 0.956, 0.956, 
             0.911, 0.911, 0.911, 0.911, 0.911, 0.874, 0.874, 0.874, 0.874, 0.874, 
             0.786, 0.786, 0.786, 0.786, 0.786, 0.631, 0.631, 0.631, 0.631, 0.631, 
             0.433, 0.433, 0.433, 0.433, 0.433, 0.351, 0.351, 0.351, 0.351, 0.351, 
             0.250, 0.250, 0.250, 0.250, 0.250, 0.191, 0.191, 0.191, 0.191, 0.191, 
             0.088, 0.088, 0.088, 0.088, 0.088, 0.063, 0.063, 0.063, 0.063, 0.063, 
             0.017, 0.017, 0.017, 0.017, 0.017, 0.002, 0.002, 0.002, 0.002, 0.002, 
             0.001, 0.001, 0.001, 0.001, 0.001, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)                                          
nu200   &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 0.999, 0.999, 0.999, 0.999, 0.999, 
             0.994, 0.994, 0.994, 0.994, 0.994, 0.994, 0.994, 0.994, 0.994, 0.994, 
             0.994, 0.994, 0.994, 0.994, 0.994, 0.989, 0.989, 0.989, 0.989, 0.989, 
             0.974, 0.974, 0.974, 0.974, 0.974, 0.957, 0.957, 0.957, 0.957, 0.957, 
             0.890, 0.890, 0.890, 0.890, 0.890, 0.821, 0.821, 0.821, 0.821, 0.821, 
             0.675, 0.675, 0.675, 0.675, 0.675, 0.551, 0.551, 0.551, 0.551, 0.551, 
             0.514, 0.514, 0.514, 0.514, 0.514, 0.376, 0.376, 0.376, 0.376, 0.376, 
             0.227, 0.227, 0.227, 0.227, 0.227, 0.168, 0.168, 0.168, 0.168, 0.168, 
             0.074, 0.074, 0.074, 0.074, 0.074, 0.027, 0.027, 0.027, 0.027, 0.027, 
             0.003, 0.003, 0.003, 0.003, 0.003, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
extreme &lt;- c(0.867, 0.867, 0.867, 0.867, 0.867, 0.682, 0.682, 0.682, 0.682, 0.682, 
             0.622, 0.622, 0.622, 0.622, 0.622, 0.520, 0.520, 0.520, 0.520, 0.520, 
             0.418, 0.418, 0.418, 0.418, 0.418, 0.362, 0.362, 0.362, 0.362, 0.362, 
             0.244, 0.244, 0.244, 0.244, 0.244, 0.143, 0.143, 0.143, 0.143, 0.143, 
             0.101, 0.101, 0.101, 0.101, 0.101, 0.045, 0.045, 0.045, 0.045, 0.045, 
             0.015, 0.015, 0.015, 0.015, 0.015, 0.006, 0.006, 0.006, 0.006, 0.006, 
             0.004, 0.004, 0.004, 0.004, 0.004, 0.004, 0.004, 0.004, 0.004, 0.004, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
ppp125  &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 0.999, 0.999, 0.999, 0.999, 0.999, 
             0.979, 0.979, 0.979, 0.979, 0.979, 0.970, 0.970, 0.970, 0.970, 0.970, 
             0.965, 0.965, 0.965, 0.965, 0.965, 0.948, 0.948, 0.948, 0.948, 0.948, 
             0.874, 0.874, 0.874, 0.874, 0.874, 0.801, 0.801, 0.801, 0.801, 0.801, 
             0.699, 0.699, 0.699, 0.699, 0.699, 0.543, 0.543, 0.543, 0.543, 0.543, 
             0.351, 0.351, 0.351, 0.351, 0.351, 0.234, 0.234, 0.234, 0.234, 0.234, 
             0.162, 0.162, 0.162, 0.162, 0.162, 0.118, 0.118, 0.118, 0.118, 0.118, 
             0.054, 0.054, 0.054, 0.054, 0.054, 0.034, 0.034, 0.034, 0.034, 0.034, 
             0.006, 0.006, 0.006, 0.006, 0.006, 0.001, 0.001, 0.001, 0.001, 0.001, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
ppp200  &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
             0.999, 0.999, 0.999, 0.999, 0.999, 0.996, 0.996, 0.996, 0.996, 0.996, 
             0.995, 0.995, 0.995, 0.995, 0.995, 0.990, 0.990, 0.990, 0.990, 0.990, 
             0.979, 0.979, 0.979, 0.979, 0.979, 0.964, 0.964, 0.964, 0.964, 0.964, 
             0.892, 0.892, 0.892, 0.892, 0.892, 0.833, 0.833, 0.833, 0.833, 0.833, 
             0.686, 0.686, 0.686, 0.686, 0.686, 0.565, 0.565, 0.565, 0.565, 0.565, 
             0.513, 0.513, 0.513, 0.513, 0.513, 0.394, 0.394, 0.394, 0.394, 0.394, 
             0.285, 0.285, 0.285, 0.285, 0.285, 0.213, 0.213, 0.213, 0.213, 0.213, 
             0.095, 0.095, 0.095, 0.095, 0.095, 0.033, 0.033, 0.033, 0.033, 0.033, 
             0.026, 0.026, 0.026, 0.026, 0.026, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
ppp250  &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
             1.000, 1.000, 1.000, 1.000, 1.000, 0.998, 0.998, 0.998, 0.998, 0.998, 
             0.998, 0.998, 0.998, 0.998, 0.998, 0.996, 0.996, 0.996, 0.996, 0.996, 
             0.988, 0.988, 0.988, 0.988, 0.988, 0.980, 0.980, 0.980, 0.980, 0.980, 
             0.957, 0.957, 0.957, 0.957, 0.957, 0.913, 0.913, 0.913, 0.913, 0.913, 
             0.811, 0.811, 0.811, 0.811, 0.811, 0.711, 0.711, 0.711, 0.711, 0.711, 
             0.670, 0.670, 0.670, 0.670, 0.670, 0.544, 0.544, 0.544, 0.544, 0.544, 
             0.419, 0.419, 0.419, 0.419, 0.419, 0.341, 0.341, 0.341, 0.341, 0.341, 
             0.170, 0.170, 0.170, 0.170, 0.170, 0.130, 0.130, 0.130, 0.130, 0.130, 
             0.053, 0.053, 0.053, 0.053, 0.053, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
#
#
#
ppiMatrixZMB &lt;- data.frame(score, nlFood, nu100, nu150, nu200, extreme, ppp125,
                           ppp200, ppp250)
#
#
#
rm(score, nlFood, nu100, nu150, nu200, extreme, ppp125, ppp200, ppp250)

                                                                                                                                                                                                                                                                


################################################################################
#
# Function to produce response based on selection
#
################################################################################
#
# 
#
onOK &lt;- function()
  {
  #
  # Extract name of country selected
  #
  cValue &lt;- as.character(tclvalue(choice.value))
  #
  # Close dialog box for country choices
  #
  tkdestroy(choice)
  #
  # Remind user of country chosen
  #
  tkmessageBox(title = &quot;Selected country&quot;,
	          message = paste(&quot;You have selected &quot;, cValue, &quot;.&quot;, sep = &quot;&quot;),
		     icon = &quot;info&quot;,
		     type = &quot;ok&quot;)
  #
  # Return result for cValue
  #
  return(cValue)
  }


################################################################################
#
# Select which country the data being analysed is from
#
################################################################################
#
# Vector of country choices
#
countries &lt;- c(&quot;Bangladesh&quot;, &quot;Ghana&quot;, &quot;Kenya&quot;, &quot;Madagascar&quot;, &quot;Mozambique&quot;, &quot;Zambia&quot;)
#
# Open dialog box
#
choice &lt;- tktoplevel()
#
# Label teh dialog box
#
tkwm.title(choice, &quot;Select country&quot;)
#
# Cycle through countries
#
for(i in 1:length(countries))
  {
  #
  # Add buttons in dialog box for each country choice
  # 	
  assign(x = paste(&quot;choice$env$choice&quot;, i, sep = &quot;&quot;),
	    value = tk2radiobutton(choice))
  }
#
# Select which radio button is selected by default
#
choice.value &lt;- tclVar(countries[1])
#
# Cycle through countries
#
for(i in 1:length(countries))
  {
  #
  # Configure radio buttons
  #
  tkconfigure(widget = get(paste(&quot;choice$env$choice&quot;, i, sep = &quot;&quot;)),
		    variable = choice.value,
		    value = countries[i])
  }
#
# Add a question prompt for country selection
#
tkgrid(tk2label(parent = choice, text = &quot;Which country data are you analysing?&quot;),
	           columnspan = 2, padx = 10, pady = c(15, 5))
#
# Cycle through countries
#
for(i in 1:length(countries))
  {
  #
  # Position choices on dialog box
  #    
  tkgrid(tk2label(parent = choice, text = countries[i]),
	             get(paste(&quot;choice$env$choice&quot;, i, sep = &quot;&quot;)),
	             padx = 10, pady = c(0, i + 5))
  }
#
# Create &apos;OK&apos; button
#  
choice$env$butOK &lt;- tk2button(choice, text = &quot;OK&quot;, width = -6, command = onOK)
#
# Define size parameters for dialog box
#
tkgrid(choice$env$butOK, columnspan = 2, padx = 10, pady = c(5, 15))
#
# Focus to the choice dialog box
#
tkfocus(choice)
#
#
#
tkwait.window(choice)
#
# Clean-up
#
rm(i)


################################################################################
#
# Get country selection
#
################################################################################
#
# Extract country choice
#
country &lt;- as.character(tclvalue(choice.value))
#
# Determine country code
#
ccode &lt;- ifelse(country == &quot;Bangladesh&quot;, &quot;BGD&quot;,
	      ifelse(country == &quot;Ghana&quot;, &quot;GHA&quot;,
		   ifelse(country == &quot;Kenya&quot;, &quot;KEN&quot;,
			ifelse(country == &quot;Madagascar&quot;, &quot;MDG&quot;,
			  ifelse(country == &quot;Mozambique&quot;, &quot;MOZ&quot;, &quot;ZMB&quot;)))))
#
# Clean-up
#
rm(choice, choice.value)

</command>
			<property title="Setup" shape="RANDOM"/>
			<option type="com.ef_prime.rflow.node.base.SubflowNodeModel">
				<subflow>
					<graph version="0.8" width="1444" height="513" locationtype="a" offsetx="81" offsety="2">
						<node id="2" date="1510899093927" uid="1e759f0af29d6461" x="420" y="40">
							<command>################################################################################
#
# Get country selection
#
################################################################################
#
# Extract country choice
#
country &lt;- as.character(tclvalue(choice.value))
#
# Determine country code
#
ccode &lt;- ifelse(country == &quot;Bangladesh&quot;, &quot;BGD&quot;,
	      ifelse(country == &quot;Ghana&quot;, &quot;GHA&quot;,
		   ifelse(country == &quot;Kenya&quot;, &quot;KEN&quot;,
			ifelse(country == &quot;Madagascar&quot;, &quot;MDG&quot;,
			  ifelse(country == &quot;Mozambique&quot;, &quot;MOZ&quot;, &quot;ZMB&quot;)))))
#
# Clean-up
#
rm(choice, choice.value)

</command>
							<property title="Get country name" shape="INOUT"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="3" date="1510899093928" uid="b16edfacad12fb84" x="500" y="40">
							<command></command>
							<property/>
							<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
								<entry key="io">out</entry>
							</option>
						</node>
						<node id="4" date="1510899093928" uid="9a597e319f384a77" x="120" y="110">
							<command>################################################################################
#
# Load libraries
#
################################################################################

library(maptools)          # library for reading map data
library(maps)              # library for other map functions e.g., scale bar
library(rgeos)             # library for geospatial data manipulation and analysis
library(rgdal)             # library for geospatial data manipulation and analysis
library(gstat)             # library for geospatial modelling and interpolation
library(ggmap)             # library for plotting maps using ggplot
library(ggplot2)           # library for creating plots using ggplot
library(raster)            # library for working with raster data
library(FNN)               # library for finding nearest neighbour algorithm
library(grid)              # library for map-based grids
library(scales)            # library for scaling values
library(stringr)           # library for character manipulation/handling
library(classInt)          # library for creating class intervals for vector values
library(tcltk2)            # library for TCL/TK properties
library(Hmisc)             # library for miscellaneous R functions on top of base

</command>
							<property title="Load libraries"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="5" date="1510899093927" uid="7e89dc75040efca5" x="120" y="40">
							<command>################################################################################
#
# Configure R
#
################################################################################
#
# Clear workspace
#
rm(list = ls())
#
# Garbage collection
#
gc()
#
# Set options
#
options(stringsAsFactors = FALSE)
#
# Set seed for pseudo-random number generator
#
set.seed(1977)

</command>
							<property title="Configure R"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="6" date="1510899093928" uid="3bc742a37c51ecf9" x="320" y="110">
							<command>
################################################################################
#
#
#
# PPI LOOK-UP TABLES
#
#
#
################################################################################

################################################################################
#
# Bangladesh PPI look-up table
#
################################################################################
#
#
#
score   &lt;- c(0:100)
nl      &lt;- c(0.762, 0.762, 0.762, 0.762, 0.762, 0.706, 0.706, 0.706, 0.706, 0.706, 
             0.636, 0.636, 0.636, 0.636, 0.636, 0.464, 0.464, 0.464, 0.464, 0.464, 
             0.371, 0.371, 0.371, 0.371, 0.371, 0.266, 0.266, 0.266, 0.266, 0.266, 
             0.191, 0.191, 0.191, 0.191, 0.191, 0.150, 0.150, 0.150, 0.150, 0.150, 
             0.127, 0.127, 0.127, 0.127, 0.127, 0.066, 0.066, 0.066, 0.066, 0.066, 
             0.039, 0.039, 0.039, 0.039, 0.039, 0.015, 0.015, 0.015, 0.015, 0.015, 
             0.009, 0.009, 0.009, 0.009, 0.009, 0.004, 0.004, 0.004, 0.004, 0.004, 
             0.002, 0.002, 0.002, 0.002, 0.002, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
nu100   &lt;- c(0.873, 0.873, 0.873, 0.873, 0.873, 0.846, 0.846, 0.846, 0.846, 0.846, 
             0.821, 0.821, 0.821, 0.821, 0.821, 0.680, 0.680, 0.680, 0.680, 0.680, 
             0.627, 0.627, 0.627, 0.627, 0.627, 0.504, 0.504, 0.504, 0.504, 0.504, 
             0.409, 0.409, 0.409, 0.409, 0.409, 0.360, 0.360, 0.360, 0.360, 0.360, 
             0.267, 0.267, 0.267, 0.267, 0.267, 0.196, 0.196, 0.196, 0.196, 0.196, 
             0.147, 0.147, 0.147, 0.147, 0.147, 0.071, 0.071, 0.071, 0.071, 0.071, 
             0.053, 0.053, 0.053, 0.053, 0.053, 0.044, 0.044, 0.044, 0.044, 0.044, 
             0.023, 0.023, 0.023, 0.023, 0.023, 0.012, 0.012, 0.012, 0.012, 0.012, 
             0.005, 0.005, 0.005, 0.005, 0.005, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
nu150   &lt;- c(0.984, 0.984, 0.984, 0.984, 0.984, 0.977, 0.977, 0.977, 0.977, 0.977, 
             0.976, 0.976, 0.976, 0.976, 0.976, 0.962, 0.962, 0.962, 0.962, 0.962, 
             0.961, 0.961, 0.961, 0.961, 0.961, 0.887, 0.887, 0.887, 0.887, 0.887, 
             0.843, 0.843, 0.843, 0.843, 0.843, 0.808, 0.808, 0.808, 0.808, 0.808, 
             0.761, 0.761, 0.761, 0.761, 0.761, 0.658, 0.658, 0.658, 0.658, 0.658, 
             0.550, 0.550, 0.550, 0.550, 0.550, 0.426, 0.426, 0.426, 0.426, 0.426, 
             0.348, 0.348, 0.348, 0.348, 0.348, 0.286, 0.286, 0.286, 0.286, 0.286, 
             0.246, 0.246, 0.246, 0.246, 0.246, 0.214, 0.214, 0.214, 0.214, 0.214, 
             0.170, 0.170, 0.170, 0.170, 0.170, 0.083, 0.083, 0.083, 0.083, 0.083, 
             0.039, 0.039, 0.039, 0.039, 0.039, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
nu200   &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 0.995, 0.995, 0.995, 0.995, 0.995, 
             0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 
             0.995, 0.995, 0.995, 0.995, 0.995, 0.979, 0.979, 0.979, 0.979, 0.979, 
             0.960, 0.960, 0.960, 0.960, 0.960, 0.936, 0.936, 0.936, 0.936, 0.936, 
             0.919, 0.919, 0.919, 0.919, 0.919, 0.866, 0.866, 0.866, 0.866, 0.866, 
             0.813, 0.813, 0.813, 0.813, 0.813, 0.756, 0.756, 0.756, 0.756, 0.756, 
             0.649, 0.649, 0.649, 0.649, 0.649, 0.525, 0.525, 0.525, 0.525, 0.525, 
             0.510, 0.510, 0.510, 0.510, 0.510, 0.403, 0.403, 0.403, 0.403, 0.403, 
             0.320, 0.320, 0.320, 0.320, 0.320, 0.249, 0.249, 0.249, 0.249, 0.249, 
             0.099, 0.099, 0.099, 0.099, 0.099, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
extreme &lt;- c(0.658, 0.658, 0.658, 0.658, 0.658, 0.656, 0.656, 0.656, 0.656, 0.656, 
             0.572, 0.572, 0.572, 0.572, 0.572, 0.425, 0.425, 0.425, 0.425, 0.425, 
             0.327, 0.327, 0.327, 0.327, 0.327, 0.229, 0.229, 0.229, 0.229, 0.229, 
             0.169, 0.169, 0.169, 0.169, 0.169, 0.138, 0.138, 0.138, 0.138, 0.138, 
             0.111, 0.111, 0.111, 0.111, 0.111, 0.054, 0.054, 0.054, 0.054, 0.054, 
             0.045, 0.045, 0.045, 0.045, 0.045, 0.018, 0.018, 0.018, 0.018, 0.018, 
             0.010, 0.010, 0.010, 0.010, 0.010, 0.001, 0.001, 0.001, 0.001, 0.001, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
ppp125  &lt;- c(0.979, 0.979, 0.979, 0.979, 0.979, 0.893, 0.893, 0.893, 0.893, 0.893, 
             0.888, 0.888, 0.888, 0.888, 0.888, 0.816, 0.816, 0.816, 0.816, 0.816, 
             0.780, 0.780, 0.780, 0.780, 0.780, 0.658, 0.658, 0.658, 0.658, 0.658, 
             0.570, 0.570, 0.570, 0.570, 0.570, 0.503, 0.503, 0.503, 0.503, 0.503, 
             0.408, 0.408, 0.408, 0.408, 0.408, 0.335, 0.335, 0.335, 0.335, 0.335, 
             0.242, 0.242, 0.242, 0.242, 0.242, 0.145, 0.145, 0.145, 0.145, 0.145, 
             0.109, 0.109, 0.109, 0.109, 0.109, 0.087, 0.087, 0.087, 0.087, 0.087, 
             0.056, 0.056, 0.056, 0.056, 0.056, 0.043, 0.043, 0.043, 0.043, 0.043, 
             0.027, 0.027, 0.027, 0.027, 0.027, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
ppp175  &lt;- c(0.988, 0.988, 0.988, 0.988, 0.988, 0.982, 0.982, 0.982, 0.982, 0.982, 
             0.982, 0.982, 0.982, 0.982, 0.982, 0.969, 0.969, 0.969, 0.969, 0.969, 
             0.963, 0.963, 0.963, 0.963, 0.963, 0.916, 0.916, 0.916, 0.916, 0.916, 
             0.879, 0.879, 0.879, 0.879, 0.879, 0.836, 0.836, 0.836, 0.836, 0.836, 
             0.796, 0.796, 0.796, 0.796, 0.796, 0.688, 0.688, 0.688, 0.688, 0.688, 
             0.603, 0.603, 0.603, 0.603, 0.603, 0.504, 0.504, 0.504, 0.504, 0.504, 
             0.404, 0.404, 0.404, 0.404, 0.404, 0.322, 0.322, 0.322, 0.322, 0.322, 
             0.315, 0.315, 0.315, 0.315, 0.315, 0.258, 0.258, 0.258, 0.258, 0.258, 
             0.197, 0.197, 0.197, 0.197, 0.197, 0.107, 0.107, 0.107, 0.107, 0.107, 
             0.051, 0.051, 0.051, 0.051, 0.051, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
ppp200  &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 0.987, 0.987, 0.987, 0.987, 0.987, 
             0.987, 0.987, 0.987, 0.987, 0.987, 0.986, 0.986, 0.986, 0.986, 0.986, 
             0.984, 0.984, 0.984, 0.984, 0.984, 0.953, 0.953, 0.953, 0.953, 0.953, 
             0.935, 0.935, 0.935, 0.935, 0.935, 0.907, 0.907, 0.907, 0.907, 0.907, 
             0.874, 0.874, 0.874, 0.874, 0.874, 0.796, 0.796, 0.796, 0.796, 0.796, 
             0.742, 0.742, 0.742, 0.742, 0.742, 0.652, 0.652, 0.652, 0.652, 0.652, 
             0.546, 0.546, 0.546, 0.546, 0.546, 0.445, 0.445, 0.445, 0.445, 0.445, 
             0.429, 0.429, 0.429, 0.429, 0.429, 0.340, 0.340, 0.340, 0.340, 0.340, 
             0.267, 0.267, 0.267, 0.267, 0.267, 0.146, 0.146, 0.146, 0.146, 0.146, 
             0.066, 0.066, 0.066, 0.066, 0.066, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
ppp250  &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 0.997, 0.997, 0.997, 0.997, 0.997, 
             0.997, 0.997, 0.997, 0.997, 0.997, 0.997, 0.997, 0.997, 0.997, 0.997, 
             0.997, 0.997, 0.997, 0.997, 0.997, 0.987, 0.987, 0.987, 0.987, 0.987, 
             0.982, 0.982, 0.982, 0.982, 0.982, 0.969, 0.969, 0.969, 0.969, 0.969, 
             0.949, 0.949, 0.949, 0.949, 0.949, 0.915, 0.915, 0.915, 0.915, 0.915, 
             0.879, 0.879, 0.879, 0.879, 0.879, 0.843, 0.843, 0.843, 0.843, 0.843, 
             0.732, 0.732, 0.732, 0.732, 0.732, 0.633, 0.633, 0.633, 0.633, 0.633, 
             0.604, 0.604, 0.604, 0.604, 0.604, 0.507, 0.507, 0.507, 0.507, 0.507, 
             0.409, 0.409, 0.409, 0.409, 0.409, 0.333, 0.333, 0.333, 0.333, 0.333, 
             0.123, 0.123, 0.123, 0.123, 0.123, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
#
#
#
ppiMatrixBGD &lt;- data.frame(score, nl, nu100, nu150, nu200, extreme, 
                           ppp125, ppp175, ppp200, ppp250)
#
# Clean-up
#
rm(nu100, nu150, nu200, extreme, ppp125, ppp175, ppp200, ppp250)



################################################################################
#
# Ghana PPI look-up table
#
################################################################################
#
#
#
nlFood  &lt;- c(0.704, 0.704, 0.704, 0.704, 0.704, 0.704, 0.704, 0.704, 0.704, 0.704, 
             0.507, 0.507, 0.507, 0.507, 0.507, 0.384, 0.384, 0.384, 0.384, 0.384, 
             0.310, 0.310, 0.310, 0.310, 0.310, 0.215, 0.215, 0.215, 0.215, 0.215, 
             0.151, 0.151, 0.151, 0.151, 0.151, 0.081, 0.081, 0.081, 0.081, 0.081, 
             0.054, 0.054, 0.054, 0.054, 0.054, 0.022, 0.022, 0.022, 0.022, 0.022, 
             0.013, 0.013, 0.013, 0.013, 0.013, 0.012, 0.012, 0.012, 0.012, 0.012, 
             0.004, 0.004, 0.004, 0.004, 0.004, 0.001, 0.001, 0.001, 0.001, 0.001, 
             0.001, 0.001, 0.001, 0.001, 0.001, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
nl100   &lt;- c(0.890, 0.890, 0.890, 0.890, 0.890, 0.890, 0.890, 0.890, 0.890, 0.890, 
             0.744, 0.744, 0.744, 0.744, 0.744, 0.623, 0.623, 0.623, 0.623, 0.623, 
             0.587, 0.587, 0.587, 0.587, 0.587, 0.480, 0.480, 0.480, 0.480, 0.480, 
             0.339, 0.339, 0.339, 0.339, 0.339, 0.242, 0.242, 0.242, 0.242, 0.242, 
             0.166, 0.166, 0.166, 0.166, 0.166, 0.101, 0.101, 0.101, 0.101, 0.101, 
             0.050, 0.050, 0.050, 0.050, 0.050, 0.036, 0.036, 0.036, 0.036, 0.036, 
             0.017, 0.017, 0.017, 0.017, 0.017, 0.007, 0.007, 0.007, 0.007, 0.007, 
             0.007, 0.007, 0.007, 0.007, 0.007, 0.002, 0.002, 0.002, 0.002, 0.002, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
nl150   &lt;- c(0.979, 0.979, 0.979, 0.979, 0.979, 0.979, 0.979, 0.979, 0.979, 0.979, 
             0.882, 0.882, 0.882, 0.882, 0.882, 0.855, 0.855, 0.855, 0.855, 0.855, 
             0.849, 0.849, 0.849, 0.849, 0.849, 0.758, 0.758, 0.758, 0.758, 0.758, 
             0.655, 0.655, 0.655, 0.655, 0.655, 0.537, 0.537, 0.537, 0.537, 0.537, 
             0.392, 0.392, 0.392, 0.392, 0.392, 0.309, 0.309, 0.309, 0.309, 0.309, 
             0.211, 0.211, 0.211, 0.211, 0.211, 0.145, 0.145, 0.145, 0.145, 0.145, 
             0.085, 0.085, 0.085, 0.085, 0.085, 0.049, 0.049, 0.049, 0.049, 0.049, 
             0.037, 0.037, 0.037, 0.037, 0.037, 0.009, 0.009, 0.009, 0.009, 0.009, 
             0.002, 0.002, 0.002, 0.002, 0.002, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
nl200   &lt;- c(0.991, 0.991, 0.991, 0.991, 0.991, 0.991, 0.991, 0.991, 0.991, 0.991, 
             0.963, 0.963, 0.963, 0.963, 0.963, 0.942, 0.942, 0.942, 0.942, 0.942, 
             0.918, 0.918, 0.918, 0.918, 0.918, 0.891, 0.891, 0.891, 0.891, 0.891, 
             0.819, 0.819, 0.819, 0.819, 0.819, 0.739, 0.739, 0.739, 0.739, 0.739, 
             0.652, 0.652, 0.652, 0.652, 0.652, 0.534, 0.534, 0.534, 0.534, 0.534, 
             0.408, 0.408, 0.408, 0.408, 0.408, 0.304, 0.304, 0.304, 0.304, 0.304, 
             0.227, 0.227, 0.227, 0.227, 0.227, 0.154, 0.154, 0.154, 0.154, 0.154, 
             0.097, 0.097, 0.097, 0.097, 0.097, 0.046, 0.046, 0.046, 0.046, 0.046, 
             0.011, 0.011, 0.011, 0.011, 0.011, 0.004, 0.004, 0.004, 0.004, 0.004, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
ppp125  &lt;- c(0.839, 0.839, 0.839, 0.839, 0.839, 0.839, 0.839, 0.839, 0.839, 0.839, 
             0.596, 0.596, 0.596, 0.596, 0.596, 0.473, 0.473, 0.473, 0.473, 0.473, 
             0.394, 0.394, 0.394, 0.394, 0.394, 0.311, 0.311, 0.311, 0.311, 0.311, 
             0.203, 0.203, 0.203, 0.203, 0.203, 0.106, 0.106, 0.106, 0.106, 0.106, 
             0.078, 0.078, 0.078, 0.078, 0.078, 0.035, 0.035, 0.035, 0.035, 0.035, 
             0.015, 0.015, 0.015, 0.015, 0.015, 0.015, 0.015, 0.015, 0.015, 0.015, 
             0.007, 0.007, 0.007, 0.007, 0.007, 0.001, 0.001, 0.001, 0.001, 0.001, 
             0.001, 0.001, 0.001, 0.001, 0.001, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
ppp250  &lt;- c(0.979, 0.979, 0.979, 0.979, 0.979, 0.979, 0.979, 0.979, 0.979, 0.979, 
             0.935, 0.935, 0.935, 0.935, 0.935, 0.882, 0.882, 0.882, 0.882, 0.882, 
             0.861, 0.861, 0.861, 0.861, 0.861, 0.794, 0.794, 0.794, 0.794, 0.794, 
             0.694, 0.694, 0.694, 0.694, 0.694, 0.549, 0.549, 0.549, 0.549, 0.549, 
             0.420, 0.420, 0.420, 0.420, 0.420, 0.313, 0.313, 0.313, 0.313, 0.313, 
             0.225, 0.225, 0.225, 0.225, 0.225, 0.155, 0.155, 0.155, 0.155, 0.155, 
             0.090, 0.090, 0.090, 0.090, 0.090, 0.056, 0.056, 0.056, 0.056, 0.056, 
             0.037, 0.037, 0.037, 0.037, 0.037, 0.008, 0.008, 0.008, 0.008, 0.008, 
             0.005, 0.005, 0.005, 0.005, 0.005, 0.002, 0.002, 0.002, 0.002, 0.002, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
ppp375  &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
             0.979, 0.979, 0.979, 0.979, 0.979, 0.964, 0.964, 0.964, 0.964, 0.964, 
             0.963, 0.963, 0.963, 0.963, 0.963, 0.944, 0.944, 0.944, 0.944, 0.944, 
             0.875, 0.875, 0.875, 0.875, 0.875, 0.796, 0.796, 0.796, 0.796, 0.796, 
             0.745, 0.745, 0.745, 0.745, 0.745, 0.643, 0.643, 0.643, 0.643, 0.643, 
             0.494, 0.494, 0.494, 0.494, 0.494, 0.417, 0.417, 0.417, 0.417, 0.417, 
             0.313, 0.313, 0.313, 0.313, 0.313, 0.224, 0.224, 0.224, 0.224, 0.224, 
             0.155, 0.155, 0.155, 0.155, 0.155, 0.077, 0.077, 0.077, 0.077, 0.077, 
             0.022, 0.022, 0.022, 0.022, 0.022, 0.007, 0.007, 0.007, 0.007, 0.007, 
             0.002, 0.002, 0.002, 0.002, 0.002, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
#
#
#
ppiMatrixGHA &lt;- data.frame(score, nlFood, nl100, nl150, nl200, ppp125, ppp250, ppp375)
#
# Clean-up
#
rm(nlFood, nl100, nl150, nl200, ppp125, ppp250, ppp375)

             
################################################################################
#
# Kenya PPI look-up table
#
################################################################################
#
#
#                          
nlFood  &lt;- c(0.954, 0.954, 0.954, 0.954, 0.954, 0.726, 0.726, 0.726, 0.726, 0.726, 
             0.571, 0.571, 0.571, 0.571, 0.571, 0.474, 0.474, 0.474, 0.474, 0.474, 
             0.378, 0.378, 0.378, 0.378, 0.378, 0.328, 0.328, 0.328, 0.328, 0.328, 
             0.235, 0.235, 0.235, 0.235, 0.235, 0.127, 0.127, 0.127, 0.127, 0.127, 
             0.099, 0.099, 0.099, 0.099, 0.099, 0.047, 0.047, 0.047, 0.047, 0.047, 
             0.019, 0.019, 0.019, 0.019, 0.019, 0.009, 0.009, 0.009, 0.009, 0.009, 
             0.005, 0.005, 0.005, 0.005, 0.005, 0.009, 0.009, 0.009, 0.009, 0.009, 
             0.002, 0.002, 0.002, 0.002, 0.002, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.004, 0.004, 0.004, 0.004, 0.004, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
nl150   &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
             0.965, 0.965, 0.965, 0.965, 0.965, 0.957, 0.957, 0.957, 0.957, 0.957, 
             0.932, 0.932, 0.932, 0.932, 0.932, 0.891, 0.891, 0.891, 0.891, 0.891, 
             0.833, 0.833, 0.833, 0.833, 0.833, 0.757, 0.757, 0.757, 0.757, 0.757, 
             0.648, 0.648, 0.648, 0.648, 0.648, 0.643, 0.643, 0.643, 0.643, 0.643, 
             0.494, 0.494, 0.494, 0.494, 0.494, 0.418, 0.418, 0.418, 0.418, 0.418, 
             0.323, 0.323, 0.323, 0.323, 0.323, 0.204, 0.204, 0.204, 0.204, 0.204, 
             0.111, 0.111, 0.111, 0.111, 0.111, 0.041, 0.041, 0.041, 0.041, 0.041, 
             0.067, 0.067, 0.067, 0.067, 0.067, 0.041, 0.041, 0.041, 0.041, 0.041, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
extreme &lt;- c(0.915, 0.915, 0.915, 0.915, 0.915, 0.739, 0.739, 0.739, 0.739, 0.739, 
             0.579, 0.579, 0.579, 0.579, 0.579, 0.469, 0.469, 0.469, 0.469, 0.469, 
             0.463, 0.463, 0.463, 0.463, 0.463, 0.365, 0.365, 0.365, 0.365, 0.365, 
             0.276, 0.276, 0.276, 0.276, 0.276, 0.168, 0.168, 0.168, 0.168, 0.168, 
             0.154, 0.154, 0.154, 0.154, 0.154, 0.074, 0.074, 0.074, 0.074, 0.074, 
             0.025, 0.025, 0.025, 0.025, 0.025, 0.023, 0.023, 0.023, 0.023, 0.023, 
             0.003, 0.003, 0.003, 0.003, 0.003, 0.012, 0.012, 0.012, 0.012, 0.012, 
             0.002, 0.002, 0.002, 0.002, 0.002, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.004, 0.004, 0.004, 0.004, 0.004, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000,
             0.000)
ppp125  &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 0.972, 0.972, 0.972, 0.972, 0.972, 
             0.837, 0.837, 0.837, 0.837, 0.837, 0.876, 0.876, 0.876, 0.876, 0.876, 
             0.811, 0.811, 0.811, 0.811, 0.811, 0.707, 0.707, 0.707, 0.707, 0.707, 
             0.631, 0.631, 0.631, 0.631, 0.631, 0.484, 0.484, 0.484, 0.484, 0.484, 
             0.351, 0.351, 0.351, 0.351, 0.351, 0.254, 0.254, 0.254, 0.254, 0.254, 
             0.087, 0.087, 0.087, 0.087, 0.087, 0.078, 0.078, 0.078, 0.078, 0.078, 
             0.010, 0.010, 0.010, 0.010, 0.010, 0.011, 0.011, 0.011, 0.011, 0.011, 
             0.002, 0.002, 0.002, 0.002, 0.002, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.004, 0.004, 0.004, 0.004, 0.004, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
ppp250  &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
             0.993, 0.993, 0.993, 0.993, 0.993, 0.991, 0.991, 0.991, 0.991, 0.991, 
             0.962, 0.962, 0.962, 0.962, 0.962, 0.954, 0.954, 0.954, 0.954, 0.954, 
             0.910, 0.910, 0.910, 0.910, 0.910, 0.827, 0.827, 0.827, 0.827, 0.827, 
             0.755, 0.755, 0.755, 0.755, 0.755, 0.755, 0.755, 0.755, 0.755, 0.755, 
             0.611, 0.611, 0.611, 0.611, 0.611, 0.440, 0.440, 0.440, 0.440, 0.440, 
             0.290, 0.290, 0.290, 0.290, 0.290, 0.200, 0.200, 0.200, 0.200, 0.200, 
             0.094, 0.094, 0.094, 0.094, 0.094, 0.060, 0.060, 0.060, 0.060, 0.060, 
             0.022, 0.022, 0.022, 0.022, 0.022, 0.041, 0.041, 0.041, 0.041, 0.041, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
#
#
#
ppiMatrixKEN &lt;- data.frame(score, nlFood, nl150, extreme, ppp125, ppp250)
#
#
#
rm(nlFood, nl150, extreme, ppp125, ppp250)


################################################################################
#
# Madagascar PPI look-up table
#
################################################################################
#
#
#
nlFood  &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
             0.958, 0.958, 0.958, 0.958, 0.958, 0.882, 0.882, 0.882, 0.882, 0.882, 
             0.822, 0.822, 0.822, 0.822, 0.822, 0.770, 0.770, 0.770, 0.770, 0.770, 
             0.637, 0.637, 0.637, 0.637, 0.637, 0.524, 0.524, 0.524, 0.524, 0.524, 
             0.360, 0.360, 0.360, 0.360, 0.360, 0.230, 0.230, 0.230, 0.230, 0.230, 
             0.107, 0.107, 0.107, 0.107, 0.107, 0.044, 0.044, 0.044, 0.044, 0.044, 
             0.029, 0.029, 0.029, 0.029, 0.029, 0.015, 0.015, 0.015, 0.015, 0.015, 
             0.007, 0.007, 0.007, 0.007, 0.007, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
nl100   &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
             0.990, 0.990, 0.990, 0.990, 0.990, 0.983, 0.983, 0.983, 0.983, 0.983, 
             0.972, 0.972, 0.972, 0.972, 0.972, 0.946, 0.946, 0.946, 0.946, 0.946, 
             0.891, 0.891, 0.891, 0.891, 0.891, 0.833, 0.833, 0.833, 0.833, 0.833, 
             0.689, 0.689, 0.689, 0.689, 0.689, 0.519, 0.519, 0.519, 0.519, 0.519, 
             0.385, 0.385, 0.385, 0.385, 0.385, 0.185, 0.185, 0.185, 0.185, 0.185, 
             0.118, 0.118, 0.118, 0.118, 0.118, 0.086, 0.086, 0.086, 0.086, 0.086, 
             0.023, 0.023, 0.023, 0.023, 0.023, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
nl150   &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
             1.000, 1.000, 1.000, 1.000, 1.000, 0.998, 0.998, 0.998, 0.998, 0.998, 
             0.996, 0.996, 0.996, 0.996, 0.996, 0.988, 0.988, 0.988, 0.988, 0.988, 
             0.980, 0.980, 0.980, 0.980, 0.980, 0.971, 0.971, 0.971, 0.971, 0.971, 
             0.912, 0.912, 0.912, 0.912, 0.912, 0.846, 0.846, 0.846, 0.846, 0.846, 
             0.739, 0.739, 0.739, 0.739, 0.739, 0.530, 0.530, 0.530, 0.530, 0.530, 
             0.371, 0.371, 0.371, 0.371, 0.371, 0.289, 0.289, 0.289, 0.289, 0.289, 
             0.151, 0.151, 0.151, 0.151, 0.151, 0.066, 0.066, 0.066, 0.066, 0.066, 
             0.016, 0.016, 0.016, 0.016, 0.016, 0.008, 0.008, 0.008, 0.008, 0.008, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
nl200   &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
             1.000, 1.000, 1.000, 1.000, 1.000, 0.999, 0.999, 0.999, 0.999, 0.999, 
             0.999, 0.999, 0.999, 0.999, 0.999, 0.996, 0.996, 0.996, 0.996, 0.996, 
             0.991, 0.991, 0.991, 0.991, 0.991, 0.991, 0.991, 0.991, 0.991, 0.991, 
             0.969, 0.969, 0.969, 0.969, 0.969, 0.943, 0.943, 0.943, 0.943, 0.943, 
             0.892, 0.892, 0.892, 0.892, 0.892, 0.767, 0.767, 0.767, 0.767, 0.767, 
             0.609, 0.609, 0.609, 0.609, 0.609, 0.542, 0.542, 0.542, 0.542, 0.542, 
             0.348, 0.348, 0.348, 0.348, 0.348, 0.190, 0.190, 0.190, 0.190, 0.190, 
             0.061, 0.061, 0.061, 0.061, 0.061, 0.023, 0.023, 0.023, 0.023, 0.023, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
median100 &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
               0.829, 0.829, 0.829, 0.829, 0.829, 0.701, 0.701, 0.701, 0.701, 0.701, 
               0.563, 0.563, 0.563, 0.563, 0.563, 0.488, 0.488, 0.488, 0.488, 0.488, 
               0.369, 0.369, 0.369, 0.369, 0.369, 0.299, 0.299, 0.299, 0.299, 0.299, 
               0.191, 0.191, 0.191, 0.191, 0.191, 0.133, 0.133, 0.133, 0.133, 0.133, 
               0.047, 0.047, 0.047, 0.047, 0.047, 0.022, 0.022, 0.022, 0.022, 0.022, 
               0.013, 0.013, 0.013, 0.013, 0.013, 0.008, 0.008, 0.008, 0.008, 0.008, 
               0.005, 0.005, 0.005, 0.005, 0.005, 0.000, 0.000, 0.000, 0.000, 0.000, 
               0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
               0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
               0.000)
ppp125   &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
              1.000, 1.000, 1.000, 1.000, 1.000, 0.998, 0.998, 0.998, 0.998, 0.998, 
              0.995, 0.995, 0.995, 0.995, 0.995, 0.984, 0.984, 0.984, 0.984, 0.984, 
              0.970, 0.970, 0.970, 0.970, 0.970, 0.954, 0.954, 0.954, 0.954, 0.954, 
              0.887, 0.887, 0.887, 0.887, 0.887, 0.813, 0.813, 0.813, 0.813, 0.813, 
              0.689, 0.689, 0.689, 0.689, 0.689, 0.457, 0.457, 0.457, 0.457, 0.457, 
              0.307, 0.307, 0.307, 0.307, 0.307, 0.252, 0.252, 0.252, 0.252, 0.252, 
              0.119, 0.119, 0.119, 0.119, 0.119, 0.063, 0.063, 0.063, 0.063, 0.063, 
              0.014, 0.014, 0.014, 0.014, 0.014, 0.007, 0.007, 0.007, 0.007, 0.007, 
              0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
              0.000)
ppp200   &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
              1.000, 1.000, 1.000, 1.000, 1.000, 0.999, 0.999, 0.999, 0.999, 0.999, 
              0.999, 0.999, 0.999, 0.999, 0.999, 0.996, 0.996, 0.996, 0.996, 0.996, 
              0.994, 0.994, 0.994, 0.994, 0.994, 0.993, 0.993, 0.993, 0.993, 0.993, 
              0.977, 0.977, 0.977, 0.977, 0.977, 0.960, 0.960, 0.960, 0.960, 0.960, 
              0.924, 0.924, 0.924, 0.924, 0.924, 0.817, 0.817, 0.817, 0.817, 0.817, 
              0.721, 0.721, 0.721, 0.721, 0.721, 0.653, 0.653, 0.653, 0.653, 0.653, 
              0.418, 0.418, 0.418, 0.418, 0.418, 0.235, 0.235, 0.235, 0.235, 0.235, 
              0.129, 0.129, 0.129, 0.129, 0.129, 0.053, 0.053, 0.053, 0.053, 0.053, 
              0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
              0.000)  
ppp250   &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
              1.000, 1.000, 1.000, 1.000, 1.000, 0.999, 0.999, 0.999, 0.999, 0.999, 
              0.999, 0.999, 0.999, 0.999, 0.999, 0.998, 0.998, 0.998, 0.998, 0.998, 
              0.997, 0.997, 0.997, 0.997, 0.997, 0.997, 0.997, 0.997, 0.997, 0.997, 
              0.991, 0.991, 0.991, 0.991, 0.991, 0.978, 0.978, 0.978, 0.978, 0.978, 
              0.962, 0.962, 0.962, 0.962, 0.962, 0.918, 0.918, 0.918, 0.918, 0.918, 
              0.864, 0.864, 0.864, 0.864, 0.864, 0.800, 0.800, 0.800, 0.800, 0.800, 
              0.597, 0.597, 0.597, 0.597, 0.597, 0.341, 0.341, 0.341, 0.341, 0.341, 
              0.265, 0.265, 0.265, 0.265, 0.265, 0.104, 0.104, 0.104, 0.104, 0.104, 
              0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
              0.000)
ppp500   &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
              1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
              1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
              1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
              0.998, 0.998, 0.998, 0.998, 0.998, 0.994, 0.994, 0.994, 0.994, 0.994, 
              0.992, 0.992, 0.992, 0.992, 0.992, 0.987, 0.987, 0.987, 0.987, 0.987, 
              0.983, 0.983, 0.983, 0.983, 0.983, 0.970, 0.970, 0.970, 0.970, 0.970, 
              0.946, 0.946, 0.946, 0.946, 0.946, 0.851, 0.851, 0.851, 0.851, 0.851, 
              0.706, 0.706, 0.706, 0.706, 0.706, 0.537, 0.537, 0.537, 0.537, 0.537, 
              0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
              0.000)
#
#
#
ppiMatrixMDG &lt;- data.frame(score, nlFood, nl100, nl150, nl200, 
                           median100, ppp125, ppp200, ppp250, ppp500)
#
#
#
rm(nlFood, nl100, nl150, nl200, median100, ppp125, ppp200, ppp250, ppp500)                           
                   
################################################################################
#
# Mozambique PPI look-up table
#
################################################################################
#
#
#
nl100   &lt;- c(0.971, 0.971, 0.971, 0.971, 0.971, 0.930, 0.930, 0.930, 0.930, 0.930, 
             0.899, 0.899, 0.899, 0.899, 0.899, 0.794, 0.794, 0.794, 0.794, 0.794, 
             0.761, 0.761, 0.761, 0.761, 0.761, 0.720, 0.720, 0.720, 0.720, 0.720, 
             0.608, 0.608, 0.608, 0.608, 0.608, 0.508, 0.508, 0.508, 0.508, 0.508, 
             0.317, 0.317, 0.317, 0.317, 0.317, 0.288, 0.288, 0.288, 0.288, 0.288, 
             0.214, 0.214, 0.214, 0.214, 0.214, 0.085, 0.085, 0.085, 0.085, 0.085, 
             0.072, 0.072, 0.072, 0.072, 0.072, 0.032, 0.032, 0.032, 0.032, 0.032, 
             0.006, 0.006, 0.006, 0.006, 0.006, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
nl150   &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 0.986, 0.986, 0.986, 0.986, 0.986, 
             0.975, 0.975, 0.975, 0.975, 0.975, 0.934, 0.934, 0.934, 0.934, 0.934, 
             0.918, 0.918, 0.918, 0.918, 0.918, 0.911, 0.911, 0.911, 0.911, 0.911, 
             0.882, 0.882, 0.882, 0.882, 0.882, 0.784, 0.784, 0.784, 0.784, 0.784, 
             0.671, 0.671, 0.671, 0.671, 0.671, 0.521, 0.521, 0.521, 0.521, 0.521, 
             0.451, 0.451, 0.451, 0.451, 0.451, 0.306, 0.306, 0.306, 0.306, 0.306, 
             0.249, 0.249, 0.249, 0.249, 0.249, 0.156, 0.156, 0.156, 0.156, 0.156, 
             0.048, 0.048, 0.048, 0.048, 0.048, 0.013, 0.013, 0.013, 0.013, 0.013, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
nl200   &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
             0.996, 0.996, 0.996, 0.996, 0.996, 0.977, 0.977, 0.977, 0.977, 0.977, 
             0.973, 0.973, 0.973, 0.973, 0.973, 0.973, 0.973, 0.973, 0.973, 0.973, 
             0.969, 0.969, 0.969, 0.969, 0.969, 0.892, 0.892, 0.892, 0.892, 0.892, 
             0.843, 0.843, 0.843, 0.843, 0.843, 0.738, 0.738, 0.738, 0.738, 0.738, 
             0.678, 0.678, 0.678, 0.678, 0.678, 0.507, 0.507, 0.507, 0.507, 0.507, 
             0.435, 0.435, 0.435, 0.435, 0.435, 0.271, 0.271, 0.271, 0.271, 0.271, 
             0.156, 0.156, 0.156, 0.156, 0.156, 0.099, 0.099, 0.099, 0.099, 0.099, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
extreme &lt;- c(0.777, 0.777, 0.777, 0.777, 0.777, 0.656, 0.656, 0.656, 0.656, 0.656, 
             0.629, 0.629, 0.629, 0.629, 0.629, 0.523, 0.523, 0.523, 0.523, 0.523, 
             0.429, 0.429, 0.429, 0.429, 0.429, 0.350, 0.350, 0.350, 0.350, 0.350, 
             0.270, 0.270, 0.270, 0.270, 0.270, 0.199, 0.199, 0.199, 0.199, 0.199, 
             0.129, 0.129, 0.129, 0.129, 0.129, 0.097, 0.097, 0.097, 0.097, 0.097, 
             0.057, 0.057, 0.057, 0.057, 0.057, 0.032, 0.032, 0.032, 0.032, 0.032, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
ppp125  &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 0.969, 0.969, 0.969, 0.969, 0.969, 
             0.926, 0.926, 0.926, 0.926, 0.926, 0.841, 0.841, 0.841, 0.841, 0.841, 
             0.816, 0.816, 0.816, 0.816, 0.816, 0.783, 0.783, 0.783, 0.783, 0.783, 
             0.685, 0.685, 0.685, 0.685, 0.685, 0.593, 0.593, 0.593, 0.593, 0.593, 
             0.415, 0.415, 0.415, 0.415, 0.415, 0.330, 0.330, 0.330, 0.330, 0.330, 
             0.263, 0.263, 0.263, 0.263, 0.263, 0.119, 0.119, 0.119, 0.119, 0.119, 
             0.101, 0.101, 0.101, 0.101, 0.101, 0.050, 0.050, 0.050, 0.050, 0.050, 
             0.014, 0.014, 0.014, 0.014, 0.014, 0.000, 0.000, 0.000, 0.000, 0.000,
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
ppp250  &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
             1.000, 1.000, 1.000, 1.000, 1.000, 0.985, 0.985, 0.985, 0.985, 0.985, 
             0.981, 0.981, 0.981, 0.981, 0.981, 0.981, 0.981, 0.981, 0.981, 0.981, 
             0.978, 0.978, 0.978, 0.978, 0.978, 0.918, 0.918, 0.918, 0.918, 0.918, 
             0.880, 0.880, 0.880, 0.880, 0.880, 0.782, 0.782, 0.782, 0.782, 0.782, 
             0.734, 0.734, 0.734, 0.734, 0.734, 0.586, 0.586, 0.586, 0.586, 0.586, 
             0.516, 0.516, 0.516, 0.516, 0.516, 0.317, 0.317, 0.317, 0.317, 0.317, 
             0.210, 0.210, 0.210, 0.210, 0.210, 0.135, 0.135, 0.135, 0.135, 0.135, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
#
#
#
ppiMatrixMOZ &lt;- data.frame(score, nl100, nl150, nl200, extreme, ppp125, ppp250)
#
#
#
rm(nl100, nl150, nl200, extreme, ppp125, ppp250)                                                       


################################################################################
#
# Zambia PPI look-up table
#
################################################################################
#
#
#
nlFood  &lt;- c(0.916, 0.916, 0.916, 0.916, 0.916, 0.828, 0.828, 0.828, 0.828, 0.828, 
             0.756, 0.756, 0.756, 0.756, 0.756, 0.697, 0.697, 0.697, 0.697, 0.697, 
             0.583, 0.583, 0.583, 0.583, 0.583, 0.526, 0.526, 0.526, 0.526, 0.526, 
             0.388, 0.388, 0.388, 0.388, 0.388, 0.253, 0.253, 0.253, 0.253, 0.253, 
             0.188, 0.188, 0.188, 0.188, 0.188, 0.076, 0.076, 0.076, 0.076, 0.076, 
             0.028, 0.028, 0.028, 0.028, 0.028, 0.004, 0.004, 0.004, 0.004, 0.004, 
             0.003, 0.003, 0.003, 0.003, 0.003, 0.002, 0.002, 0.002, 0.002, 0.002, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.00, 
             0.000)
nu100   &lt;- c(0.983, 0.983, 0.983, 0.983, 0.983, 0.968, 0.968, 0.968, 0.968, 0.968, 
             0.943, 0.943, 0.943, 0.943, 0.943, 0.922, 0.922, 0.922, 0.922, 0.922, 
             0.881, 0.881, 0.881, 0.881, 0.881, 0.817, 0.817, 0.817, 0.817, 0.817, 
             0.710, 0.710, 0.710, 0.710, 0.710, 0.600, 0.600, 0.600, 0.600, 0.600, 
             0.487, 0.487, 0.487, 0.487, 0.487, 0.328, 0.328, 0.328, 0.328, 0.328, 
             0.193, 0.193, 0.193, 0.193, 0.193, 0.106, 0.106, 0.106, 0.106, 0.106, 
             0.053, 0.053, 0.053, 0.053, 0.053, 0.034, 0.034, 0.034, 0.034, 0.034, 
             0.014, 0.014, 0.014, 0.014, 0.014, 0.003, 0.003, 0.003, 0.003, 0.003, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
nu150   &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 0.999, 0.999, 0.999, 0.999, 0.999, 
             0.983, 0.983, 0.983, 0.983, 0.983, 0.979, 0.979, 0.979, 0.979, 0.979, 
             0.970, 0.970, 0.970, 0.970, 0.970, 0.956, 0.956, 0.956, 0.956, 0.956, 
             0.911, 0.911, 0.911, 0.911, 0.911, 0.874, 0.874, 0.874, 0.874, 0.874, 
             0.786, 0.786, 0.786, 0.786, 0.786, 0.631, 0.631, 0.631, 0.631, 0.631, 
             0.433, 0.433, 0.433, 0.433, 0.433, 0.351, 0.351, 0.351, 0.351, 0.351, 
             0.250, 0.250, 0.250, 0.250, 0.250, 0.191, 0.191, 0.191, 0.191, 0.191, 
             0.088, 0.088, 0.088, 0.088, 0.088, 0.063, 0.063, 0.063, 0.063, 0.063, 
             0.017, 0.017, 0.017, 0.017, 0.017, 0.002, 0.002, 0.002, 0.002, 0.002, 
             0.001, 0.001, 0.001, 0.001, 0.001, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)                                          
nu200   &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 0.999, 0.999, 0.999, 0.999, 0.999, 
             0.994, 0.994, 0.994, 0.994, 0.994, 0.994, 0.994, 0.994, 0.994, 0.994, 
             0.994, 0.994, 0.994, 0.994, 0.994, 0.989, 0.989, 0.989, 0.989, 0.989, 
             0.974, 0.974, 0.974, 0.974, 0.974, 0.957, 0.957, 0.957, 0.957, 0.957, 
             0.890, 0.890, 0.890, 0.890, 0.890, 0.821, 0.821, 0.821, 0.821, 0.821, 
             0.675, 0.675, 0.675, 0.675, 0.675, 0.551, 0.551, 0.551, 0.551, 0.551, 
             0.514, 0.514, 0.514, 0.514, 0.514, 0.376, 0.376, 0.376, 0.376, 0.376, 
             0.227, 0.227, 0.227, 0.227, 0.227, 0.168, 0.168, 0.168, 0.168, 0.168, 
             0.074, 0.074, 0.074, 0.074, 0.074, 0.027, 0.027, 0.027, 0.027, 0.027, 
             0.003, 0.003, 0.003, 0.003, 0.003, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
extreme &lt;- c(0.867, 0.867, 0.867, 0.867, 0.867, 0.682, 0.682, 0.682, 0.682, 0.682, 
             0.622, 0.622, 0.622, 0.622, 0.622, 0.520, 0.520, 0.520, 0.520, 0.520, 
             0.418, 0.418, 0.418, 0.418, 0.418, 0.362, 0.362, 0.362, 0.362, 0.362, 
             0.244, 0.244, 0.244, 0.244, 0.244, 0.143, 0.143, 0.143, 0.143, 0.143, 
             0.101, 0.101, 0.101, 0.101, 0.101, 0.045, 0.045, 0.045, 0.045, 0.045, 
             0.015, 0.015, 0.015, 0.015, 0.015, 0.006, 0.006, 0.006, 0.006, 0.006, 
             0.004, 0.004, 0.004, 0.004, 0.004, 0.004, 0.004, 0.004, 0.004, 0.004, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
ppp125  &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 0.999, 0.999, 0.999, 0.999, 0.999, 
             0.979, 0.979, 0.979, 0.979, 0.979, 0.970, 0.970, 0.970, 0.970, 0.970, 
             0.965, 0.965, 0.965, 0.965, 0.965, 0.948, 0.948, 0.948, 0.948, 0.948, 
             0.874, 0.874, 0.874, 0.874, 0.874, 0.801, 0.801, 0.801, 0.801, 0.801, 
             0.699, 0.699, 0.699, 0.699, 0.699, 0.543, 0.543, 0.543, 0.543, 0.543, 
             0.351, 0.351, 0.351, 0.351, 0.351, 0.234, 0.234, 0.234, 0.234, 0.234, 
             0.162, 0.162, 0.162, 0.162, 0.162, 0.118, 0.118, 0.118, 0.118, 0.118, 
             0.054, 0.054, 0.054, 0.054, 0.054, 0.034, 0.034, 0.034, 0.034, 0.034, 
             0.006, 0.006, 0.006, 0.006, 0.006, 0.001, 0.001, 0.001, 0.001, 0.001, 
             0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
ppp200  &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
             0.999, 0.999, 0.999, 0.999, 0.999, 0.996, 0.996, 0.996, 0.996, 0.996, 
             0.995, 0.995, 0.995, 0.995, 0.995, 0.990, 0.990, 0.990, 0.990, 0.990, 
             0.979, 0.979, 0.979, 0.979, 0.979, 0.964, 0.964, 0.964, 0.964, 0.964, 
             0.892, 0.892, 0.892, 0.892, 0.892, 0.833, 0.833, 0.833, 0.833, 0.833, 
             0.686, 0.686, 0.686, 0.686, 0.686, 0.565, 0.565, 0.565, 0.565, 0.565, 
             0.513, 0.513, 0.513, 0.513, 0.513, 0.394, 0.394, 0.394, 0.394, 0.394, 
             0.285, 0.285, 0.285, 0.285, 0.285, 0.213, 0.213, 0.213, 0.213, 0.213, 
             0.095, 0.095, 0.095, 0.095, 0.095, 0.033, 0.033, 0.033, 0.033, 0.033, 
             0.026, 0.026, 0.026, 0.026, 0.026, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
ppp250  &lt;- c(1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 
             1.000, 1.000, 1.000, 1.000, 1.000, 0.998, 0.998, 0.998, 0.998, 0.998, 
             0.998, 0.998, 0.998, 0.998, 0.998, 0.996, 0.996, 0.996, 0.996, 0.996, 
             0.988, 0.988, 0.988, 0.988, 0.988, 0.980, 0.980, 0.980, 0.980, 0.980, 
             0.957, 0.957, 0.957, 0.957, 0.957, 0.913, 0.913, 0.913, 0.913, 0.913, 
             0.811, 0.811, 0.811, 0.811, 0.811, 0.711, 0.711, 0.711, 0.711, 0.711, 
             0.670, 0.670, 0.670, 0.670, 0.670, 0.544, 0.544, 0.544, 0.544, 0.544, 
             0.419, 0.419, 0.419, 0.419, 0.419, 0.341, 0.341, 0.341, 0.341, 0.341, 
             0.170, 0.170, 0.170, 0.170, 0.170, 0.130, 0.130, 0.130, 0.130, 0.130, 
             0.053, 0.053, 0.053, 0.053, 0.053, 0.000, 0.000, 0.000, 0.000, 0.000, 
             0.000)
#
#
#
ppiMatrixZMB &lt;- data.frame(score, nlFood, nu100, nu150, nu200, extreme, ppp125,
                           ppp200, ppp250)
#
#
#
rm(score, nlFood, nu100, nu150, nu200, extreme, ppp125, ppp200, ppp250)

                                                                                                                                                                                                                                                                </command>
							<property title="PPI Tables" shape="INPUT"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="7" date="1510899093929" uid="e95d030e5b60f69a" x="320" y="40">
							<command>
################################################################################
#                                                                              #
#                ASSEMBLE COLOUR VECTORS FOR CHARTS AND MAPS                   #
#                                                                              #
################################################################################

################################################################################
#
# Create WSUP-specific and WASH-specific colour schemes
#
################################################################################
#
# WSUP blue colour fill
#
wsupFill   &lt;- &quot;#c6dbef&quot;
#
# WSUP blue colour border
#
wsupColour &lt;- &quot;#3182bd&quot;
#
# WASH ladder indicators colour schemes
#
waterLadder &lt;- c(&quot;#4575b4&quot;, &quot;#74add1&quot;, &quot;#ffffbf&quot;, &quot;#feb24c&quot;, &quot;#ec7014&quot;)
sanitationLadder &lt;- c(&quot;#1a9850&quot;, &quot;#a6d96a&quot;, &quot;#ffffbf&quot;, &quot;#feb24c&quot;, &quot;#ec7014&quot;)
handwashLadder &lt;- c(&quot;#cab2d6&quot;, &quot;#ffffbf&quot;, &quot;#ec7014&quot;)
#
# Colour for water collector plots
#
collectColour &lt;- c(&quot;#fbb4ae&quot;, &quot;#b3cde3&quot;, &quot;#ccebc5&quot;, &quot;#decbe4&quot;, &quot;#fed9a6&quot;)
#
# Colour for formal/informal plots
#
formalColour &lt;- c(&quot;#a6cee3&quot;, &quot;#1f78b4&quot;)
#
# Overall indicators colour schemes
#
overallColour &lt;- c(&quot;#fdbf6f&quot;, &quot;#b2df8a&quot;, &quot;#a6cee3&quot;, &quot;#e78ac3&quot;)
#
# Seven colour water palette scheme
#
water7 &lt;- c(&quot;#eff3ff&quot;, &quot;#c6dbef&quot;, &quot;#9ecae1&quot;, &quot;#6baed6&quot;, 
	       &quot;#4292c6&quot;, &quot;#2171b5&quot;, &quot;#084594&quot;)

</command>
							<property title="Assemble colours"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="8" date="1510899093928" uid="e964b0eda2844464" x="220" y="40">
							<command>
################################################################################
#
# Create directories within current directory for organising outputs
#
################################################################################
#
# Create first level directories for outputs
#
dir.create(&quot;outputLists&quot;, showWarnings = FALSE)
dir.create(&quot;outputTables&quot;, showWarnings = FALSE)
dir.create(&quot;data&quot;, showWarnings = FALSE)

</command>
							<property title="Directories"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="9" date="1510899093929" uid="7d0c555f558f73d4" x="40" y="40">
							<command></command>
							<property/>
							<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
								<entry key="io">in</entry>
							</option>
						</node>
						<node id="10" date="1510899093929" uid="cac07b914c747469" x="420" y="110">
							<command>
################################################################################
#
# Function to produce response based on selection
#
################################################################################
#
# 
#
onOK &lt;- function()
  {
  #
  # Extract name of country selected
  #
  cValue &lt;- as.character(tclvalue(choice.value))
  #
  # Close dialog box for country choices
  #
  tkdestroy(choice)
  #
  # Remind user of country chosen
  #
  tkmessageBox(title = &quot;Selected country&quot;,
	          message = paste(&quot;You have selected &quot;, cValue, &quot;.&quot;, sep = &quot;&quot;),
		     icon = &quot;info&quot;,
		     type = &quot;ok&quot;)
  #
  # Return result for cValue
  #
  return(cValue)
  }


################################################################################
#
# Select which country the data being analysed is from
#
################################################################################
#
# Vector of country choices
#
countries &lt;- c(&quot;Bangladesh&quot;, &quot;Ghana&quot;, &quot;Kenya&quot;, &quot;Madagascar&quot;, &quot;Mozambique&quot;, &quot;Zambia&quot;)
#
# Open dialog box
#
choice &lt;- tktoplevel()
#
# Label teh dialog box
#
tkwm.title(choice, &quot;Select country&quot;)
#
# Cycle through countries
#
for(i in 1:length(countries))
  {
  #
  # Add buttons in dialog box for each country choice
  # 	
  assign(x = paste(&quot;choice$env$choice&quot;, i, sep = &quot;&quot;),
	    value = tk2radiobutton(choice))
  }
#
# Select which radio button is selected by default
#
choice.value &lt;- tclVar(countries[1])
#
# Cycle through countries
#
for(i in 1:length(countries))
  {
  #
  # Configure radio buttons
  #
  tkconfigure(widget = get(paste(&quot;choice$env$choice&quot;, i, sep = &quot;&quot;)),
		    variable = choice.value,
		    value = countries[i])
  }
#
# Add a question prompt for country selection
#
tkgrid(tk2label(parent = choice, text = &quot;Which country data are you analysing?&quot;),
	           columnspan = 2, padx = 10, pady = c(15, 5))
#
# Cycle through countries
#
for(i in 1:length(countries))
  {
  #
  # Position choices on dialog box
  #    
  tkgrid(tk2label(parent = choice, text = countries[i]),
	             get(paste(&quot;choice$env$choice&quot;, i, sep = &quot;&quot;)),
	             padx = 10, pady = c(0, i + 5))
  }
#
# Create &apos;OK&apos; button
#  
choice$env$butOK &lt;- tk2button(choice, text = &quot;OK&quot;, width = -6, command = onOK)
#
# Define size parameters for dialog box
#
tkgrid(choice$env$butOK, columnspan = 2, padx = 10, pady = c(5, 15))
#
# Focus to the choice dialog box
#
tkfocus(choice)
#
#
#
tkwait.window(choice)
#
# Clean-up
#
rm(i)

</command>
							<property title="Choose country" shape="INOUT"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="11" date="1510899093928" uid="a71f47f7d55a63ac" x="220" y="110">
							<command>################################################################################
#
# Function to add alpha parameter to colours
#
################################################################################

addAlpha &lt;- function(col, alpha)
  {
  apply(X = sapply(col, col2rgb)/255, 
	   MARGIN = 2,
	   FUN = function(x) { rgb(x[1], x[2], x[3], alpha = alpha) })
  }


############################################################
#
# Function to scale values for mapping
#
############################################################

scaleValue &lt;- function(x, n, style = &quot;quantile&quot;, digits = 0)
  {
  y &lt;- cut(x, 
		 breaks = unique(classIntervals(x, 
		                                n = n, 
		                                style = style,
		                                dataPrecision = digits)$brks),
	      labels = FALSE, 
	      include.lowest = TRUE)
  return(y)
  }


################################################################################
#
# bootBW function (blocked weighted bootstrap function)
#
################################################################################
#
#  Returns :
#
#    A data.frame with :
#
#      ncol  = length(outputColumns)
#      nrow  = replicates
#      names = outputColumns
#
################################################################################
#
#  Example :
#
#    Example function (estimate a proportion for a binary (0/1) variable) :
#
#      oneP &lt;- function(x, params)
#        {
#        v1 &lt;- params[1]
#        v1Data &lt;- x[[v1]]
#        oneP &lt;- mean(v1Data, na.rm = TRUE)
#        return(oneP)
#        }
#
#  Example call to bootBW function:
#
#    bootP &lt;- bootBW(x = data,
#                    w = pops,
#                    statistic = oneP,
#                    params = &quot;nameOfVariable&quot;,
#                    outputColumns = &quot;p&quot;,
#                    replicates = 1999)
#
#  Example estimate with 95% CI :
#
#    quantile(bootP, probs = c(0.500, 0.025, 0.975), na.rm = TRUE)
#
################################################################################
#
#  Version : 21/03/2014
#
################################################################################

bootBW &lt;- function(x, w, statistic, params, outputColumns, replicates = 400)
  {
  #
  # Scale weights and accumulate weights
  #
  w$weight &lt;- w$pop / sum(w$pop)
  w$cumWeight &lt;- cumsum(w$weight)
  #
  # Create data.frame with named columns for output
  #
  boot &lt;- data.frame(matrix(ncol = length(outputColumns), nrow = replicates))
  names(boot) &lt;- outputColumns
  #
  # Create an empty data.frame with same structure of &apos;x&apos; with sufficient rows
  # to hold the largest possible survey replicates (i.e. number of clusters
  # multiplied by the size of the largest cluster)
  #
  nClusters &lt;- nrow(w)
  maxRows &lt;- nClusters * max(table(x$psu))
  emptyDF &lt;- rbind(as.data.frame(lapply(x, function(x) rep.int(NA, maxRows))))
  #
  # Vector to hold clusters to be included in a survey replicate
  #
  sampledClusters &lt;- vector(mode = mode(x$psu), length = nClusters)
  #
  # And now ... resample!
  #
  for(i in 1:replicates)
    {
    #
    # Create a dataframe to hold a survey replicate
    #
    xBW &lt;- emptyDF
    #
    # Blocking Bootstrap from &apos;x&apos; (blocking on x$psu = cluster identifier)
    #
    for(j in 1:nClusters)
      {
      #
      # &quot;Roulette Wheel&quot; algorithm (to select a weighted sample of clusters)
      #
	 sampledClusters[j] &lt;- w$psu[which.max(w$cumWeight &gt;= runif(n = 1, min = 0, max = 1))]
	 }
    #
    # Pointer for inserting selected clusters into the survey replicate
    #
    rowIndex &lt;- 1
    #
    # Build a (blocking weighted) bootstrap replicate from the selected clusters
    #
    for(k in 1:nClusters)
      {
      #
      # Extract data for cluster and resample within the cluster
      #
	 y &lt;- subset(x, psu == sampledClusters[k])
	 clusterN &lt;- nrow(y)
	 y &lt;- y[sample(1:clusterN, replace = TRUE), ]
	 #
	 # Insert cluster replicate into survey replicate
	 #
	 endRow &lt;- rowIndex + clusterN
	 xBW[rowIndex:(endRow - 1), ] &lt;- y
	 #
	 # Update pointer
	 #
	 rowIndex &lt;- endRow
	 }
    #
    # Select data for analysis
    #
    xBW &lt;- xBW[1:(rowIndex - 1), ]
    #
    # Apply statistic
    #
    boot[i, ] &lt;- statistic(xBW, params)
    }
  return(boot)
  }


################################################################################
#
# Statistic function for use with bootBW
#
#   This function returns a mean of the first item in &apos;params&apos;. If a binary
#   variable is coded 1 / 0 then this is a proportion.
#
################################################################################

oneMean &lt;- function(x, params)
  {
  v1 &lt;- params[1]
  v1Data &lt;- x[[v1]]
  oneMean &lt;- mean(v1Data, na.rm = TRUE)
  return(oneMean)
  }


################################################################################
#
#  Pyramid plot 
#
################################################################################
#
#  Parameters :
#
#    x     A vector (numeric, factor, character) holding age-groups
#
#    g     A binary categorical variable (usually sex)
#
#    main  Plot title
# 
#    xlab  x-axis label
#
#    ylab  y-axis label
#
################################################################################
#
#  Returns :
#
#    Axis tick positions (of limited use)
#
################################################################################

pyramid.plot &lt;- function(x, 
	                    g,
	                    main = paste(&quot;Pyramid plot of&quot;, deparse(substitute(x)), &quot;by&quot;, deparse(substitute(g))),
	                    xlab = paste(deparse(substitute(g)), &quot;(&quot;, levels(g)[1], &quot;/&quot;, levels(g)[2],&quot;)&quot;),
	                    ylab = deparse(substitute(x)))
  {
  tab &lt;- table(x, g); tab[ ,1] &lt;- -tab[ ,1]
  barplot(tab,
  horiz = TRUE,
  beside = TRUE,
  space = c(0, -nrow(tab)),
  names.arg = c(dimnames(tab)$x, dimnames(tab)$x),
  xlim = c(min(tab) * 1.2, max(tab) * 1.2),
  col = &quot;white&quot;,
  main = main,
  xlab = xlab,
  ylab = ylab,
  axes = FALSE)
  axis(side = 1, labels = abs(axTicks(side = 1)), at = (axTicks(side = 1)))
  }


################################################################################
#
#  Pareto plot 
#
################################################################################
#
#  Parameters :
#
#    x     A vector (numeric, factor, character)
#
#    main  Plot title
# 
#    xlab  x-axis label
#
#    ylab  y-axis label
#
################################################################################
#
#  Returns :
#
#    Bar positions
#
################################################################################

pareto.plot &lt;- function(x, 
	                   main = paste(&quot;Pareto Chart of&quot;, deparse(substitute(x))),
	                   xlab = deparse(substitute(x)),
	                   ylab = &quot;Count&quot;)
  {
  barplot(rev(sort(table(x))), xlab = xlab, ylab = ylab, main = main, col = &quot;white&quot;)
  }



 </command>
							<property title="Functions"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<edge from="2" to="3"/>
						<edge from="10" to="2"/>
						<edge from="5" to="4"/>
						<edge from="4" to="11"/>
						<edge from="11" to="8"/>
						<edge from="6" to="10"/>
						<edge from="9" to="5"/>
						<edge from="7" to="6"/>
						<edge from="8" to="7"/>
					</graph>
				</subflow>
			</option>
		</node>
		<node id="12" date="1510899095248" uid="8c224fd8318343ae" x="-190" y="720">
			<command>
################################################################################
#
# Specify LQAS classification parameters
#
################################################################################
#
# Set default upper and lower classification standards
#
upper.value &lt;- tclVar(&quot;0.8&quot;)
lower.value &lt;- tclVar(&quot;0.5&quot;)
#
# Create dialog box
#
choice &lt;- tktoplevel()
#
# Add title to dialog box
#
tkwm.title(choice, &quot;LQAS standards&quot;)
#
# Create input boxes
#
upper.entry &lt;- tkentry(choice, textvariable = upper.value)
lower.entry &lt;- tkentry(choice, textvariable = lower.value)
#
# RESET function for RESET button
#
reset &lt;- function()
  {
  #
  # Specify default parameters
  #
  tclvalue(upper.value) &lt;- &quot;0.8&quot;
  tclvalue(lower.value) &lt;- &quot;0.5&quot;
  }
#
# Create reset button
#
reset.button &lt;- tkbutton(choice, text = &quot;Reset&quot;, command = reset)
#
# SUBMIT function for SUBMIT button
#
submit &lt;- function() 
  {
  #
  # Extract values for upper and lower values
  #
  x &lt;- as.numeric(tclvalue(upper.value))
  y &lt;- as.numeric(tclvalue(lower.value))
  #
  # Prompt user with the upper and lower standards chosen and ask whether to continue
  #
  proceed &lt;- tkmessageBox(title = &quot;LQAS standards&quot;,
                          message = paste(&quot;Upper standard: &quot;, x * 100, &quot;%; Lower standard: &quot;, y * 100, &quot;%. Do you wish to use these standards?&quot;, sep = &quot;&quot;),
                          icon = &quot;question&quot;,
                          type = &quot;yesno&quot;)
  #
  # Determine if user responded not to continue with specified standards
  #
  if(tclvalue(proceed) == &quot;no&quot;)
    {
    #
    # Prompt user that no standards have been specified
    #
    tkmessageBox(title = &quot;LQAS standards&quot;,
                 message = &quot;No standards specified. Specify upper and lower standards&quot;,
                 icon = &quot;warning&quot;,
                 type = &quot;ok&quot;)
    }
  #
  # Determine if user accepted the specified standards
  #
  if(tclvalue(proceed) == &quot;yes&quot;)
    {
    #
    # Close dialog box
    #
    tkdestroy(choice)
    }
  }
#
# Create submit button
#
submit.button &lt;- tkbutton(choice, text = &quot;Submit&quot;, command = submit)
#
# Layout the options and buttons on dialog box
# 
tkgrid(tklabel(choice, text = &quot;Specify upper and lower standards&quot;), columnspan = 2, pady = 5)
tkgrid(tklabel(choice, text = &quot;Upper Standard:&quot;), upper.entry, pady = 5, padx = 5)
tkgrid(tklabel(choice, text = &quot;Lower Standard:&quot;), lower.entry, pady = 5, padx = 5)
tkgrid(submit.button, reset.button, pady = 5, padx = 5)

tkwait.window(choice)


 


################################################################################
#
# Perform LQAS on proportion indicators
#
################################################################################
#
# Extract standards provided by user
#
lowerClass &lt;- as.numeric(tclvalue(lower.value))
upperClass &lt;- as.numeric(tclvalue(upper.value))


################################################################################
#
# Results by indicator single output
#
################################################################################
#
# Create empty aggregator object for LQAS results
#
resultAll &lt;- NULL
#
# Cycle through indicators
#
for(i in steerIndicators$varList)
  {
  #
  # Create empty matrix to aggregate interim output
  #
  resultDF &lt;- matrix(ncol = 13, nrow = max(unique(indicatorsDF$zone)))
  #
  # Check type of function required for current indicator is a proportion
  #
  if(steerIndicators$varFunction[steerIndicators$varList == i] == &quot;proportion&quot;)
    {
    #
    # Cycle through survey zones
    #
    for(j in unique(indicatorsDF$zone))
      {
	 #
	 # Cycle through area types i.e. slum and other
	 #
	 for(k in unique(indicatorsDF$type))
	   {
	   #
	   # Subset indicator data to current zone and current area type
	   #
	   temp &lt;- indicatorsDF[indicatorsDF$zone == j &amp; indicatorsDF$type == k, i]
	   #
	   # Count total sample size for current area type
	   #
	   total &lt;- length(!is.na(temp))
	   #
	   # Calculate lower target
	   #
	   class1 &lt;- floor(total * lowerClass)
	   #
	   # Calculate upper target
	   #
	   class2 &lt;- floor(total * upperClass)
	   #
        # Count total number of cases i.e. those for which indicator is TRUE
	   #
	   cases &lt;- sum(temp, na.rm = TRUE)
	   #
	   #
	   #
	   if(is.na(sum(temp)) == TRUE)
	     {
	     cases &lt;- NA
	     }
	   #
	   # Classify
	   #
	   class &lt;- ifelse(is.na(cases), NA,
	              ifelse(cases &lt;= class1, &quot;Low&quot;,
	                ifelse(cases &gt; class2, &quot;High&quot;, &quot;Moderate&quot;)))
	   #      
	   # Determine if area is slum or other
	   #     
	   typeCol &lt;- rep(k, 3)
	   #
	   # Add interim results to empty matrix
	   #
	   resultDF[j, ifelse(typeCol == 1, 8:10, 11:13)] &lt;- c(total, cases, class)
	   }
	}
  }
  #
  # If current indicator does not require proportion function
  #  
  else
    {
    #
    # Cylce through zones
    #
    for(j in unique(indicatorsDF$zone))
      {
      #
      # Cycle through area types i.e. slum or other
      #
	 for(k in unique(indicatorsDF$type))
	   {
        #
        # Subset indicator data to current zone and current area type
        #
	   temp &lt;- indicatorsDF[indicatorsDF$zone == j &amp; indicatorsDF$type == k, i]
	   #
	   # Count total sample size for current area type
	   #
	   total &lt;- length(!is.na(temp))
	   #
        # Set cases to 0 as indicator is not a proportion
	   #
	   cases &lt;- 0
	   #
	   # No classification as current indicator is not a proportion
	   #
	   class &lt;- NA
	   #      
	   # Determine if area is slum or other
	   #     
	   typeCol &lt;- rep(k, 3)
	   #
	   # Add interim results to empty matrix
        #
	   resultDF[j, ifelse(typeCol == 1, 8:10, 11:13)] &lt;- c(total, cases, class)
	   }
      }  
    }
  #
  # Add identifying data to interim results matrix
  #  
  resultDF[,1] &lt;- unique(country)
  resultDF[,2] &lt;- unique(ccode)
  resultDF[,3] &lt;- unique(month)
  resultDF[,4] &lt;- unique(year)
  resultDF[,5] &lt;- steerIndicators$varNames[steerIndicators$varList == i]
  resultDF[,6] &lt;- i
  resultDF[,7] &lt;- paste(&quot;Survey Area&quot;, unique(indicatorsDF$zone), sep = &quot; &quot;)
  #
  # Convert interim results matrix to data.frame
  #
  resultDF &lt;- data.frame(resultDF)
  #
  # Name variables in interim results data.frame
  #
  names(resultDF) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;, &quot;Month&quot;, &quot;Year&quot;,
  	                  &quot;Indicator Name&quot;, &quot;Indicator Code&quot;, &quot;Survey Area&quot;, 
		             &quot;Low Income Area Total Respondents&quot;, &quot;Low Income Area Cases&quot;, &quot;Low Income Area Classification&quot;, 
		             &quot;Other Total Respondents&quot;, &quot;Other Cases&quot;, &quot;Other Classification&quot;)
  #
  # Concatenate interim results data.frame with resulst aggregator
  #
  resultAll &lt;- rbind(resultAll, resultDF)
  }
#
# Save results aggregator as CSV
#
write.csv(x = resultAll,
	     file = paste(&quot;outputTables/surveyResultsClass&quot;, 
	                  unique(ccode), unique(month), unique(year),
	                  &quot;.csv&quot;, sep = &quot;&quot;), 
	     row.names = FALSE)



################################################################################
#
# Perform LQAS on proportion indicators
#
################################################################################
#
# Extract standards provided by user
#
lowerClass &lt;- as.numeric(tclvalue(lower.value))
upperClass &lt;- as.numeric(tclvalue(upper.value))


################################################################################
#
# Results by indicator single output
#
################################################################################
#
# Create empty aggregator object for LQAS results
#
resultAll &lt;- NULL
#
# Cycle through indicators
#
for(i in steerIndicators$varList)
  {
  #
  # Create empty matrix to aggregate interim output
  #
  resultDF &lt;- matrix(ncol = 13, nrow = max(unique(indicatorsDF$pQuintile)))
  #
  # Check type of function required for current indicator is a proportion
  #
  if(steerIndicators$varFunction[steerIndicators$varList == i] == &quot;proportion&quot;)
    {
    #
    # Cycle through survey zones
    #
    for(j in unique(indicatorsDF$pQuintile))
      {
	 #
	 # Cycle through area types i.e. slum and other
	 #
	 for(k in unique(indicatorsDF$type))
	   {
	   #
	   # Subset indicator data to current zone and current area type
	   #
	   temp &lt;- indicatorsDF[indicatorsDF$pQuintile == j &amp; indicatorsDF$type == k, i]
	   #
	   # Count total sample size for current area type
	   #
	   total &lt;- length(!is.na(temp))
	   #
	   # Calculate lower target
	   #
	   class1 &lt;- floor(total * lowerClass)
	   #
	   # Calculate upper target
	   #
	   class2 &lt;- floor(total * upperClass)
	   #
        # Count total number of cases i.e. those for which indicator is TRUE
	   #
	   cases &lt;- sum(temp, na.rm = TRUE)
	   #
	   #
	   #
	   if(is.na(sum(temp)) == TRUE)
	     {
	     cases &lt;- NA
	     }
	   #
	   # Classify
	   #
	   class &lt;- ifelse(is.na(cases), NA,
		         ifelse(cases &lt;= class1, &quot;Low&quot;,
			      ifelse(cases &gt; class2, &quot;High&quot;, &quot;Moderate&quot;)))
	   #      
	   # Determine if area is slum or other
	   #     
	   typeCol &lt;- rep(k, 3)
	   #
	   # Add interim results to empty matrix
	   #
	   resultDF[j, ifelse(typeCol == 1, 8:10, 11:13)] &lt;- c(total, cases, class)
	   }
	}
  }
  #
  # If current indicator does not require proportion function
  #  
  else
    {
    #
    # Cylce through zones
    #
    for(j in unique(indicatorsDF$pQuintile))
      {
      #
      # Cycle through area types i.e. slum or other
      #
	 for(k in unique(indicatorsDF$type))
	   {
        #
        # Subset indicator data to current zone and current area type
        #
	   temp &lt;- indicatorsDF[indicatorsDF$pQuintile == j &amp; indicatorsDF$type == k, i]
	   #
	   # Count total sample size for current area type
	   #
	   total &lt;- length(!is.na(temp))
	   #
        # Set cases to 0 as indicator is not a proportion
	   #
	   cases &lt;- 0
	   #
	   # No classification as current indicator is not a proportion
	   #
	   class &lt;- NA
	   #      
	   # Determine if area is slum or other
	   #     
	   typeCol &lt;- rep(k, 3)
	   #
	   # Add interim results to empty matrix
        #
	   resultDF[j, ifelse(typeCol == 1, 8:10, 11:13)] &lt;- c(total, cases, class)
	   }
      }  
    }
  #
  # Add identifying data to interim results matrix
  #  
  resultDF[,1] &lt;- unique(country)
  resultDF[,2] &lt;- unique(ccode)
  resultDF[,3] &lt;- unique(month)
  resultDF[,4] &lt;- unique(year)
  resultDF[,5] &lt;- steerIndicators$varNames[steerIndicators$varList == i]
  resultDF[,6] &lt;- i
  resultDF[,7] &lt;- paste(&quot;Wealth Quintile&quot;, 1:j, sep = &quot; &quot;)
  #
  # Convert interim results matrix to data.frame
  #
  resultDF &lt;- data.frame(resultDF)
  #
  # Name variables in interim results data.frame
  #
  names(resultDF) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;, &quot;Month&quot;, &quot;Year&quot;,
  	                  &quot;Indicator Name&quot;, &quot;Indicator Code&quot;, &quot;Wealth Quintile&quot;, 
		             &quot;Low Income Area Total Respondents&quot;, &quot;Low Income Area Cases&quot;, &quot;Low Income Area Classification&quot;, 
		             &quot;Other Total Respondents&quot;, &quot;Other Cases&quot;, &quot;Other Classification&quot;)
  #
  # Concatenate interim results data.frame with resulst aggregator
  #
  resultAll &lt;- rbind(resultAll, resultDF)
  }

# Save results aggregator as CSV
#
write.csv(x = resultAll,
	     file = paste(&quot;outputTables/surveyResultsClassWealth&quot;, 
	                  unique(ccode), unique(month), unique(year),
	                  &quot;.csv&quot;, sep = &quot;&quot;), 
	     row.names = FALSE)



################################################################################
#
# Perform LQAS on proportion indicators
#
################################################################################
#
# Extract standards provided by user
#
lowerClass &lt;- as.numeric(tclvalue(lower.value))
upperClass &lt;- as.numeric(tclvalue(upper.value))


################################################################################
#
# Results by indicator single output
#
################################################################################
#
# Create empty matrix to aggregate interim output
#
resultDF &lt;- matrix(ncol = 13, nrow = length(steerIndicators$varList))
#
#
#
resultDF[,1] &lt;- unique(country)
resultDF[,2] &lt;- unique(ccode)
resultDF[,3] &lt;- unique(month)
resultDF[,4] &lt;- unique(year)
resultDF[,5] &lt;- steerIndicators$varNames
resultDF[,6] &lt;- steerIndicators$varList
resultDF[,7] &lt;- &quot;Overall&quot;
#
#
#
for(i in 1:length(steerIndicators$varList))
  {
  #
  # Cycle through area types i.e. slum and other
  #
  for(j in unique(indicatorsDF$type))
    {
    #
    # Check type of function required for current indicator is a proportion
    #
    if(steerIndicators$varFunction[i] == &quot;proportion&quot;)
      {
      #
      # Subset indicator data current area type
      #
      temp &lt;- indicatorsDF[indicatorsDF$type == j, steerIndicators$varList[i]]
      #
      # Count total sample size for current area type
      #
      total &lt;- length(!is.na(temp))
      #
      # Calculate lower target
      #
	 class1 &lt;- floor(total * lowerClass)
	 #
	 # Calculate upper target
	 #
	 class2 &lt;- floor(total * upperClass)
	 #
	 # Count total number of cases i.e. those for which indicator is TRUE
	 #
	 cases &lt;- sum(temp, na.rm = TRUE)
 	 #
	 #
	 #
	 if(is.na(sum(temp)) == TRUE)
	   {
	   cases &lt;- NA
	   }
	 #
	 # Classify
	 #
	 class &lt;- ifelse(is.na(cases), NA,
		       ifelse(cases &lt;= class1, &quot;Low&quot;,
			    ifelse(cases &gt; class2, &quot;High&quot;, &quot;Moderate&quot;)))
	 #      
	 # Determine if area is slum or other
	 #     
	 typeCol &lt;- rep(j, 3)
	 #
	 # Add interim results to empty matrix
	 #
	 resultDF[i, ifelse(typeCol == 1, 8:10, 11:13)] &lt;- c(total, cases, class)
      }
    else
	 {
	 #
	 # Subset indicator data to current zone and current area type
	 #
	 temp &lt;- indicatorsDF[indicatorsDF$type == j, steerIndicators$varList[i]]
	 #
	 # Count total sample size for current area type
	 #
	 total &lt;- length(!is.na(temp))
	 #
	 # Set cases to 0 as indicator is not a proportion
	 #
	 cases &lt;- 0
	 #
	 # No classification as current indicator is not a proportion
	 #
	 class &lt;- NA
	 #      
	 # Determine if area is slum or other
	 #     
	 typeCol &lt;- rep(j, 3)
	 #
	 # Add interim results to empty matrix
	 #
	 resultDF[i, ifelse(typeCol == 1, 8:10, 11:13)] &lt;- c(total, cases, class)
      }      
    }
  }   
#
# Convert interim results matrix to data.frame
#
resultDF &lt;- data.frame(resultDF)
#
# Name variables in interim results data.frame
#
names(resultDF) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;, &quot;Month&quot;, &quot;Year&quot;,
                     &quot;Indicator Name&quot;, &quot;Indicator Code&quot;, &quot;surveyArea&quot;, 
	                &quot;Low Income Area Total Respondents&quot;, &quot;LOw Income Area Cases&quot;, &quot;Low Income Area Classification&quot;, 
	                &quot;Other Total Respondents&quot;, &quot;Other Cases&quot;, &quot;Other Classification&quot;)
#
# Save results aggregator as CSV
#
write.csv(x = resultDF,
	     file = paste(&quot;outputTables/surveyResultsClassOverall&quot;, 
	                  unique(ccode), unique(month), unique(year),
	                  &quot;.csv&quot;, sep = &quot;&quot;), 
	     row.names = FALSE)    

</command>
			<property title="Classify" shape="MODEL"/>
			<option type="com.ef_prime.rflow.node.base.SubflowNodeModel">
				<subflow>
					<graph version="0.8" width="1443" height="513" locationtype="a" offsetx="260" offsety="68">
						<node id="13" date="1510899095247" uid="567836411fb1af30" x="-20" y="10">
							<command></command>
							<property/>
							<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
								<entry key="io">in</entry>
							</option>
						</node>
						<node id="14" date="1510899095248" uid="241a61efb43264ae" x="140" y="240">
							<command></command>
							<property/>
							<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
								<entry key="io">out</entry>
							</option>
						</node>
						<node id="15" date="1510899095247" uid="b64c0ef804335912" x="60" y="10">
							<command>
################################################################################
#
# Specify LQAS classification parameters
#
################################################################################
#
# Set default upper and lower classification standards
#
upper.value &lt;- tclVar(&quot;0.8&quot;)
lower.value &lt;- tclVar(&quot;0.5&quot;)
#
# Create dialog box
#
choice &lt;- tktoplevel()
#
# Add title to dialog box
#
tkwm.title(choice, &quot;LQAS standards&quot;)
#
# Create input boxes
#
upper.entry &lt;- tkentry(choice, textvariable = upper.value)
lower.entry &lt;- tkentry(choice, textvariable = lower.value)
#
# RESET function for RESET button
#
reset &lt;- function()
  {
  #
  # Specify default parameters
  #
  tclvalue(upper.value) &lt;- &quot;0.8&quot;
  tclvalue(lower.value) &lt;- &quot;0.5&quot;
  }
#
# Create reset button
#
reset.button &lt;- tkbutton(choice, text = &quot;Reset&quot;, command = reset)
#
# SUBMIT function for SUBMIT button
#
submit &lt;- function() 
  {
  #
  # Extract values for upper and lower values
  #
  x &lt;- as.numeric(tclvalue(upper.value))
  y &lt;- as.numeric(tclvalue(lower.value))
  #
  # Prompt user with the upper and lower standards chosen and ask whether to continue
  #
  proceed &lt;- tkmessageBox(title = &quot;LQAS standards&quot;,
                          message = paste(&quot;Upper standard: &quot;, x * 100, &quot;%; Lower standard: &quot;, y * 100, &quot;%. Do you wish to use these standards?&quot;, sep = &quot;&quot;),
                          icon = &quot;question&quot;,
                          type = &quot;yesno&quot;)
  #
  # Determine if user responded not to continue with specified standards
  #
  if(tclvalue(proceed) == &quot;no&quot;)
    {
    #
    # Prompt user that no standards have been specified
    #
    tkmessageBox(title = &quot;LQAS standards&quot;,
                 message = &quot;No standards specified. Specify upper and lower standards&quot;,
                 icon = &quot;warning&quot;,
                 type = &quot;ok&quot;)
    }
  #
  # Determine if user accepted the specified standards
  #
  if(tclvalue(proceed) == &quot;yes&quot;)
    {
    #
    # Close dialog box
    #
    tkdestroy(choice)
    }
  }
#
# Create submit button
#
submit.button &lt;- tkbutton(choice, text = &quot;Submit&quot;, command = submit)
#
# Layout the options and buttons on dialog box
# 
tkgrid(tklabel(choice, text = &quot;Specify upper and lower standards&quot;), columnspan = 2, pady = 5)
tkgrid(tklabel(choice, text = &quot;Upper Standard:&quot;), upper.entry, pady = 5, padx = 5)
tkgrid(tklabel(choice, text = &quot;Lower Standard:&quot;), lower.entry, pady = 5, padx = 5)
tkgrid(submit.button, reset.button, pady = 5, padx = 5)

tkwait.window(choice)


 </command>
							<property title="Specify LQAS parameters" shape="INPUT"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="16" date="1510899095248" uid="7526618811e4b975" x="60" y="80">
							<command>
################################################################################
#
# Perform LQAS on proportion indicators
#
################################################################################
#
# Extract standards provided by user
#
lowerClass &lt;- as.numeric(tclvalue(lower.value))
upperClass &lt;- as.numeric(tclvalue(upper.value))


################################################################################
#
# Results by indicator single output
#
################################################################################
#
# Create empty aggregator object for LQAS results
#
resultAll &lt;- NULL
#
# Cycle through indicators
#
for(i in steerIndicators$varList)
  {
  #
  # Create empty matrix to aggregate interim output
  #
  resultDF &lt;- matrix(ncol = 13, nrow = max(unique(indicatorsDF$zone)))
  #
  # Check type of function required for current indicator is a proportion
  #
  if(steerIndicators$varFunction[steerIndicators$varList == i] == &quot;proportion&quot;)
    {
    #
    # Cycle through survey zones
    #
    for(j in unique(indicatorsDF$zone))
      {
	 #
	 # Cycle through area types i.e. slum and other
	 #
	 for(k in unique(indicatorsDF$type))
	   {
	   #
	   # Subset indicator data to current zone and current area type
	   #
	   temp &lt;- indicatorsDF[indicatorsDF$zone == j &amp; indicatorsDF$type == k, i]
	   #
	   # Count total sample size for current area type
	   #
	   total &lt;- length(!is.na(temp))
	   #
	   # Calculate lower target
	   #
	   class1 &lt;- floor(total * lowerClass)
	   #
	   # Calculate upper target
	   #
	   class2 &lt;- floor(total * upperClass)
	   #
        # Count total number of cases i.e. those for which indicator is TRUE
	   #
	   cases &lt;- sum(temp, na.rm = TRUE)
	   #
	   #
	   #
	   if(is.na(sum(temp)) == TRUE)
	     {
	     cases &lt;- NA
	     }
	   #
	   # Classify
	   #
	   class &lt;- ifelse(is.na(cases), NA,
	              ifelse(cases &lt;= class1, &quot;Low&quot;,
	                ifelse(cases &gt; class2, &quot;High&quot;, &quot;Moderate&quot;)))
	   #      
	   # Determine if area is slum or other
	   #     
	   typeCol &lt;- rep(k, 3)
	   #
	   # Add interim results to empty matrix
	   #
	   resultDF[j, ifelse(typeCol == 1, 8:10, 11:13)] &lt;- c(total, cases, class)
	   }
	}
  }
  #
  # If current indicator does not require proportion function
  #  
  else
    {
    #
    # Cylce through zones
    #
    for(j in unique(indicatorsDF$zone))
      {
      #
      # Cycle through area types i.e. slum or other
      #
	 for(k in unique(indicatorsDF$type))
	   {
        #
        # Subset indicator data to current zone and current area type
        #
	   temp &lt;- indicatorsDF[indicatorsDF$zone == j &amp; indicatorsDF$type == k, i]
	   #
	   # Count total sample size for current area type
	   #
	   total &lt;- length(!is.na(temp))
	   #
        # Set cases to 0 as indicator is not a proportion
	   #
	   cases &lt;- 0
	   #
	   # No classification as current indicator is not a proportion
	   #
	   class &lt;- NA
	   #      
	   # Determine if area is slum or other
	   #     
	   typeCol &lt;- rep(k, 3)
	   #
	   # Add interim results to empty matrix
        #
	   resultDF[j, ifelse(typeCol == 1, 8:10, 11:13)] &lt;- c(total, cases, class)
	   }
      }  
    }
  #
  # Add identifying data to interim results matrix
  #  
  resultDF[,1] &lt;- unique(country)
  resultDF[,2] &lt;- unique(ccode)
  resultDF[,3] &lt;- unique(month)
  resultDF[,4] &lt;- unique(year)
  resultDF[,5] &lt;- steerIndicators$varNames[steerIndicators$varList == i]
  resultDF[,6] &lt;- i
  resultDF[,7] &lt;- paste(&quot;Survey Area&quot;, unique(indicatorsDF$zone), sep = &quot; &quot;)
  #
  # Convert interim results matrix to data.frame
  #
  resultDF &lt;- data.frame(resultDF)
  #
  # Name variables in interim results data.frame
  #
  names(resultDF) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;, &quot;Month&quot;, &quot;Year&quot;,
  	                  &quot;Indicator Name&quot;, &quot;Indicator Code&quot;, &quot;Survey Area&quot;, 
		             &quot;Low Income Area Total Respondents&quot;, &quot;Low Income Area Cases&quot;, &quot;Low Income Area Classification&quot;, 
		             &quot;Other Total Respondents&quot;, &quot;Other Cases&quot;, &quot;Other Classification&quot;)
  #
  # Concatenate interim results data.frame with resulst aggregator
  #
  resultAll &lt;- rbind(resultAll, resultDF)
  }
#
# Save results aggregator as CSV
#
write.csv(x = resultAll,
	     file = paste(&quot;outputTables/surveyResultsClass&quot;, 
	                  unique(ccode), unique(month), unique(year),
	                  &quot;.csv&quot;, sep = &quot;&quot;), 
	     row.names = FALSE)

</command>
							<property title="Classify by area" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="17" date="1510899095247" uid="1be13c2cb4e8e2c4" x="160" y="10">
							<command>
################################################################################
#
# If Country is Bangladesh...
#
################################################################################

################################################################################
#
# Identify sampling points within North and South Corporations
#
################################################################################

if(unique(country) == &quot;Bangladesh&quot;)
  {
  #
  #
  #
  temp &lt;- indicatorsDF[ , c(&quot;psu&quot;, &quot;corporation&quot;)]
  #
  #
  #	
  popDF &lt;- merge(popDF, temp, by = &quot;psu&quot;)
  #
  #
  #
  steer.corporation &lt;- c(&quot;North City Corporation&quot;, &quot;South City Corporation&quot;)	
  						
################################################################################
#
# Perform LQAS on proportion indicators
#
################################################################################
#
# Extract standards provided by user
#
lowerClass &lt;- as.numeric(tclvalue(lower.value))
upperClass &lt;- as.numeric(tclvalue(upper.value))


################################################################################
#
# Results by indicator single output
#
################################################################################
#
# Create empty aggregator object for LQAS results
#
resultAll &lt;- NULL
#
# Cycle through indicators
#
for(i in steerIndicators$varList)
  {
  #
  # Create empty matrix to aggregate interim output
  #
  resultDF &lt;- matrix(ncol = 13, nrow = 2)
  #
  # Check type of function required for current indicator is a proportion
  #
  if(steerIndicators$varFunction[steerIndicators$varList == i] == &quot;proportion&quot;)
    {
    #
    # Cycle through survey zones
    #
    for(j in 1:2)
      {
	 #
	 # Cycle through area types i.e. slum and other
	 #
	 for(k in unique(indicatorsDF$type))
	   {
	   #
	   # Subset indicator data to current zone and current area type
	   #
	   temp &lt;- indicatorsDF[indicatorsDF$corporation == steer.corporation[j] &amp; indicatorsDF$type == k, i]
	   #
	   # Count total sample size for current area type
	   #
	   total &lt;- length(!is.na(temp))
	   #
	   # Calculate lower target
	   #
	   class1 &lt;- floor(total * lowerClass)
	   #
	   # Calculate upper target
	   #
	   class2 &lt;- floor(total * upperClass)
	   #
        # Count total number of cases i.e. those for which indicator is TRUE
	   #
	   cases &lt;- sum(temp, na.rm = TRUE)
	   #
	   #
	   #
	   if(is.na(sum(temp)) == TRUE)
	     {
		cases &lt;- NA
	     }
	   #
	   # Classify
	   #
	   class &lt;- ifelse(is.na(cases), NA,
		         ifelse(cases &lt;= class1, &quot;Low&quot;,
			      ifelse(cases &gt; class2, &quot;High&quot;, &quot;Moderate&quot;)))
	   #      
	   # Determine if area is slum or other
	   #     
	   typeCol &lt;- rep(k, 3)
	   #
	   # Add interim results to empty matrix
	   #
	   resultDF[j, ifelse(typeCol == 1, 8:10, 11:13)] &lt;- c(total, cases, class)
	   }
	}
  }
  #
  # If current indicator does not require proportion function
  #  
  else
    {
    #
    # Cylce through zones
    #
    for(j in 1:2)
      {
      #
      # Cycle through area types i.e. slum or other
      #
	 for(k in unique(indicatorsDF$type))
	   {
        #
        # Subset indicator data to current zone and current area type
        #
	   temp &lt;- indicatorsDF[indicatorsDF$corporation == steer.corporation[j] &amp; indicatorsDF$type == k, i]
	   #
	   # Count total sample size for current area type
	   #
	   total &lt;- length(!is.na(temp))
	   #
        # Set cases to 0 as indicator is not a proportion
	   #
	   cases &lt;- 0
	   #
	   # No classification as current indicator is not a proportion
	   #
	   class &lt;- NA
	   #      
	   # Determine if area is slum or other
	   #     
	   typeCol &lt;- rep(k, 3)
	   #
	   # Add interim results to empty matrix
        #
	   resultDF[j, ifelse(typeCol == 1, 8:10, 11:13)] &lt;- c(total, cases, class)
	   }
      }  
    }
  #
  # Add identifying data to interim results matrix
  #  
  resultDF[,1] &lt;- unique(country)
  resultDF[,2] &lt;- unique(ccode)
  resultDF[,3] &lt;- unique(month)
  resultDF[,4] &lt;- unique(year)
  resultDF[,5] &lt;- steerIndicators$varNames[steerIndicators$varList == i]
  resultDF[,6] &lt;- i
  resultDF[,7] &lt;- steer.corporation
  #
  # Convert interim results matrix to data.frame
  #
  resultDF &lt;- data.frame(resultDF)
  #
  # Name variables in interim results data.frame
  #
  names(resultDF) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;, &quot;Month&quot;, &quot;Year&quot;,
  	                  &quot;Indicator Name&quot;, &quot;Indicator Code&quot;, &quot;Survey Area&quot;, 
		             &quot;Low Income Area Total Respondents&quot;, &quot;Low Income Area Cases&quot;, &quot;Low Income Area Classification&quot;, 
		             &quot;Other Total Respondents&quot;, &quot;Other Cases&quot;, &quot;Other Classification&quot;)
  #
  # Concatenate interim results data.frame with resulst aggregator
  #
  resultAll &lt;- rbind(resultAll, resultDF)
  }
#
# Save results aggregator as CSV
#
write.csv(x = resultAll,
	     file = paste(&quot;outputTables/surveyResultsClassCorporation&quot;, 
	                  unique(ccode), unique(month), unique(year),
	                  &quot;.csv&quot;, sep = &quot;&quot;), 
	     row.names = FALSE)
}
</command>
							<property title="Classify by corporation" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="18" date="1510899095247" uid="107e7996377f4651" x="60" y="240">
							<command>
################################################################################
#
# Perform LQAS on proportion indicators
#
################################################################################
#
# Extract standards provided by user
#
lowerClass &lt;- as.numeric(tclvalue(lower.value))
upperClass &lt;- as.numeric(tclvalue(upper.value))


################################################################################
#
# Results by indicator single output
#
################################################################################
#
# Create empty matrix to aggregate interim output
#
resultDF &lt;- matrix(ncol = 13, nrow = length(steerIndicators$varList))
#
#
#
resultDF[,1] &lt;- unique(country)
resultDF[,2] &lt;- unique(ccode)
resultDF[,3] &lt;- unique(month)
resultDF[,4] &lt;- unique(year)
resultDF[,5] &lt;- steerIndicators$varNames
resultDF[,6] &lt;- steerIndicators$varList
resultDF[,7] &lt;- &quot;Overall&quot;
#
#
#
for(i in 1:length(steerIndicators$varList))
  {
  #
  # Cycle through area types i.e. slum and other
  #
  for(j in unique(indicatorsDF$type))
    {
    #
    # Check type of function required for current indicator is a proportion
    #
    if(steerIndicators$varFunction[i] == &quot;proportion&quot;)
      {
      #
      # Subset indicator data current area type
      #
      temp &lt;- indicatorsDF[indicatorsDF$type == j, steerIndicators$varList[i]]
      #
      # Count total sample size for current area type
      #
      total &lt;- length(!is.na(temp))
      #
      # Calculate lower target
      #
	 class1 &lt;- floor(total * lowerClass)
	 #
	 # Calculate upper target
	 #
	 class2 &lt;- floor(total * upperClass)
	 #
	 # Count total number of cases i.e. those for which indicator is TRUE
	 #
	 cases &lt;- sum(temp, na.rm = TRUE)
 	 #
	 #
	 #
	 if(is.na(sum(temp)) == TRUE)
	   {
	   cases &lt;- NA
	   }
	 #
	 # Classify
	 #
	 class &lt;- ifelse(is.na(cases), NA,
		       ifelse(cases &lt;= class1, &quot;Low&quot;,
			    ifelse(cases &gt; class2, &quot;High&quot;, &quot;Moderate&quot;)))
	 #      
	 # Determine if area is slum or other
	 #     
	 typeCol &lt;- rep(j, 3)
	 #
	 # Add interim results to empty matrix
	 #
	 resultDF[i, ifelse(typeCol == 1, 8:10, 11:13)] &lt;- c(total, cases, class)
      }
    else
	 {
	 #
	 # Subset indicator data to current zone and current area type
	 #
	 temp &lt;- indicatorsDF[indicatorsDF$type == j, steerIndicators$varList[i]]
	 #
	 # Count total sample size for current area type
	 #
	 total &lt;- length(!is.na(temp))
	 #
	 # Set cases to 0 as indicator is not a proportion
	 #
	 cases &lt;- 0
	 #
	 # No classification as current indicator is not a proportion
	 #
	 class &lt;- NA
	 #      
	 # Determine if area is slum or other
	 #     
	 typeCol &lt;- rep(j, 3)
	 #
	 # Add interim results to empty matrix
	 #
	 resultDF[i, ifelse(typeCol == 1, 8:10, 11:13)] &lt;- c(total, cases, class)
      }      
    }
  }   
#
# Convert interim results matrix to data.frame
#
resultDF &lt;- data.frame(resultDF)
#
# Name variables in interim results data.frame
#
names(resultDF) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;, &quot;Month&quot;, &quot;Year&quot;,
                     &quot;Indicator Name&quot;, &quot;Indicator Code&quot;, &quot;surveyArea&quot;, 
	                &quot;Low Income Area Total Respondents&quot;, &quot;LOw Income Area Cases&quot;, &quot;Low Income Area Classification&quot;, 
	                &quot;Other Total Respondents&quot;, &quot;Other Cases&quot;, &quot;Other Classification&quot;)
#
# Save results aggregator as CSV
#
write.csv(x = resultDF,
	     file = paste(&quot;outputTables/surveyResultsClassOverall&quot;, 
	                  unique(ccode), unique(month), unique(year),
	                  &quot;.csv&quot;, sep = &quot;&quot;), 
	     row.names = FALSE)    

</command>
							<property title="Classify overall" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="19" date="1510899095248" uid="8193d39f8ac1b10d" x="60" y="160">
							<command>
################################################################################
#
# Perform LQAS on proportion indicators
#
################################################################################
#
# Extract standards provided by user
#
lowerClass &lt;- as.numeric(tclvalue(lower.value))
upperClass &lt;- as.numeric(tclvalue(upper.value))


################################################################################
#
# Results by indicator single output
#
################################################################################
#
# Create empty aggregator object for LQAS results
#
resultAll &lt;- NULL
#
# Cycle through indicators
#
for(i in steerIndicators$varList)
  {
  #
  # Create empty matrix to aggregate interim output
  #
  resultDF &lt;- matrix(ncol = 13, nrow = max(unique(indicatorsDF$pQuintile)))
  #
  # Check type of function required for current indicator is a proportion
  #
  if(steerIndicators$varFunction[steerIndicators$varList == i] == &quot;proportion&quot;)
    {
    #
    # Cycle through survey zones
    #
    for(j in unique(indicatorsDF$pQuintile))
      {
	 #
	 # Cycle through area types i.e. slum and other
	 #
	 for(k in unique(indicatorsDF$type))
	   {
	   #
	   # Subset indicator data to current zone and current area type
	   #
	   temp &lt;- indicatorsDF[indicatorsDF$pQuintile == j &amp; indicatorsDF$type == k, i]
	   #
	   # Count total sample size for current area type
	   #
	   total &lt;- length(!is.na(temp))
	   #
	   # Calculate lower target
	   #
	   class1 &lt;- floor(total * lowerClass)
	   #
	   # Calculate upper target
	   #
	   class2 &lt;- floor(total * upperClass)
	   #
        # Count total number of cases i.e. those for which indicator is TRUE
	   #
	   cases &lt;- sum(temp, na.rm = TRUE)
	   #
	   #
	   #
	   if(is.na(sum(temp)) == TRUE)
	     {
	     cases &lt;- NA
	     }
	   #
	   # Classify
	   #
	   class &lt;- ifelse(is.na(cases), NA,
		         ifelse(cases &lt;= class1, &quot;Low&quot;,
			      ifelse(cases &gt; class2, &quot;High&quot;, &quot;Moderate&quot;)))
	   #      
	   # Determine if area is slum or other
	   #     
	   typeCol &lt;- rep(k, 3)
	   #
	   # Add interim results to empty matrix
	   #
	   resultDF[j, ifelse(typeCol == 1, 8:10, 11:13)] &lt;- c(total, cases, class)
	   }
	}
  }
  #
  # If current indicator does not require proportion function
  #  
  else
    {
    #
    # Cylce through zones
    #
    for(j in unique(indicatorsDF$pQuintile))
      {
      #
      # Cycle through area types i.e. slum or other
      #
	 for(k in unique(indicatorsDF$type))
	   {
        #
        # Subset indicator data to current zone and current area type
        #
	   temp &lt;- indicatorsDF[indicatorsDF$pQuintile == j &amp; indicatorsDF$type == k, i]
	   #
	   # Count total sample size for current area type
	   #
	   total &lt;- length(!is.na(temp))
	   #
        # Set cases to 0 as indicator is not a proportion
	   #
	   cases &lt;- 0
	   #
	   # No classification as current indicator is not a proportion
	   #
	   class &lt;- NA
	   #      
	   # Determine if area is slum or other
	   #     
	   typeCol &lt;- rep(k, 3)
	   #
	   # Add interim results to empty matrix
        #
	   resultDF[j, ifelse(typeCol == 1, 8:10, 11:13)] &lt;- c(total, cases, class)
	   }
      }  
    }
  #
  # Add identifying data to interim results matrix
  #  
  resultDF[,1] &lt;- unique(country)
  resultDF[,2] &lt;- unique(ccode)
  resultDF[,3] &lt;- unique(month)
  resultDF[,4] &lt;- unique(year)
  resultDF[,5] &lt;- steerIndicators$varNames[steerIndicators$varList == i]
  resultDF[,6] &lt;- i
  resultDF[,7] &lt;- paste(&quot;Wealth Quintile&quot;, 1:j, sep = &quot; &quot;)
  #
  # Convert interim results matrix to data.frame
  #
  resultDF &lt;- data.frame(resultDF)
  #
  # Name variables in interim results data.frame
  #
  names(resultDF) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;, &quot;Month&quot;, &quot;Year&quot;,
  	                  &quot;Indicator Name&quot;, &quot;Indicator Code&quot;, &quot;Wealth Quintile&quot;, 
		             &quot;Low Income Area Total Respondents&quot;, &quot;Low Income Area Cases&quot;, &quot;Low Income Area Classification&quot;, 
		             &quot;Other Total Respondents&quot;, &quot;Other Cases&quot;, &quot;Other Classification&quot;)
  #
  # Concatenate interim results data.frame with resulst aggregator
  #
  resultAll &lt;- rbind(resultAll, resultDF)
  }

# Save results aggregator as CSV
#
write.csv(x = resultAll,
	     file = paste(&quot;outputTables/surveyResultsClassWealth&quot;, 
	                  unique(ccode), unique(month), unique(year),
	                  &quot;.csv&quot;, sep = &quot;&quot;), 
	     row.names = FALSE)

</command>
							<property title="Classify by wealth" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<edge from="16" to="19"/>
						<edge from="13" to="15"/>
						<edge from="15" to="17"/>
						<edge from="19" to="18"/>
						<edge from="18" to="14"/>
						<edge from="15" to="16"/>
					</graph>
				</subflow>
			</option>
		</node>
		<node id="20" date="1510899093932" uid="f303b3e9acc1f99" x="-90" y="1000" disabled="true">
			<command></command>
			<property title="Under development" shape="STAR"/>
			<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
		</node>
		<node id="21" date="1510899093932" uid="9d072a0f7ae42f30" x="-410" y="290">
			<command></command>
			<property/>
			<option type="com.ef_prime.rflow.node.base.CommentNodeModel">
				<entry key="state">opened</entry>
				<entry key="comment">####################
#                  #
#        B.        #
#       READ       #
#       AND        #
#     PROCESS      #
#       DATA       #
#                  #
####################</entry>
			</option>
		</node>
		<node id="22" date="1510899093927" uid="ffe7f675a23cb809" x="-190" y="870">
			<command>
################################################################################
#
# Create single results file - classification and estimation by area
#
################################################################################
#
# Read LQAS results
#
resultsClass &lt;- read.csv(file = paste(&quot;outputTables/surveyResultsClass&quot;, 
                                      unique(ccode), unique(month), unique(year), 
                                      &quot;.csv&quot;, sep = &quot;&quot;),
                         header = TRUE, sep = &quot;,&quot;)
#
# Count sample size for both slum and other
#
resultsClass$total &lt;- resultsClass$Low.Income.Area.Total.Respondents + 
                      resultsClass$Other.Total.Respondents
#
# Rename variables of LQAS results
#
names(resultsClass) &lt;- c(&quot;country&quot;, &quot;countryCode&quot;, &quot;month&quot;, &quot;year&quot;,
	                    &quot;indicatorName&quot;, &quot;indicatorCode&quot;, &quot;surveyArea&quot;,
                         &quot;slumTotal&quot;, &quot;slumCases&quot;, &quot;slumClass&quot;, &quot;otherTotal&quot;,
                         &quot;otherCases&quot;, &quot;otherClass&quot;, &quot;total&quot;)
#
# Read bootstrap results
#
resultsBoot &lt;- read.csv(file = paste(&quot;outputTables/surveyResultsBoot&quot;, 
                                     unique(ccode), unique(month), unique(year),
                                     &quot;.csv&quot;, sep = &quot;&quot;),
                        header = TRUE, sep = &quot;,&quot;)
#
# Rename variables of bootstrap results
#
names(resultsBoot) &lt;- c(&quot;country&quot;, &quot;countryCode&quot;, &quot;month&quot;, &quot;year&quot;,
	                   &quot;indicatorName&quot;, &quot;indicatorCode&quot;, &quot;surveyArea&quot;,
                        &quot;slumEst&quot;, &quot;slumLCL&quot;, &quot;slumUCL&quot;, 
                        &quot;otherEst&quot;, &quot;otherLCL&quot;, &quot;otherUCL&quot;,
                        &quot;totalEst&quot;, &quot;totalLCL&quot;, &quot;totalUCL&quot;)
#
# Merge LQAS and bootstrap results into single data.frame
#
areaResults &lt;- merge(resultsClass, resultsBoot, all.y = TRUE)
#
# Save results as CSV
#
write.csv(x = areaResults,
          file = paste(&quot;outputTables/surveyResultsArea&quot;, 
                       unique(ccode), unique(month), unique(year),
                       &quot;.csv&quot;, sep = &quot;&quot;),
          row.names = FALSE)


################################################################################
#
# Create single results file - classification and estimation by corporation
#
################################################################################
#
#
#
if(unique(country) == &quot;Bangladesh&quot;)
  {
  #
  # Read LQAS results
  #
  resultsClass &lt;- read.csv(file = paste(&quot;outputTables/surveyResultsClassCorporation&quot;, 
	                                   unique(ccode), unique(month), unique(year), 
	                                   &quot;.csv&quot;, sep = &quot;&quot;),
                           header = TRUE, sep = &quot;,&quot;)
  #
  # Count sample size for both slum and other
  #
  resultsClass$total &lt;- resultsClass$Low.Income.Area.Total.Respondents + 
                        resultsClass$Other.Total.Respondents
  #
  # Rename variables of LQAS results
  #
  names(resultsClass) &lt;- c(&quot;country&quot;, &quot;countryCode&quot;, &quot;month&quot;, &quot;year&quot;,
	                      &quot;indicatorName&quot;, &quot;indicatorCode&quot;, &quot;surveyArea&quot;,
	                      &quot;slumTotal&quot;, &quot;slumCases&quot;, &quot;slumClass&quot;, &quot;otherTotal&quot;,
	                      &quot;otherCases&quot;, &quot;otherClass&quot;, &quot;total&quot;)
  #
  # Read bootstrap results
  #
  resultsBoot &lt;- read.csv(file = paste(&quot;outputTables/surveyResultsBootCorporation&quot;, 
	                                  unique(ccode), unique(month), unique(year),
	                                  &quot;.csv&quot;, sep = &quot;&quot;),
                          header = TRUE, sep = &quot;,&quot;)
  #
  # Rename variables of bootstrap results
  #
  names(resultsBoot) &lt;- c(&quot;country&quot;, &quot;countryCode&quot;, &quot;month&quot;, &quot;year&quot;,
	                     &quot;indicatorName&quot;, &quot;indicatorCode&quot;, &quot;surveyArea&quot;,
	                     &quot;slumEst&quot;, &quot;slumLCL&quot;, &quot;slumUCL&quot;, 
	                     &quot;otherEst&quot;, &quot;otherLCL&quot;, &quot;otherUCL&quot;,
	                     &quot;totalEst&quot;, &quot;totalLCL&quot;, &quot;totalUCL&quot;)
  #
  # Merge LQAS and bootstrap results into single data.frame
  #
  corporationResults &lt;- merge(resultsClass, resultsBoot, all.y = TRUE)
  #
  # Save results as CSV
  #
  write.csv(x = corporationResults,
	       file = paste(&quot;outputTables/surveyResultsCorporation&quot;, 
		               unique(ccode), unique(month), unique(year),
		               &quot;.csv&quot;, sep = &quot;&quot;),
	       row.names = FALSE)
  }

################################################################################
#
# Create single results file - classification and estimation by wealth
#
################################################################################
#
# Read LQAS results
#
resultsClass &lt;- read.csv(file = paste(&quot;outputTables/surveyResultsClassWealth&quot;, 
                                      unique(ccode), unique(month), unique(year),
                                      &quot;.csv&quot;, sep = &quot;&quot;),
                         header = TRUE, sep = &quot;,&quot;)
#
# Count sample size for both slum and other
#
resultsClass$total &lt;- resultsClass$Low.Income.Area.Total.Respondents + 
                      resultsClass$Other.Total.Respondents
#
# Rename variables of LQAS results
#
names(resultsClass) &lt;- c(&quot;country&quot;, &quot;countryCode&quot;, &quot;month&quot;, &quot;year&quot;,
	                    &quot;indicatorName&quot;, &quot;indicatorCode&quot;, &quot;wealthQuintile&quot;,
                         &quot;slumTotal&quot;, &quot;slumCases&quot;, &quot;slumClass&quot;, &quot;otherTotal&quot;,
                         &quot;otherCases&quot;, &quot;otherClass&quot;, &quot;total&quot;)
#
# Read bootstrap results
#
resultsBoot &lt;- read.csv(file = paste(&quot;outputTables/surveyResultsBootWealth&quot;, 
                                     unique(ccode), unique(month), unique(year),
                                     &quot;.csv&quot;, sep = &quot;&quot;),
                        header = TRUE, sep = &quot;,&quot;)
#
# Rename variables of bootstrap results
#
names(resultsBoot) &lt;- c(&quot;country&quot;, &quot;countryCode&quot;, &quot;month&quot;, &quot;year&quot;,
	                   &quot;indicatorName&quot;, &quot;indicatorCode&quot;, &quot;wealthQuintile&quot;,
                        &quot;slumEst&quot;, &quot;slumLCL&quot;, &quot;slumUCL&quot;, 
                        &quot;otherEst&quot;, &quot;otherLCL&quot;, &quot;otherUCL&quot;,
                        &quot;totalEst&quot;, &quot;totalLCL&quot;, &quot;totalUCL&quot;)
#
# Merge LQAS and bootstrap results into single data.frame
#
wealthResults &lt;- merge(resultsClass, resultsBoot, all.y = TRUE)
#
# Save results as CSV
#
write.csv(x = wealthResults,
          file = paste(&quot;outputTables/surveyResultsWealth&quot;, 
                       unique(ccode), unique(month), unique(year), 
                       &quot;.csv&quot;, sep = &quot;&quot;),
          row.names = FALSE)


################################################################################
#
# Create single results file - classification and estimation overall
#
################################################################################
#
# Read LQAS results
#
resultsClass &lt;- read.csv(file = paste(&quot;outputTables/surveyResultsClassOverall&quot;, 
                                      unique(ccode), unique(month), unique(year),
                                      &quot;.csv&quot;, sep = &quot;&quot;),
	                    header = TRUE, sep = &quot;,&quot;)
#
# Count sample size for both slum and other
#
resultsClass$total &lt;- resultsClass$Low.Income.Area.Total.Respondents + 
                      resultsClass$Other.Total.Respondents
#
# Rename variables of LQAS results
#
names(resultsClass) &lt;- c(&quot;country&quot;, &quot;countryCode&quot;, &quot;month&quot;, &quot;year&quot;,
	                    &quot;indicatorName&quot;, &quot;indicatorCode&quot;, &quot;surveyArea&quot;,
	                    &quot;slumTotal&quot;, &quot;slumCases&quot;, &quot;slumClass&quot;, 
	                    &quot;otherTotal&quot;, &quot;otherCases&quot;, &quot;otherClass&quot;, &quot;total&quot;)
#
# Read bootstrap results
#
resultsBoot &lt;- read.csv(file = paste(&quot;outputTables/surveyResultsBootOverall&quot;, 
                                     unique(ccode), unique(month), unique(year),
                                     &quot;.csv&quot;, sep = &quot;&quot;),
	                   header = TRUE, sep = &quot;,&quot;)
#
# Rename variables of bootstrap results
#
names(resultsBoot) &lt;- c(&quot;country&quot;, &quot;countryCode&quot;, &quot;month&quot;, &quot;year&quot;,
	                   &quot;indicatorName&quot;, &quot;indicatorCode&quot;, &quot;surveyArea&quot;,
	                   &quot;slumEst&quot;, &quot;slumLCL&quot;, &quot;slumUCL&quot;, 
	                   &quot;otherEst&quot;, &quot;otherLCL&quot;, &quot;otherUCL&quot;,
	                   &quot;totalEst&quot;, &quot;totalLCL&quot;, &quot;totalUCL&quot;)
#
# Merge LQAS and bootstrap results into single data.frame
#
overallResults &lt;- merge(resultsClass, resultsBoot, all.y = TRUE)
#
# Save results as CSV
#
write.csv(x = overallResults,
	     file = paste(&quot;outputTables/surveyResultsOverall&quot;, 
	             unique(ccode), unique(month), unique(year), 
	             &quot;.csv&quot;, sep = &quot;&quot;),
	     row.names = FALSE)
          

################################################################################
#
# Create single results file for all outputs (area, wealth, overall)
#
################################################################################
#
# Rename variables - stratifying variable rename to &quot;strata&quot;
#
names(areaResults)[7] &lt;- &quot;strata&quot;
#
# Rename all results outputs with the same names
#
names(overallResults) &lt;- names(wealthResults) &lt;- names(corporationResults) &lt;- names(areaResults)
#
# Concatenate results
#
surveyResults &lt;- data.frame(rbind(areaResults, corporationResults, wealthResults, overallResults))
#
# Save surveyResults as CSV
#
write.csv(x = surveyResults,
          file = paste(&quot;outputTables/surveyResults&quot;, 
                       unique(ccode), unique(month), unique(year),
                       &quot;.csv&quot;, sep = &quot;&quot;),
          row.names = FALSE)
          
          
################################################################################
#
# Create single results file for all outputs (area, wealth, overall) for all
# countries and dates
#
################################################################################
#
# Get range of survey years based on current year
#
survey.date.range &lt;- 2017:str_split(Sys.Date(), pattern = &quot;-&quot;, simplify = TRUE)[,1]
#
# Get list of months
#
survey.month.range &lt;- substr(format(ISOdate(2004,1:12,1),&quot;%B&quot;), start = 1, stop = 3)
#
# Get list of countries
#
survey.country.code &lt;- c(&quot;BGD&quot;, &quot;GHA&quot;, &quot;KEN&quot;, &quot;MDG&quot;, &quot;MOZ&quot;, &quot;ZMB&quot;)
#
#
#
surveyResultsAll &lt;- NULL
#
#
#
for(i in survey.country.code)
  {
  #
  #
  #
  for(j in survey.month.range)
    {
    #
    #
    #
    for(k in survey.date.range)
      {
      #
      #
      #
      temp &lt;- try(read.csv(file = paste(&quot;outputTables/surveyResults&quot;, i, j, k, &quot;.csv&quot;, sep = &quot;&quot;),
                           header = TRUE, sep = &quot;,&quot;),
                           silent = TRUE)
      #
      #
      #
      if(class(temp) == &quot;try-error&quot;) { temp &lt;- NULL }
      #
      #
      #
      surveyResultsAll &lt;- data.frame(rbind(surveyResultsAll, temp))
      }
    }
  }
    

################################################################################
#
# Create long format data for use in shiny
#
################################################################################
#
# Extract slum results with CIs
#
temp1 &lt;- subset(surveyResultsAll, select = c(country:strata, slumEst:slumUCL))
type &lt;- rep(&quot;Low Income Area&quot;, nrow(temp1))
temp1 &lt;- data.frame(temp1[ , 1:7], type, temp1[ , 8:10])
#
#
#
temp2 &lt;- subset(surveyResultsAll, select = c(country:strata, totalEst:totalUCL))
type &lt;- rep(&quot;Citywide&quot;, nrow(temp2))
temp2 &lt;- data.frame(temp2[ , 1:7], type, temp2[ , 8:10])
#
#
#
names(temp1) &lt;- c(names(temp1)[1:8], &quot;estimate&quot;, &quot;LCL&quot;, &quot;UCL&quot;)
names(temp2) &lt;- names(temp1)
#
#
#
surveyResultsAll &lt;- data.frame(rbind(temp1, temp2))
#
#
#
write.csv(x = surveyResultsAll,
          file = &quot;outputTables/surveyResultsAll.csv&quot;,
          row.names = FALSE)


</command>
			<property title="Combine results" shape="TRANSFORM"/>
			<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
		</node>
		<node id="23" date="1510899093932" uid="6de77d6bde0e30f" x="-410" y="250">
			<command></command>
			<property/>
			<option type="com.ef_prime.rflow.node.base.CommentNodeModel">
				<entry key="state">opened</entry>
				<entry key="comment">################################################################################</entry>
			</option>
		</node>
		<node id="24" date="1510899093933" uid="36db297980fda53" x="-190" y="400">
			<command>
################################################################################
#
# Rename survey data variable names
#
################################################################################
#
# Get variable names of survey data
#
varNames &lt;- names(surveyDataX)
#
# Split words in the variable names to allow for word manipulation
#
temp &lt;- str_split(string = varNames, pattern = &quot;[.]&quot;)
#
# Create storage object for variable name vector
#
varNames &lt;- NULL
#
# Cycle through the split up list of words of the variable names
#
for(i in 1:length(temp))
  {
  #
  # Create appropriate variable names based on split up words
  #
  varNames &lt;- c(varNames, paste(temp[[i]], sep = &quot; &quot;, collapse = &quot; &quot;))
  }
#
# Create variable code list vector matching variable names
#
# CAUTION: This script is hardcoded to create a variable list based on the
#          existing questionnaire. Any changes in the questionnaire sequence
#          (i.e., addition or deletion of questions) will break the
#          software
#
varList &lt;- c(&quot;deployment&quot;, &quot;enumerator&quot;, &quot;status&quot;, &quot;responseCode&quot;,
	        &quot;draftDate&quot;, &quot;submissionDate&quot;, &quot;ipAddress&quot;, &quot;surveyType&quot;, 
	        &quot;psu&quot;, &quot;psuTime&quot;, &quot;latitude&quot;, &quot;longitude&quot;, &quot;accuracy&quot;,
	        &quot;altitude&quot;, &quot;area1&quot;, &quot;area1Other&quot;, &quot;area1Time&quot;, &quot;area2&quot;,
             &quot;slum&quot;, &quot;houseIdentifiers&quot;, &quot;gender&quot;, &quot;landOwnStatus&quot;, 
             &quot;nWomen&quot;, &quot;nMen&quot;, &quot;nOldWomen&quot;, &quot;nOldMen&quot;, &quot;nGirls&quot;,
	        &quot;nBoys&quot;, &quot;nInfants&quot;, &quot;nMobility&quot;,
	        paste(&quot;water&quot;, 1:59, sep = &quot;&quot;),
	        paste(&quot;san&quot;, 1:89, sep = &quot;&quot;),
	        &quot;wash60&quot;, &quot;wash61&quot;, &quot;wash62&quot;,
	        paste(&quot;san&quot;, 90:106, sep = &quot;&quot;),
	        paste(&quot;ppi&quot;, 1:11, sep = &quot;&quot;))
#
# Rename surveyDataX data.frame using the variable code list created
#
names(surveyDataX) &lt;- varList


################################################################################
#
# Create sampling unit identifiers (i.e, country, zone, type, quadrat)
#
################################################################################
#
# Create country vector
#
country &lt;- rep(country, nrow(surveyDataX))
#
# Create country code vector
#
ccode &lt;- rep(ccode, nrow(surveyDataX))
#
# Extract survey area from psu data
#
zone &lt;- trunc(surveyDataX$psu / 1000)
#
# Extract survey area type from psu data
#
type &lt;- trunc((surveyDataX$psu - signif(surveyDataX$psu, digits = 1)) / 100)
#
# extract quadrat number/sampling point id from psu data
#
quadrat &lt;- as.numeric(sprintf(&quot;%02d&quot;, surveyDataX$psu %% 100))
#
# Add survey month
#
month &lt;- as.numeric(
	      str_split(
	        string = surveyDataX$submissionDate, 
	        pattern = &quot;/&quot;,
	        simplify = TRUE
	      )[ , 2]
	    )
#
# Convert numeric month to month name
#
month &lt;- ifelse(month == 1, &quot;Jan&quot;,
           ifelse(month == 2, &quot;Feb&quot;,
             ifelse(month == 3, &quot;Mar&quot;,
               ifelse(month == 4, &quot;Apr&quot;,
                 ifelse(month == 5, &quot;May&quot;,
                   ifelse(month == 6, &quot;Jun&quot;,
                     ifelse(month == 7, &quot;Jul&quot;,
                       ifelse(month == 8, &quot;Aug&quot;,
                         ifelse(month == 9, &quot;Sep&quot;,
                           ifelse(month == 10, &quot;Oct&quot;,
                             ifelse(month == 11, &quot;Nov&quot;, &quot;Dec&quot;)))))))))))	    

#
# Add survey month
#
year &lt;- as.numeric(
	     str_split(
	       string = surveyDataX$submissionDate, 
	       pattern = &quot;/&quot;,
	       simplify = TRUE
	     )[ , 3]
	   )


################################################################################
#
# Lines 132, 133, 134 below are specific to the first Dhaka, Bangladesh survey
# and were used to re-assign sampling points to more appropriate survey areas 
# based on GPS location.
#
################################################################################
#
# Run next lines only if survey was done on the 3rd month of 2017 in Dhaka
#
if(unique(country) == &quot;Bangladesh&quot; &amp; unique(year) == 2017 &amp; unique(month) == &quot;Mar&quot;)
  {
  #
  # Re-code zones for PSUs based on actual location after survey
  #
  zone[surveyDataX$psu == 3101] &lt;- 1
  zone[surveyDataX$psu == 9215] &lt;- 8
  zone[surveyDataX$psu %in% c(8110, 8111, 8114, 8115)] &lt;- 9
  }


################################################################################
#
# Add household ID
#
################################################################################
#
# Create hhid container vector
#
hhid &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyDataX))
#
# Cylce through each unique psu ids
#
for(i in unique(surveyDataX$psu))
  {
  #
  # Assign household ids
  #
  hhid[surveyDataX$psu == i] &lt;- 1:2
  }
#
# Create unique IDs by adding psuid and hhid
#
uniqueID &lt;- (surveyDataX$psu * 100) + hhid
#
# Create admin data.frame for sampling point identifiers
#
admin &lt;- data.frame(country, ccode, zone, type, quadrat, hhid, uniqueID, month, year)
#
# Add unique ID to administrative data
#
surveyDataX &lt;- data.frame(admin, surveyDataX)
#
# Save ammended survey data as workingSurveyData.csv
#
write.csv(x = surveyDataX,
	     file = paste(&quot;data/workingSurveyData&quot;, unique(ccode), &quot;.csv&quot;, sep = &quot;&quot;),
	     row.names = FALSE)


################################################################################
#
# Create codebook for survey data variables
#
################################################################################
#
# Expand variable code list and variable names list
#
varList  &lt;- c(&quot;country&quot;, &quot;countryCode&quot;, &quot;zone&quot;, &quot;type&quot;, &quot;quadrat&quot;, &quot;hhid&quot;, 
              &quot;uniqueID&quot;, &quot;month&quot;, &quot;year&quot;, varList)
varNames &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;, &quot;Enumeration Area&quot;, &quot;Sampling Point Type&quot;, 
              &quot;Quadrat Number&quot;, &quot;Household ID&quot;, &quot;Unique ID&quot;, &quot;Month of Survey&quot;, 
              &quot;Year of Survey&quot;, varNames)
#
# Concatenate variable code list and variable names list vectors
#             
codeBook &lt;- data.frame(varList, varNames)
#
# 
#
write.csv(x = codeBook, 
          file = paste(&quot;outputLists/codeBook&quot;, unique(ccode), &quot;.csv&quot;, sep = &quot;&quot;),
          row.names = FALSE)
#
# Clean-up
#
rm(varList, varNames, codeBook, temp, hhid, uniqueID, 
   admin, zone, type, quadrat, i)

</command>
			<property title="Process data" shape="TRANSFORM"/>
			<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
		</node>
		<node id="25" date="1510899093927" uid="306cb8f357eac3a8" x="-410" y="970">
			<command></command>
			<property/>
			<option type="com.ef_prime.rflow.node.base.CommentNodeModel">
				<entry key="state">opened</entry>
				<entry key="comment">####################
#                  #
#  E. Development  #
#                  #
####################</entry>
			</option>
		</node>
		<node id="26" date="1510899093932" uid="94c267b267c1978c" x="-90" y="400">
			<command></command>
			<property title="Run STEP 2b" shape="STAR">
				<comment state="opened" x="60" y="-20">STEP 2b: Read and process
         data</comment>
			</property>
			<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
		</node>
		<node id="27" date="1510899095248" uid="8cf9a81b5c1d6e3b" x="-300" y="760">
			<command>
################################################################################
#
#  Select and read indicator steering file: Accepts CSV data files
#
################################################################################
#
# Prompt user to supply indicator steering file
#
tkmessageBox(title = &quot;Load file&quot;,
             message = &quot;Select indicators steering file&quot;, 
	        icon = &quot;info&quot;, 
	        type = &quot;ok&quot;)
#
# Cycle through indicator steering file selection prompts
#
repeat
  {
  #
  # Cycle through indicator steering file selection prompts when no file is selected
  #
  repeat
    {
    #
    # Select indicator steering file
    #
    fileName &lt;- tclvalue(tkgetOpenFile())
    #
    # Determine if a indicator steering file has been selected
    #	
    if(!nchar(fileName)) 
      {
      #
      # Prompt user that no file has been selected
      #
      error1 &lt;- tkmessageBox(title = &quot;Error&quot;,
				         message = &quot;No file was selected! Please try again.&quot;,
				         icon = &quot;error&quot;,
				         type = &quot;retrycancel&quot;)
      }
    #
    # Break repeat once any file has been selected
    #	
    if(nchar(fileName) &gt; 0) break
    #
    # Break repeat if user cancels option to select file
    #
    if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
    } 
  #
  # Break repeat if user cancels option to select file
  #
  if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  #
  # Try to read indicator steering file based on filename provided by user
  #	
  steerIndicators &lt;- try(expr = read.csv(file = fileName, header = TRUE, sep = &quot;,&quot;), 
		               silent = TRUE)
  #
  # Check if indicator steering file provided is in correct format (CSV file)
  #
  if(exists(&quot;steerIndicators&quot;) &amp;&amp; class(steerIndicators) == &quot;try-error&quot;)
    {
    #
    # Prompt user that file format is incorrect
    #
    error2 &lt;- tkmessageBox(title = &quot;Error&quot;,
			            message = paste(&quot;Problem reading file &apos;&quot;, basename(fileName), &quot;&apos;. Please try again&quot;, sep = &quot;,&quot;),
			            icon = &quot;error&quot;,
			            type = &quot;retrycancel&quot;)
    }
  #
  # Break repeat once selected indicator steering file is in correct format
  #
  if(exists(&quot;steerIndicators&quot;) &amp;&amp; class(steerIndicators) != &quot;try-error&quot;) break
  #
  # Break repeat if user cancels option to retry providing a new file
  #
  if(exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;) break
  }
#
# Determine if user cancels option to select file or cancels option to retry providing a new file
#
if((exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) | (exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;))
  {
  #
  # Prompt user that no file has been loaded
  #
  tkmessageBox(title = &quot;Warning&quot;,
		     message = &quot;You have not loaded any data file&quot;,
		     icon = &quot;warning&quot;,
		     type = &quot;ok&quot;)
  }
#
# Determine user has successfully selected and loaded an appropriate data file
#
if(exists(&quot;steerIndicators&quot;) &amp;&amp; class(steerIndicators) != &quot;try-error&quot;)
  {
  #
  # Prompt use of the filename of the indicator steering file file selected
  #
  tkmessageBox(title = &quot;Success!&quot;,
     		message = paste(&quot;You have loaded the data file named &apos;&quot;, basename(fileName), &quot;&apos;.&quot;, sep = &quot;&quot;),
		     icon = &quot;info&quot;,
		     type = &quot;ok&quot;)
  }
#
# Clean-up filename
#
rm(fileName)
#
# Clean-up error1 if present
#
if(exists(&quot;error1&quot;))
  {
  rm(error1)
  }
#
# Clean-up error2 if present
#
if(exists(&quot;error2&quot;))
  {
  rm(error2)
  }
#
#
#
steerIndicators &lt;- subset(steerIndicators, get(unique(country)) == 1)








################################################################################
#
#  Select and read indicator data: Accepts CSV data files
#
################################################################################
#
# Prompt user to supply indicator data file
#
tkmessageBox(title = &quot;Load file&quot;,
	        message = &quot;Select indicators data file&quot;, 
	        icon = &quot;info&quot;, 
	        type = &quot;ok&quot;)
#
# Cycle through indicator data file selection prompts
#
repeat
  {
  #
  # Cycle through indicator data file selection prompts when no file is selected
  #
  repeat
    {
    #
    # Select indicator data file
    #
    fileName &lt;- tclvalue(tkgetOpenFile())
    #
    # Determine if a indicator data file has been selected
    #	
    if(!nchar(fileName)) 
      {
      #
      # Prompt user that no file has been selected
      #
      error1 &lt;- tkmessageBox(title = &quot;Error&quot;,
				         message = &quot;No file was selected! Please try again.&quot;,
				         icon = &quot;error&quot;,
				         type = &quot;retrycancel&quot;)
      }
    #
    # Break repeat once any file has been selected
    #	
    if(nchar(fileName) &gt; 0) break
    #
    # Break repeat if user cancels option to select file
    #
    if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  }
  #
  # Break repeat if user cancels option to select file
  #
  if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  #
  # Try to read indicator steering file based on filename provided by user
  #
  indicatorsDF &lt;- try(expr = read.csv(file = fileName, header = TRUE, sep = &quot;,&quot;), 
		            silent = TRUE)
  #
  # Check if indicator steering file provided is in correct format (CSV file)
  #
  if(exists(&quot;indicatorsDF&quot;) &amp;&amp; class(indicatorsDF) == &quot;try-error&quot;)
    {
    #
    # Prompt user that file format is incorrect
    #
    error2 &lt;- tkmessageBox(title = &quot;Error&quot;,
			            message = paste(&quot;Problem reading file &apos;&quot;, basename(fileName), &quot;&apos;. Please try again&quot;, sep = &quot;,&quot;),
			            icon = &quot;error&quot;,
			            type = &quot;retrycancel&quot;)
    }
  #
  # Break repeat once selected indicator data file is in correct format
  #
  if(exists(&quot;indicatorsDF&quot;) &amp;&amp; class(indicatorsDF) != &quot;try-error&quot;) break
  #
  # Break repeat if user cancels option to retry providing a new file
  #
  if(exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;) break
  }
#
# Determine if user cancels option to select file or cancels option to retry providing a new file
#
if((exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) | (exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;))
  {
  #
  # Prompt user that no file has been loaded
  #
  tkmessageBox(title = &quot;Warning&quot;,
 		     message = &quot;You have not loaded any data file&quot;,
		     icon = &quot;warning&quot;,
		     type = &quot;ok&quot;)
  }
#
# Determine user has successfully selected and loaded an appropriate data file
#
if(exists(&quot;indicatorsDF&quot;) &amp;&amp; class(indicatorsDF) != &quot;try-error&quot;)
  {
  #
  # Prompt use of the filename of the indicator steering file file selected
  #
  tkmessageBox(title = &quot;Success!&quot;,
		     message = paste(&quot;You have loaded the data file named &apos;&quot;, basename(fileName), &quot;&apos;.&quot;, sep = &quot;&quot;),
		     icon = &quot;info&quot;,
		     type = &quot;ok&quot;)
  }
#
# Clean-up filename
#
rm(fileName)
#
# Clean-up error1 if present
#
if(exists(&quot;error1&quot;))
  {
  rm(error1)
  }
#
# Clean-up error2 if present
#
if(exists(&quot;error2&quot;))
  {
  rm(error2)
  }



################################################################################
#
#  Select and read population data: Accepts CSV data files
#
################################################################################
#
# Prompt user to supply survey data
#
tkmessageBox(title = &quot;Load data&quot;,
             message = &quot;Select population data&quot;, 
	        icon = &quot;info&quot;, 
	        type = &quot;ok&quot;)
#
# Cycle through survey data selection prompts
#
repeat
  {
  #
  # Cycle through survey data selection prompts when no file is selected
  #
  repeat
    {
    #
    # Select survey data file
    #
    fileName &lt;- tclvalue(tkgetOpenFile())
    #
    # Determine if a survey data file has been selected
    #	
    if(!nchar(fileName)) 
      {
      #
      # Prompt user that no file has been selected
      #
      error1 &lt;- tkmessageBox(title = &quot;Error&quot;,
				         message = &quot;No file was selected! Please try again.&quot;,
				         icon = &quot;error&quot;,
				         type = &quot;retrycancel&quot;)
      }
    #
    # Break repeat once any file has been selected
    #	
    if(nchar(fileName) &gt; 0) break
    #
    # Break repeat if user cancels option to select file
    #
    if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
    } 
  #
  # Break repeat if user cancels option to select file
  #
  if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  #
  # Try to read survey data based on filename provided by user
  #	
  popDF &lt;- try(expr = read.csv(file = fileName, header = TRUE, sep = &quot;,&quot;), 
		     silent = TRUE)
  #
  # Check if survey data file provided is in correct format (CSV file)
  #
  if(exists(&quot;popDF&quot;) &amp;&amp; class(popDF) == &quot;try-error&quot;)
    {
    #
    # Prompt user that file format is incorrect
    #
    error2 &lt;- tkmessageBox(title = &quot;Error&quot;,
			            message = paste(&quot;Problem reading file &apos;&quot;, basename(fileName), &quot;&apos;. Please try again&quot;, sep = &quot;,&quot;),
			            icon = &quot;error&quot;,
			            type = &quot;retrycancel&quot;)
    }
  #
  # Break repeat once selected survey data is in correct format
  #
  if(exists(&quot;popDF&quot;) &amp;&amp; class(popDF) != &quot;try-error&quot;) break
  #
  # Break repeat if user cancels option to retry providing a new file
  #
  if(exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;) break
  }
#
# Determine if user cancels option to select file or cancels option to retry providing a new file
#
if((exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) | (exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;))
  {
  #
  # Prompt user that no file has been loaded
  #
  tkmessageBox(title = &quot;Warning&quot;,
		     message = &quot;You have not loaded any data file&quot;,
		     icon = &quot;warning&quot;,
		     type = &quot;ok&quot;)
  }
#
# Determine user has successfully selected and loaded an appropriate data file
#
if(exists(&quot;popDF&quot;) &amp;&amp; class(popDF) != &quot;try-error&quot;)
  {
  #
  # Prompt use of the filename of the survey data file selected
  #
  tkmessageBox(title = &quot;Success!&quot;,
     		message = paste(&quot;You have loaded the data file named &apos;&quot;, basename(fileName), &quot;&apos;.&quot;, sep = &quot;&quot;),
		     icon = &quot;info&quot;,
		     type = &quot;ok&quot;)
  }
#
# Clean-up filename
#
rm(fileName)
#
# Clean-up error1 if present
#
if(exists(&quot;error1&quot;))
  {
  rm(error1)
  }
#
# Clean-up error2 if present
#
if(exists(&quot;error2&quot;))
  {
  rm(error2)
  }

</command>
			<property title="Read data to analyse" shape="INOUT"/>
			<option type="com.ef_prime.rflow.node.base.SubflowNodeModel">
				<subflow>
					<graph version="0.8" width="783" height="245" locationtype="a" offsetx="120" offsety="41">
						<node id="28" date="1510899095248" uid="449ce245f1d6f921" x="0" y="0">
							<command>
################################################################################
#
#  Select and read indicator steering file: Accepts CSV data files
#
################################################################################
#
# Prompt user to supply indicator steering file
#
tkmessageBox(title = &quot;Load file&quot;,
             message = &quot;Select indicators steering file&quot;, 
	        icon = &quot;info&quot;, 
	        type = &quot;ok&quot;)
#
# Cycle through indicator steering file selection prompts
#
repeat
  {
  #
  # Cycle through indicator steering file selection prompts when no file is selected
  #
  repeat
    {
    #
    # Select indicator steering file
    #
    fileName &lt;- tclvalue(tkgetOpenFile())
    #
    # Determine if a indicator steering file has been selected
    #	
    if(!nchar(fileName)) 
      {
      #
      # Prompt user that no file has been selected
      #
      error1 &lt;- tkmessageBox(title = &quot;Error&quot;,
				         message = &quot;No file was selected! Please try again.&quot;,
				         icon = &quot;error&quot;,
				         type = &quot;retrycancel&quot;)
      }
    #
    # Break repeat once any file has been selected
    #	
    if(nchar(fileName) &gt; 0) break
    #
    # Break repeat if user cancels option to select file
    #
    if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
    } 
  #
  # Break repeat if user cancels option to select file
  #
  if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  #
  # Try to read indicator steering file based on filename provided by user
  #	
  steerIndicators &lt;- try(expr = read.csv(file = fileName, header = TRUE, sep = &quot;,&quot;), 
		               silent = TRUE)
  #
  # Check if indicator steering file provided is in correct format (CSV file)
  #
  if(exists(&quot;steerIndicators&quot;) &amp;&amp; class(steerIndicators) == &quot;try-error&quot;)
    {
    #
    # Prompt user that file format is incorrect
    #
    error2 &lt;- tkmessageBox(title = &quot;Error&quot;,
			            message = paste(&quot;Problem reading file &apos;&quot;, basename(fileName), &quot;&apos;. Please try again&quot;, sep = &quot;,&quot;),
			            icon = &quot;error&quot;,
			            type = &quot;retrycancel&quot;)
    }
  #
  # Break repeat once selected indicator steering file is in correct format
  #
  if(exists(&quot;steerIndicators&quot;) &amp;&amp; class(steerIndicators) != &quot;try-error&quot;) break
  #
  # Break repeat if user cancels option to retry providing a new file
  #
  if(exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;) break
  }
#
# Determine if user cancels option to select file or cancels option to retry providing a new file
#
if((exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) | (exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;))
  {
  #
  # Prompt user that no file has been loaded
  #
  tkmessageBox(title = &quot;Warning&quot;,
		     message = &quot;You have not loaded any data file&quot;,
		     icon = &quot;warning&quot;,
		     type = &quot;ok&quot;)
  }
#
# Determine user has successfully selected and loaded an appropriate data file
#
if(exists(&quot;steerIndicators&quot;) &amp;&amp; class(steerIndicators) != &quot;try-error&quot;)
  {
  #
  # Prompt use of the filename of the indicator steering file file selected
  #
  tkmessageBox(title = &quot;Success!&quot;,
     		message = paste(&quot;You have loaded the data file named &apos;&quot;, basename(fileName), &quot;&apos;.&quot;, sep = &quot;&quot;),
		     icon = &quot;info&quot;,
		     type = &quot;ok&quot;)
  }
#
# Clean-up filename
#
rm(fileName)
#
# Clean-up error1 if present
#
if(exists(&quot;error1&quot;))
  {
  rm(error1)
  }
#
# Clean-up error2 if present
#
if(exists(&quot;error2&quot;))
  {
  rm(error2)
  }
#
#
#
steerIndicators &lt;- subset(steerIndicators, get(unique(country)) == 1)





</command>
							<property title="Read steering file" shape="INOUT"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="29" date="1510899095248" uid="baa30ca3b6e4982" x="-80" y="0">
							<command></command>
							<property/>
							<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
								<entry key="io">in</entry>
							</option>
						</node>
						<node id="30" date="1510899095248" uid="6b2eff1384f13e6" x="50" y="80">
							<command>

################################################################################
#
#  Select and read indicator data: Accepts CSV data files
#
################################################################################
#
# Prompt user to supply indicator data file
#
tkmessageBox(title = &quot;Load file&quot;,
	        message = &quot;Select indicators data file&quot;, 
	        icon = &quot;info&quot;, 
	        type = &quot;ok&quot;)
#
# Cycle through indicator data file selection prompts
#
repeat
  {
  #
  # Cycle through indicator data file selection prompts when no file is selected
  #
  repeat
    {
    #
    # Select indicator data file
    #
    fileName &lt;- tclvalue(tkgetOpenFile())
    #
    # Determine if a indicator data file has been selected
    #	
    if(!nchar(fileName)) 
      {
      #
      # Prompt user that no file has been selected
      #
      error1 &lt;- tkmessageBox(title = &quot;Error&quot;,
				         message = &quot;No file was selected! Please try again.&quot;,
				         icon = &quot;error&quot;,
				         type = &quot;retrycancel&quot;)
      }
    #
    # Break repeat once any file has been selected
    #	
    if(nchar(fileName) &gt; 0) break
    #
    # Break repeat if user cancels option to select file
    #
    if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  }
  #
  # Break repeat if user cancels option to select file
  #
  if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  #
  # Try to read indicator steering file based on filename provided by user
  #
  indicatorsDF &lt;- try(expr = read.csv(file = fileName, header = TRUE, sep = &quot;,&quot;), 
		            silent = TRUE)
  #
  # Check if indicator steering file provided is in correct format (CSV file)
  #
  if(exists(&quot;indicatorsDF&quot;) &amp;&amp; class(indicatorsDF) == &quot;try-error&quot;)
    {
    #
    # Prompt user that file format is incorrect
    #
    error2 &lt;- tkmessageBox(title = &quot;Error&quot;,
			            message = paste(&quot;Problem reading file &apos;&quot;, basename(fileName), &quot;&apos;. Please try again&quot;, sep = &quot;,&quot;),
			            icon = &quot;error&quot;,
			            type = &quot;retrycancel&quot;)
    }
  #
  # Break repeat once selected indicator data file is in correct format
  #
  if(exists(&quot;indicatorsDF&quot;) &amp;&amp; class(indicatorsDF) != &quot;try-error&quot;) break
  #
  # Break repeat if user cancels option to retry providing a new file
  #
  if(exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;) break
  }
#
# Determine if user cancels option to select file or cancels option to retry providing a new file
#
if((exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) | (exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;))
  {
  #
  # Prompt user that no file has been loaded
  #
  tkmessageBox(title = &quot;Warning&quot;,
 		     message = &quot;You have not loaded any data file&quot;,
		     icon = &quot;warning&quot;,
		     type = &quot;ok&quot;)
  }
#
# Determine user has successfully selected and loaded an appropriate data file
#
if(exists(&quot;indicatorsDF&quot;) &amp;&amp; class(indicatorsDF) != &quot;try-error&quot;)
  {
  #
  # Prompt use of the filename of the indicator steering file file selected
  #
  tkmessageBox(title = &quot;Success!&quot;,
		     message = paste(&quot;You have loaded the data file named &apos;&quot;, basename(fileName), &quot;&apos;.&quot;, sep = &quot;&quot;),
		     icon = &quot;info&quot;,
		     type = &quot;ok&quot;)
  }
#
# Clean-up filename
#
rm(fileName)
#
# Clean-up error1 if present
#
if(exists(&quot;error1&quot;))
  {
  rm(error1)
  }
#
# Clean-up error2 if present
#
if(exists(&quot;error2&quot;))
  {
  rm(error2)
  }

</command>
							<property title="Read indicator data" shape="INOUT"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="31" date="1510899095248" uid="80eaffc1002c6588" x="100" y="0">
							<command>
################################################################################
#
#  Select and read population data: Accepts CSV data files
#
################################################################################
#
# Prompt user to supply survey data
#
tkmessageBox(title = &quot;Load data&quot;,
             message = &quot;Select population data&quot;, 
	        icon = &quot;info&quot;, 
	        type = &quot;ok&quot;)
#
# Cycle through survey data selection prompts
#
repeat
  {
  #
  # Cycle through survey data selection prompts when no file is selected
  #
  repeat
    {
    #
    # Select survey data file
    #
    fileName &lt;- tclvalue(tkgetOpenFile())
    #
    # Determine if a survey data file has been selected
    #	
    if(!nchar(fileName)) 
      {
      #
      # Prompt user that no file has been selected
      #
      error1 &lt;- tkmessageBox(title = &quot;Error&quot;,
				         message = &quot;No file was selected! Please try again.&quot;,
				         icon = &quot;error&quot;,
				         type = &quot;retrycancel&quot;)
      }
    #
    # Break repeat once any file has been selected
    #	
    if(nchar(fileName) &gt; 0) break
    #
    # Break repeat if user cancels option to select file
    #
    if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
    } 
  #
  # Break repeat if user cancels option to select file
  #
  if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  #
  # Try to read survey data based on filename provided by user
  #	
  popDF &lt;- try(expr = read.csv(file = fileName, header = TRUE, sep = &quot;,&quot;), 
		     silent = TRUE)
  #
  # Check if survey data file provided is in correct format (CSV file)
  #
  if(exists(&quot;popDF&quot;) &amp;&amp; class(popDF) == &quot;try-error&quot;)
    {
    #
    # Prompt user that file format is incorrect
    #
    error2 &lt;- tkmessageBox(title = &quot;Error&quot;,
			            message = paste(&quot;Problem reading file &apos;&quot;, basename(fileName), &quot;&apos;. Please try again&quot;, sep = &quot;,&quot;),
			            icon = &quot;error&quot;,
			            type = &quot;retrycancel&quot;)
    }
  #
  # Break repeat once selected survey data is in correct format
  #
  if(exists(&quot;popDF&quot;) &amp;&amp; class(popDF) != &quot;try-error&quot;) break
  #
  # Break repeat if user cancels option to retry providing a new file
  #
  if(exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;) break
  }
#
# Determine if user cancels option to select file or cancels option to retry providing a new file
#
if((exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) | (exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;))
  {
  #
  # Prompt user that no file has been loaded
  #
  tkmessageBox(title = &quot;Warning&quot;,
		     message = &quot;You have not loaded any data file&quot;,
		     icon = &quot;warning&quot;,
		     type = &quot;ok&quot;)
  }
#
# Determine user has successfully selected and loaded an appropriate data file
#
if(exists(&quot;popDF&quot;) &amp;&amp; class(popDF) != &quot;try-error&quot;)
  {
  #
  # Prompt use of the filename of the survey data file selected
  #
  tkmessageBox(title = &quot;Success!&quot;,
     		message = paste(&quot;You have loaded the data file named &apos;&quot;, basename(fileName), &quot;&apos;.&quot;, sep = &quot;&quot;),
		     icon = &quot;info&quot;,
		     type = &quot;ok&quot;)
  }
#
# Clean-up filename
#
rm(fileName)
#
# Clean-up error1 if present
#
if(exists(&quot;error1&quot;))
  {
  rm(error1)
  }
#
# Clean-up error2 if present
#
if(exists(&quot;error2&quot;))
  {
  rm(error2)
  }

</command>
							<property title="Read pop data" shape="INOUT"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="32" date="1510899095248" uid="7a90df27074cfaee" x="190" y="0">
							<command></command>
							<property/>
							<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
								<entry key="io">out</entry>
							</option>
						</node>
						<edge from="31" to="32"/>
						<edge from="29" to="28"/>
						<edge from="30" to="31"/>
						<edge from="28" to="30"/>
					</graph>
				</subflow>
			</option>
		</node>
		<node id="33" date="1510899095247" uid="325c4cd5d23f99ed" x="-410" y="940">
			<command></command>
			<property/>
			<option type="com.ef_prime.rflow.node.base.CommentNodeModel">
				<entry key="state">opened</entry>
				<entry key="comment">################################################################################</entry>
			</option>
		</node>
		<node id="34" date="1510899093932" uid="662b09212f6277cb" x="-410" y="460">
			<command></command>
			<property/>
			<option type="com.ef_prime.rflow.node.base.CommentNodeModel">
				<entry key="state">opened</entry>
				<entry key="comment">################################################################################</entry>
			</option>
		</node>
		<node id="35" date="1510899093932" uid="2a9cb3bf44749748" x="-190" y="790">
			<command>
################################################################################
#
# Specify bootstrapping parameters
#
################################################################################
#
# Set default number of replicates
#
replicates &lt;- tclVar(&quot;399&quot;)
#
# Create dialog box
#
choice &lt;- tktoplevel()
#
# Add title to dialog box
#
tkwm.title(choice, &quot;Bootstrap replicates&quot;)
#
# Create input box
#
replicates.entry &lt;- tkentry(choice, textvariable = replicates)
#
# RESET function for RESET button
#
reset &lt;- function()
  {
  #
  # Reset user input back to default
  #
  tclvalue(replicates) &lt;- &quot;399&quot;
  }
#
# Create reset button
#
reset.button &lt;- tkbutton(choice, text = &quot;Reset&quot;, command = reset)
#
# SUBMIT function for SUBMIT button
#
submit &lt;- function() 
  {
  #
  # Extract user input
  #
  x &lt;- as.numeric(tclvalue(replicates))
  #
  # Prompt user with input specified and ask whether to proceed
  #
  proceed &lt;- tkmessageBox(title = &quot;Bootstrap replicates&quot;,
                          message = paste(&quot;You specified &quot;, x, &quot; replicates for bootstrapping. Do you wish to continue?&quot;, sep = &quot;&quot;),
                          icon = &quot;question&quot;,
                          type = &quot;yesno&quot;)
  #
  # Determine if user does not want to continue with specified values
  #
  if(tclvalue(proceed) == &quot;no&quot;)
    {
    #
    # Prompt user that no replicates specified
    #
    tkmessageBox(title = &quot;Bootstrap replicates&quot;,
                 message = &quot;No number of replicates specified. Specify number of replicates&quot;,
                 icon = &quot;warning&quot;,
                 type = &quot;ok&quot;)
    }
  #
  # Determine if user wishes to proceed with specified replicates
  #
  if(tclvalue(proceed) == &quot;yes&quot;)
    {
    #
    # Close dialog box
    #
    tkdestroy(choice)
    }
  }
#
# Create submit button
#
submit.button &lt;- tkbutton(choice, text = &quot;Submit&quot;, command = submit)
#
# Create layout of input boxes and control buttons
# 
tkgrid(tklabel(choice, text = &quot;Specify number of bootstrap replicates&quot;), columnspan = 2, pady = 5)
tkgrid(tklabel(choice, text = &quot;Number of replicates:&quot;), replicates.entry, pady = 5, padx = 5)
tkgrid(submit.button, reset.button, pady = 5, padx = 5)

tkwait.window(choice)


 


################################################################################
#
# Perform bootstrap
#
################################################################################
#
# Subset steerIndicators to those that can be bootstrapped
#
steerBoot &lt;- subset(steerIndicators, varStatistic == &quot;oneMean&quot;)
#
# Extract number of replicates specified by user
#
REPLICATES &lt;- as.numeric(tclvalue(replicates))


################################################################################
#
# All results in a single output - Bootstrap
#
################################################################################
#
# Create empty container object for bootstrap results
#
summaryTable &lt;- NULL
#
# Cycle through each enumeration zones
#
for(i in unique(indicatorsDF$zone))
  {
  #
  # Subset population data to slum areas
  #
  slum.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 1, ]
  #
  # Subset population data to other areas
  #
  other.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 2, ]
  #
  # Subset survey data to slum areas
  #
  slum.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 1, ]
  #
  # Subset survey data to other areas
  #
  other.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 2, ]  
  #
  # Get population data for all areas in current zone
  #
  all.pop &lt;- popDF[popDF$zone == i, ]
  #
  # Get survey data for all areas in current zone
  #
  all.data &lt;- indicatorsDF[indicatorsDF$zone == i, ]
  #
  # Cycle through indicator codes
  #
  for(j in steerBoot$varList)
    {
    #
    # Select indicator and statistic pair
    #
    INDICATOR &lt;- j
    STATISTIC &lt;- steerBoot$varStatistic[steerBoot$varList == j]
    #
    # Report progress
    #
    cat(&quot;\n\n&quot;, INDICATOR, &quot; : Survey Area &quot;, i, &quot;\n\n&quot;, sep = &quot;&quot;)
    #
    # Boostrap (BBW) for current indicator and statistic pair - slum
    #
    boot.slum &lt;- bootBW(x = slum.data, 
                        w = slum.pop, 
                        statistic = eval(parse(text = STATISTIC)), 
			         params = INDICATOR, 
			         outputColumns = INDICATOR, 
			         replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - other
    #
    boot.other &lt;- bootBW(x = other.data, 
			          w = other.pop, 
			          statistic = eval(parse(text = STATISTIC)), 
			          params = INDICATOR, 
			          outputColumns = INDICATOR, 
			          replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - total
    #
    boot.total &lt;- bootBW(x = all.data, 
			          w = all.pop, 
			          statistic = eval(parse(text = STATISTIC)), 
			          params = INDICATOR, 
			          outputColumns = INDICATOR, 
			          replicates = REPLICATES)     
    #
    # Concatenate various boot vectors into data.frame
    #
    boot.all &lt;- data.frame(boot.slum, boot.other, boot.total)
    names(boot.all) &lt;- c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Total&quot;)
    #
    # Create a row of results and insert quantiles of boot results
    #
    rowResult &lt;- c(unique(country), unique(ccode), unique(month), unique(year), 
                   steerBoot$varNames[steerBoot$varList == j], j, paste(&quot;Survey Area &quot;, i, sep = &quot;&quot;))
    for(k in names(boot.all))
      {
	 rowResult &lt;- c(rowResult, quantile(boot.all[[k]], probs = c(0.5, 0.025, 0.975), na.rm = TRUE))
      }
    #
    # Record results
    #
    summaryTable &lt;- rbind(summaryTable, rowResult)
    }
  #
  # Tidy results (row names, column types, column names, and order of rows)
  #
  summaryTable &lt;- data.frame(summaryTable, row.names = 1:nrow(summaryTable))
  #
  # Convert estimate results into numeric
  #
  for(col in 8:ncol(summaryTable))
    {
    summaryTable[, col] &lt;- as.numeric(summaryTable[, col])
    }
  }
#
# Rename summaryTable
#
names(summaryTable) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;, &quot;Month&quot;, &quot;Year&quot;,
	                    &quot;Indicator&quot;, &quot;Indicator Code&quot;, &quot;Survey Area&quot;, 
           	          &quot;Low Income Area Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Other Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Total Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;)
#
# Round-off estimates to the nearest 4 decimal places
#
summaryTable[ , 8:ncol(summaryTable)] &lt;- round(summaryTable[  , 8:ncol(summaryTable)], 4)
#
# Keep the rounding off of results for table output
#
options(scipen = 10)
#
# Save summaryTable as CSV file
#
write.csv(x = summaryTable, 
  	     file = paste(&quot;outputTables/surveyResultsBoot&quot;, 
  	                  unique(ccode), unique(month), unique(year),
  	                  &quot;.csv&quot;, sep = &quot;&quot;),
	     row.names = FALSE)
#
# Reset scipen back to 0
#
options(scipen = 0)


################################################################################
#
# Perform bootstrap
#
################################################################################
#
# Subset steerIndicators to those that can be bootstrapped
#
steerBoot &lt;- subset(steerIndicators, varStatistic != &quot;oneMean&quot;)

################################################################################
#
# All results in a single output - Bootstrap
#
################################################################################
#
# Determine if steerBoot is empty and decide whether to continue with next step
#
if(nrow(steerBoot) &gt; 0)
  {
  #
  # Create empty container object for bootstrap results  
  #
  summaryTableX &lt;- NULL
  #  
# Cycle through each enumeration zones
#
for(i in unique(indicatorsDF$zone))
  {
  #
  # Subset population data to slum areas
  #
  slum.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 1, ]
  #
  # Subset population data to other areas
  #
  other.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 2, ]
  #
  # Subset survey data to slum areas
  #
  slum.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 1, ]
  #
  # Subset survey data to other areas
  #
  other.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 2, ]  
  #
  # Get population data for all areas in current zone
  #
  all.pop &lt;- popDF[popDF$zone == i, ]
  #
  # Get survey data for all areas in current zone
  #
  all.data &lt;- indicatorsDF[indicatorsDF$zone == i, ]
  #
  # Cycle through indicator codes
  #
  for(j in steerBoot$varList)
    {
    #
    # Concatenate various boot vectors into data.frame
    #
    boot.all &lt;- data.frame(matrix(nrow = 1, ncol = 3))
    names(boot.all) &lt;- c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Total&quot;)
    #
    # Create a row of results and insert quantiles of boot results
    #
    rowResult &lt;- c(unique(country), unique(ccode), unique(month), unique(year),
                   steerBoot$varNames[steerBoot$varList == j], j, paste(&quot;Survey Area &quot;, i, sep = &quot;&quot;))
    for(k in names(boot.all))
      {
	 rowResult &lt;- c(rowResult, rep(NA, 3))
	 }
    #
    # Record results
    #
    summaryTableX &lt;- rbind(summaryTableX, rowResult)
    }
  #
  # Tidy results (row names, column types, column names, and order of rows)
  #
  if(!is.null(summaryTableX))
    {
    summaryTableX &lt;- data.frame(summaryTableX, row.names = 1:nrow(summaryTableX))
    #
    # Convert estimate results into numeric
    #
    for(col in 8:ncol(summaryTableX))
      {
      summaryTableX[, col] &lt;- as.numeric(summaryTableX[, col])
      }
    }
  }
 
  if(!is.null(summaryTableX))
    {
    #
    # Rename summaryTable
    #
    names(summaryTableX) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;, &quot;Month&quot;, &quot;Year&quot;,
	                         &quot;Indicator&quot;, &quot;Indicator Code&quot;, &quot;Survey Area&quot;, 
	                         &quot;Low Income Area Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                         &quot;Other Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                         &quot;Total Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;)
    #
    # Round-off estimates to the nearest 4 decimal places
    #
    summaryTableX[ , 8:ncol(summaryTableX)] &lt;- round(summaryTableX[  , 8:ncol(summaryTableX)], 4)
    }

#
# Combine results data.frame
#
summaryTable &lt;- data.frame(rbind(summaryTable, summaryTableX))
#
# Keep the rounding off of results for table output
#
options(scipen = 10)
#
# Save summaryTable as CSV file
#
write.csv(x = summaryTable, 
	     file = paste(&quot;outputTables/surveyResultsBoot&quot;, 
	                  unique(ccode), unique(month), unique(year),
	                  &quot;.csv&quot;, sep = &quot;&quot;),
	     row.names = FALSE)
#
# Reset scipen back to 0
#
options(scipen = 0)
}



################################################################################
#
# Perform bootstrap
#
################################################################################
#
# Subset steerIndicators to those that can be bootstrapped
#
steerBoot &lt;- subset(steerIndicators, varStatistic == &quot;oneMean&quot;)
#
# Extract number of replicates specified by user
#
REPLICATES &lt;- as.numeric(tclvalue(replicates))


################################################################################
#
# All results in a single output - Bootstrap
#
################################################################################
#
# Create empty container object for bootstrap results
#
summaryTable &lt;- NULL
#
# Cycle through each wealth quintile
#
for(i in unique(indicatorsDF$pQuintile))
  {
  #
  # Subset survey data to slum areas
  #
  slum.data &lt;- indicatorsDF[indicatorsDF$pQuintile == i &amp; indicatorsDF$type == 1, ]
  #
  # Subset survey data to other areas
  #
  other.data &lt;- indicatorsDF[indicatorsDF$pQuintile == i &amp; indicatorsDF$type == 2, ]  
  #
  # Get survey data for all areas in current zone
  #
  all.data &lt;- indicatorsDF[indicatorsDF$pQuintile == i, ]
  #
  # Subset population data to slum areas
  #
  slum.pop &lt;- popDF[popDF$psu %in% unique(slum.data$psu) &amp; popDF$type == 1, ]
  #
  # Subset population data to other areas
  #
  other.pop &lt;- popDF[popDF$psu %in% unique(other.data$psu) &amp; popDF$type == 2, ]
  #
  # Get population data for all areas in current zone
  #
  all.pop &lt;- popDF[popDF$psu %in% unique(all.data$psu), ]
  #
  # Cycle through indicator codes
  #
  for(j in steerBoot$varList)
    {
    #
    # Select indicator and statistic pair
    #
    INDICATOR &lt;- j
    STATISTIC &lt;- steerBoot$varStatistic[steerBoot$varList == j]
    #
    # Report progress
    #
    cat(&quot;\n\n&quot;, INDICATOR, &quot; : Wealth Quintile &quot;, i, &quot;\n\n&quot;, sep = &quot;&quot;)
    #
    # Boostrap (BBW) for current indicator and statistic pair - slum
    #
    boot.slum &lt;- bootBW(x = slum.data, 
                        w = slum.pop, 
                        statistic = eval(parse(text = STATISTIC)), 
			         params = INDICATOR, 
			         outputColumns = INDICATOR, 
			         replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - other
    #
    boot.other &lt;- bootBW(x = other.data, 
			          w = other.pop, 
			          statistic = eval(parse(text = STATISTIC)), 
			          params = INDICATOR, 
			          outputColumns = INDICATOR, 
			          replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - total
    #
    boot.total &lt;- bootBW(x = all.data, 
			          w = all.pop, 
			          statistic = eval(parse(text = STATISTIC)), 
			          params = INDICATOR, 
			          outputColumns = INDICATOR, 
			          replicates = REPLICATES)     
    #
    # Concatenate various boot vectors into data.frame
    #
    boot.all &lt;- data.frame(boot.slum, boot.other, boot.total)
    names(boot.all) &lt;- c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Total&quot;)
    #
    # Create a row of results and insert quantiles of boot results
    #
    rowResult &lt;- c(unique(country), unique(ccode), unique(month), unique(year),
                   steerBoot$varNames[steerBoot$varList == j], j, paste(&quot;Wealth Quintile &quot;, i, sep = &quot;&quot;))
    for(k in names(boot.all))
      {
	 rowResult &lt;- c(rowResult, quantile(boot.all[[k]], probs = c(0.5, 0.025, 0.975), na.rm = TRUE))
      }
    #
    # Record results
    #
    summaryTable &lt;- rbind(summaryTable, rowResult)
    }
  #
  # Tidy results (row names, column types, column names, and order of rows)
  #
  summaryTable &lt;- data.frame(summaryTable, row.names = 1:nrow(summaryTable))
  #
  # Convert estimate results into numeric
  #
  for(col in 8:ncol(summaryTable))
    {
    summaryTable[, col] &lt;- as.numeric(summaryTable[, col])
    }
  }
#
# Rename summaryTable
#
names(summaryTable) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;, &quot;Month&quot;, &quot;Year&quot;,
	                    &quot;Indicator&quot;, &quot;Indicator Code&quot;, &quot;Wealth Quintile&quot;, 
           	          &quot;Low Income Area Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Other Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Total Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;)
#
# Round-off estimates to the nearest 4 decimal places
#
summaryTable[ , 8:ncol(summaryTable)] &lt;- round(summaryTable[  , 8:ncol(summaryTable)], 4)
#
# Keep the rounding off of results for table output
#
options(scipen = 10)
#
# Save summaryTable as CSV file
#
write.csv(x = summaryTable, 
  	     file = paste(&quot;outputTables/surveyResultsBootWealth&quot;, 
  	                  unique(ccode), unique(month), unique(year),
  	                  &quot;.csv&quot;, sep = &quot;&quot;),
	     row.names = FALSE)
#
# Reset scipen back to 0
#
options(scipen = 0)


################################################################################
#
# Perform bootstrap
#
################################################################################
#
# Subset steerIndicators to those that can be bootstrapped
#
steerBoot &lt;- subset(steerIndicators, varStatistic != &quot;oneMean&quot;)

################################################################################
#
# All results in a single output - Bootstrap
#
################################################################################


#
# Determine if steerBoot is empty and decide whether to continue with next step
#
if(nrow(steerBoot) &gt; 0)
  {	
  #
  # Create empty container object for bootstrap results
  #
  summaryTableX &lt;- NULL
  #
  # Cycle through each enumeration zones
  #
  for(i in unique(indicatorsDF$zone))
    {
    #
    # Subset population data to slum areas
    #
    slum.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 1, ]
    #
    # Subset population data to other areas
    #
    other.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 2, ]
    #
    # Subset survey data to slum areas
    #
    slum.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 1, ]
    #
    # Subset survey data to other areas
    #
    other.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 2, ]  
    #
    # Get population data for all areas in current zone
    #
    all.pop &lt;- popDF[popDF$zone == i, ]
    #
    # Get survey data for all areas in current zone
    #
    all.data &lt;- indicatorsDF[indicatorsDF$zone == i, ]
    #
    # Cycle through indicator codes
    #
    for(j in steerBoot$varList)
      {
      #
      # Concatenate various boot vectors into data.frame
      #
      boot.all &lt;- data.frame(matrix(nrow = 1, ncol = 3))
      names(boot.all) &lt;- c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Total&quot;)
      #
      # Create a row of results and insert quantiles of boot results
      #
      rowResult &lt;- c(unique(country), unique(ccode), unique(month), unique(year),
                     steerBoot$varNames[steerBoot$varList == j], j, paste(&quot;Survey Area &quot;, i, sep = &quot;&quot;))
      for(k in names(boot.all))
        {
	   rowResult &lt;- c(rowResult, rep(NA, 3))
	   }
      #
      # Record results
      #
      summaryTableX &lt;- rbind(summaryTableX, rowResult)
      }
    #
    # Tidy results (row names, column types, column names, and order of rows)
    #
    summaryTableX &lt;- data.frame(summaryTableX, row.names = 1:nrow(summaryTableX))
    #
    # Convert estimate results into numeric
    #
    for(col in 8:ncol(summaryTableX))
      {
      summaryTableX[, col] &lt;- as.numeric(summaryTableX[, col])
      }
    }
  #
  # Rename summaryTable 
  #
  names(summaryTableX) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;, &quot;Month&quot;, &quot;Year&quot;,
	                       &quot;Indicator&quot;, &quot;Indicator Code&quot;, &quot;Wealth Quintile&quot;, 
	                       &quot;Low Income Area Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                       &quot;Other Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                       &quot;Total Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;)
  #
  # Round-off estimates to the nearest 4 decimal places  
  #
  summaryTableX[ , 8:ncol(summaryTableX)] &lt;- round(summaryTableX[  , 8:ncol(summaryTableX)], 4)
  #
  # Combine results data.frame
  #
  summaryTable &lt;- data.frame(rbind(summaryTable, summaryTableX))
  #
  # Keep the rounding off of results for table output
  #
  options(scipen = 10)
  #
  # Save summaryTable as CSV file
  #
  write.csv(x = summaryTable, 
	       file = paste(&quot;outputTables/surveyResultsBootWealth&quot;, 
	                    unique(ccode), unique(month), unique(year),
	                    &quot;.csv&quot;, sep = &quot;&quot;),
	       row.names = FALSE)
  #
  # Reset scipen back to 0
  #
  options(scipen = 0)
  }


################################################################################
#
# Perform bootstrap
#
################################################################################
#
# Subset steerIndicators to those that can be bootstrapped
#
steerBoot &lt;- subset(steerIndicators, varStatistic == &quot;oneMean&quot;)
#
# Extract number of replicates specified by user
#
REPLICATES &lt;- as.numeric(tclvalue(replicates))


################################################################################
#
# All results in a single output - Bootstrap
#
################################################################################
#
# Create empty container object for bootstrap results
#
summaryTable &lt;- NULL
#
# Subset population data to slum areas
#
slum.pop &lt;- popDF[popDF$type == 1, ]
#
# Subset population data to other areas
#
other.pop &lt;- popDF[popDF$type == 2, ]
#
# Subset survey data to slum areas
#
slum.data &lt;- indicatorsDF[indicatorsDF$type == 1, ]
#
# Subset survey data to other areas
#
other.data &lt;- indicatorsDF[indicatorsDF$type == 2, ]  
#
# Get population data for all areas in current zone
#
all.pop &lt;- popDF
#
# Get survey data for all areas in current zone
#
all.data &lt;- indicatorsDF
#
# Cycle through indicator codes
#
for(i in steerBoot$varList)
  {
  #
  # Select indicator and statistic pair
  #
  INDICATOR &lt;- i
  STATISTIC &lt;- steerBoot$varStatistic[steerBoot$varList == i]
  #
  # Report progress
  #
  cat(&quot;\n\n&quot;, INDICATOR, &quot;\n\n&quot;, sep = &quot;&quot;)
  #
  # Boostrap (BBW) for current indicator and statistic pair - slum
  #
  boot.slum &lt;- bootBW(x = slum.data, 
                      w = slum.pop, 
                      statistic = eval(parse(text = STATISTIC)), 
			       params = INDICATOR, 
			       outputColumns = INDICATOR, 
			       replicates = REPLICATES)
  #
  # Boostrap (BBW) for current indicator and statistic pair - other
  #
  boot.other &lt;- bootBW(x = other.data, 
			        w = other.pop, 
			        statistic = eval(parse(text = STATISTIC)), 
			        params = INDICATOR, 
			        outputColumns = INDICATOR, 
			        replicates = REPLICATES)
  #
  # Boostrap (BBW) for current indicator and statistic pair - total
  #
  boot.total &lt;- bootBW(x = all.data, 
			        w = all.pop, 
			        statistic = eval(parse(text = STATISTIC)), 
			        params = INDICATOR, 
			        outputColumns = INDICATOR, 
			        replicates = REPLICATES)     
  #
  # Concatenate various boot vectors into data.frame
  #
  boot.all &lt;- data.frame(boot.slum, boot.other, boot.total)
  names(boot.all) &lt;- c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Total&quot;)
  #
  # Create a row of results and insert quantiles of boot results
  #
  rowResult &lt;- c(unique(country), unique(ccode), unique(month), unique(year),
                 steerBoot$varNames[steerBoot$varList == i], i, &quot;Overall&quot;)
  for(j in names(boot.all))
    {
    rowResult &lt;- c(rowResult, quantile(boot.all[[j]], probs = c(0.5, 0.025, 0.975), na.rm = TRUE))
    }
  #
  # Record results
  #
  summaryTable &lt;- rbind(summaryTable, rowResult)
  }
#
# Tidy results (row names, column types, column names, and order of rows)
#
summaryTable &lt;- data.frame(summaryTable, row.names = 1:nrow(summaryTable))
#
# Convert estimate results into numeric
#
for(col in 8:ncol(summaryTable))
  {
  summaryTable[, col] &lt;- as.numeric(summaryTable[, col])
  }
#
# Rename summaryTable
#
names(summaryTable) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;, &quot;Month&quot;, &quot;Year&quot;,
	                    &quot;Indicator&quot;, &quot;Indicator Code&quot;, &quot;Survey Area&quot;,
           	          &quot;Low Income Area Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Other Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Total Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;)
#
# Round-off estimates to the nearest 4 decimal places
#
summaryTable[ , 8:ncol(summaryTable)] &lt;- round(summaryTable[  , 8:ncol(summaryTable)], 4)
#
# Keep the rounding off of results for table output
#
options(scipen = 10)
#
# Save summaryTable as CSV file
#
write.csv(x = summaryTable, 
  	     file = paste(&quot;outputTables/surveyResultsBootOverall&quot;, 
  	                  unique(ccode), unique(month), unique(year),
  	                  &quot;.csv&quot;, sep = &quot;&quot;),
	     row.names = FALSE)
#
# Reset scipen back to 0
#
options(scipen = 0)

</command>
			<property title="Estimate" shape="MODEL"/>
			<option type="com.ef_prime.rflow.node.base.SubflowNodeModel">
				<subflow>
					<graph version="0.8" width="702" height="193" locationtype="a" offsetx="340" offsety="41">
						<node id="36" date="1510899093931" uid="ef5b3200934e4c74" x="30" y="150">
							<command>
################################################################################
#
# Perform bootstrap
#
################################################################################
#
# Subset steerIndicators to those that can be bootstrapped
#
steerBoot &lt;- subset(steerIndicators, varStatistic == &quot;oneMean&quot;)
#
# Extract number of replicates specified by user
#
REPLICATES &lt;- as.numeric(tclvalue(replicates))


################################################################################
#
# All results in a single output - Bootstrap
#
################################################################################
#
# Create empty container object for bootstrap results
#
summaryTable &lt;- NULL
#
# Cycle through each wealth quintile
#
for(i in unique(indicatorsDF$pQuintile))
  {
  #
  # Subset survey data to slum areas
  #
  slum.data &lt;- indicatorsDF[indicatorsDF$pQuintile == i &amp; indicatorsDF$type == 1, ]
  #
  # Subset survey data to other areas
  #
  other.data &lt;- indicatorsDF[indicatorsDF$pQuintile == i &amp; indicatorsDF$type == 2, ]  
  #
  # Get survey data for all areas in current zone
  #
  all.data &lt;- indicatorsDF[indicatorsDF$pQuintile == i, ]
  #
  # Subset population data to slum areas
  #
  slum.pop &lt;- popDF[popDF$psu %in% unique(slum.data$psu) &amp; popDF$type == 1, ]
  #
  # Subset population data to other areas
  #
  other.pop &lt;- popDF[popDF$psu %in% unique(other.data$psu) &amp; popDF$type == 2, ]
  #
  # Get population data for all areas in current zone
  #
  all.pop &lt;- popDF[popDF$psu %in% unique(all.data$psu), ]
  #
  # Cycle through indicator codes
  #
  for(j in steerBoot$varList)
    {
    #
    # Select indicator and statistic pair
    #
    INDICATOR &lt;- j
    STATISTIC &lt;- steerBoot$varStatistic[steerBoot$varList == j]
    #
    # Report progress
    #
    cat(&quot;\n\n&quot;, INDICATOR, &quot; : Wealth Quintile &quot;, i, &quot;\n\n&quot;, sep = &quot;&quot;)
    #
    # Boostrap (BBW) for current indicator and statistic pair - slum
    #
    boot.slum &lt;- bootBW(x = slum.data, 
                        w = slum.pop, 
                        statistic = eval(parse(text = STATISTIC)), 
			         params = INDICATOR, 
			         outputColumns = INDICATOR, 
			         replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - other
    #
    boot.other &lt;- bootBW(x = other.data, 
			          w = other.pop, 
			          statistic = eval(parse(text = STATISTIC)), 
			          params = INDICATOR, 
			          outputColumns = INDICATOR, 
			          replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - total
    #
    boot.total &lt;- bootBW(x = all.data, 
			          w = all.pop, 
			          statistic = eval(parse(text = STATISTIC)), 
			          params = INDICATOR, 
			          outputColumns = INDICATOR, 
			          replicates = REPLICATES)     
    #
    # Concatenate various boot vectors into data.frame
    #
    boot.all &lt;- data.frame(boot.slum, boot.other, boot.total)
    names(boot.all) &lt;- c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Total&quot;)
    #
    # Create a row of results and insert quantiles of boot results
    #
    rowResult &lt;- c(unique(country), unique(ccode), unique(month), unique(year),
                   steerBoot$varNames[steerBoot$varList == j], j, paste(&quot;Wealth Quintile &quot;, i, sep = &quot;&quot;))
    for(k in names(boot.all))
      {
	 rowResult &lt;- c(rowResult, quantile(boot.all[[k]], probs = c(0.5, 0.025, 0.975), na.rm = TRUE))
      }
    #
    # Record results
    #
    summaryTable &lt;- rbind(summaryTable, rowResult)
    }
  #
  # Tidy results (row names, column types, column names, and order of rows)
  #
  summaryTable &lt;- data.frame(summaryTable, row.names = 1:nrow(summaryTable))
  #
  # Convert estimate results into numeric
  #
  for(col in 8:ncol(summaryTable))
    {
    summaryTable[, col] &lt;- as.numeric(summaryTable[, col])
    }
  }
#
# Rename summaryTable
#
names(summaryTable) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;, &quot;Month&quot;, &quot;Year&quot;,
	                    &quot;Indicator&quot;, &quot;Indicator Code&quot;, &quot;Wealth Quintile&quot;, 
           	          &quot;Low Income Area Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Other Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Total Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;)
#
# Round-off estimates to the nearest 4 decimal places
#
summaryTable[ , 8:ncol(summaryTable)] &lt;- round(summaryTable[  , 8:ncol(summaryTable)], 4)
#
# Keep the rounding off of results for table output
#
options(scipen = 10)
#
# Save summaryTable as CSV file
#
write.csv(x = summaryTable, 
  	     file = paste(&quot;outputTables/surveyResultsBootWealth&quot;, 
  	                  unique(ccode), unique(month), unique(year),
  	                  &quot;.csv&quot;, sep = &quot;&quot;),
	     row.names = FALSE)
#
# Reset scipen back to 0
#
options(scipen = 0)


################################################################################
#
# Perform bootstrap
#
################################################################################
#
# Subset steerIndicators to those that can be bootstrapped
#
steerBoot &lt;- subset(steerIndicators, varStatistic != &quot;oneMean&quot;)

################################################################################
#
# All results in a single output - Bootstrap
#
################################################################################


#
# Determine if steerBoot is empty and decide whether to continue with next step
#
if(nrow(steerBoot) &gt; 0)
  {	
  #
  # Create empty container object for bootstrap results
  #
  summaryTableX &lt;- NULL
  #
  # Cycle through each enumeration zones
  #
  for(i in unique(indicatorsDF$zone))
    {
    #
    # Subset population data to slum areas
    #
    slum.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 1, ]
    #
    # Subset population data to other areas
    #
    other.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 2, ]
    #
    # Subset survey data to slum areas
    #
    slum.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 1, ]
    #
    # Subset survey data to other areas
    #
    other.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 2, ]  
    #
    # Get population data for all areas in current zone
    #
    all.pop &lt;- popDF[popDF$zone == i, ]
    #
    # Get survey data for all areas in current zone
    #
    all.data &lt;- indicatorsDF[indicatorsDF$zone == i, ]
    #
    # Cycle through indicator codes
    #
    for(j in steerBoot$varList)
      {
      #
      # Concatenate various boot vectors into data.frame
      #
      boot.all &lt;- data.frame(matrix(nrow = 1, ncol = 3))
      names(boot.all) &lt;- c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Total&quot;)
      #
      # Create a row of results and insert quantiles of boot results
      #
      rowResult &lt;- c(unique(country), unique(ccode), unique(month), unique(year),
                     steerBoot$varNames[steerBoot$varList == j], j, paste(&quot;Survey Area &quot;, i, sep = &quot;&quot;))
      for(k in names(boot.all))
        {
	   rowResult &lt;- c(rowResult, rep(NA, 3))
	   }
      #
      # Record results
      #
      summaryTableX &lt;- rbind(summaryTableX, rowResult)
      }
    #
    # Tidy results (row names, column types, column names, and order of rows)
    #
    summaryTableX &lt;- data.frame(summaryTableX, row.names = 1:nrow(summaryTableX))
    #
    # Convert estimate results into numeric
    #
    for(col in 8:ncol(summaryTableX))
      {
      summaryTableX[, col] &lt;- as.numeric(summaryTableX[, col])
      }
    }
  #
  # Rename summaryTable 
  #
  names(summaryTableX) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;, &quot;Month&quot;, &quot;Year&quot;,
	                       &quot;Indicator&quot;, &quot;Indicator Code&quot;, &quot;Wealth Quintile&quot;, 
	                       &quot;Low Income Area Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                       &quot;Other Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                       &quot;Total Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;)
  #
  # Round-off estimates to the nearest 4 decimal places  
  #
  summaryTableX[ , 8:ncol(summaryTableX)] &lt;- round(summaryTableX[  , 8:ncol(summaryTableX)], 4)
  #
  # Combine results data.frame
  #
  summaryTable &lt;- data.frame(rbind(summaryTable, summaryTableX))
  #
  # Keep the rounding off of results for table output
  #
  options(scipen = 10)
  #
  # Save summaryTable as CSV file
  #
  write.csv(x = summaryTable, 
	       file = paste(&quot;outputTables/surveyResultsBootWealth&quot;, 
	                    unique(ccode), unique(month), unique(year),
	                    &quot;.csv&quot;, sep = &quot;&quot;),
	       row.names = FALSE)
  #
  # Reset scipen back to 0
  #
  options(scipen = 0)
  }
</command>
							<property title="Estimate by wealth" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="37" date="1510899093931" uid="3945548d08f023b1" x="-50" y="0">
							<command></command>
							<property/>
							<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
								<entry key="io">in</entry>
							</option>
						</node>
						<node id="38" date="1510899093931" uid="a17228f97bc9a5fd" x="30" y="70">
							<command>
################################################################################
#
# Perform bootstrap
#
################################################################################
#
# Subset steerIndicators to those that can be bootstrapped
#
steerBoot &lt;- subset(steerIndicators, varStatistic == &quot;oneMean&quot;)
#
# Extract number of replicates specified by user
#
REPLICATES &lt;- as.numeric(tclvalue(replicates))


################################################################################
#
# All results in a single output - Bootstrap
#
################################################################################
#
# Create empty container object for bootstrap results
#
summaryTable &lt;- NULL
#
# Cycle through each enumeration zones
#
for(i in unique(indicatorsDF$zone))
  {
  #
  # Subset population data to slum areas
  #
  slum.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 1, ]
  #
  # Subset population data to other areas
  #
  other.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 2, ]
  #
  # Subset survey data to slum areas
  #
  slum.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 1, ]
  #
  # Subset survey data to other areas
  #
  other.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 2, ]  
  #
  # Get population data for all areas in current zone
  #
  all.pop &lt;- popDF[popDF$zone == i, ]
  #
  # Get survey data for all areas in current zone
  #
  all.data &lt;- indicatorsDF[indicatorsDF$zone == i, ]
  #
  # Cycle through indicator codes
  #
  for(j in steerBoot$varList)
    {
    #
    # Select indicator and statistic pair
    #
    INDICATOR &lt;- j
    STATISTIC &lt;- steerBoot$varStatistic[steerBoot$varList == j]
    #
    # Report progress
    #
    cat(&quot;\n\n&quot;, INDICATOR, &quot; : Survey Area &quot;, i, &quot;\n\n&quot;, sep = &quot;&quot;)
    #
    # Boostrap (BBW) for current indicator and statistic pair - slum
    #
    boot.slum &lt;- bootBW(x = slum.data, 
                        w = slum.pop, 
                        statistic = eval(parse(text = STATISTIC)), 
			         params = INDICATOR, 
			         outputColumns = INDICATOR, 
			         replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - other
    #
    boot.other &lt;- bootBW(x = other.data, 
			          w = other.pop, 
			          statistic = eval(parse(text = STATISTIC)), 
			          params = INDICATOR, 
			          outputColumns = INDICATOR, 
			          replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - total
    #
    boot.total &lt;- bootBW(x = all.data, 
			          w = all.pop, 
			          statistic = eval(parse(text = STATISTIC)), 
			          params = INDICATOR, 
			          outputColumns = INDICATOR, 
			          replicates = REPLICATES)     
    #
    # Concatenate various boot vectors into data.frame
    #
    boot.all &lt;- data.frame(boot.slum, boot.other, boot.total)
    names(boot.all) &lt;- c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Total&quot;)
    #
    # Create a row of results and insert quantiles of boot results
    #
    rowResult &lt;- c(unique(country), unique(ccode), unique(month), unique(year), 
                   steerBoot$varNames[steerBoot$varList == j], j, paste(&quot;Survey Area &quot;, i, sep = &quot;&quot;))
    for(k in names(boot.all))
      {
	 rowResult &lt;- c(rowResult, quantile(boot.all[[k]], probs = c(0.5, 0.025, 0.975), na.rm = TRUE))
      }
    #
    # Record results
    #
    summaryTable &lt;- rbind(summaryTable, rowResult)
    }
  #
  # Tidy results (row names, column types, column names, and order of rows)
  #
  summaryTable &lt;- data.frame(summaryTable, row.names = 1:nrow(summaryTable))
  #
  # Convert estimate results into numeric
  #
  for(col in 8:ncol(summaryTable))
    {
    summaryTable[, col] &lt;- as.numeric(summaryTable[, col])
    }
  }
#
# Rename summaryTable
#
names(summaryTable) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;, &quot;Month&quot;, &quot;Year&quot;,
	                    &quot;Indicator&quot;, &quot;Indicator Code&quot;, &quot;Survey Area&quot;, 
           	          &quot;Low Income Area Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Other Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Total Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;)
#
# Round-off estimates to the nearest 4 decimal places
#
summaryTable[ , 8:ncol(summaryTable)] &lt;- round(summaryTable[  , 8:ncol(summaryTable)], 4)
#
# Keep the rounding off of results for table output
#
options(scipen = 10)
#
# Save summaryTable as CSV file
#
write.csv(x = summaryTable, 
  	     file = paste(&quot;outputTables/surveyResultsBoot&quot;, 
  	                  unique(ccode), unique(month), unique(year),
  	                  &quot;.csv&quot;, sep = &quot;&quot;),
	     row.names = FALSE)
#
# Reset scipen back to 0
#
options(scipen = 0)


################################################################################
#
# Perform bootstrap
#
################################################################################
#
# Subset steerIndicators to those that can be bootstrapped
#
steerBoot &lt;- subset(steerIndicators, varStatistic != &quot;oneMean&quot;)

################################################################################
#
# All results in a single output - Bootstrap
#
################################################################################
#
# Determine if steerBoot is empty and decide whether to continue with next step
#
if(nrow(steerBoot) &gt; 0)
  {
  #
  # Create empty container object for bootstrap results  
  #
  summaryTableX &lt;- NULL
  #  
# Cycle through each enumeration zones
#
for(i in unique(indicatorsDF$zone))
  {
  #
  # Subset population data to slum areas
  #
  slum.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 1, ]
  #
  # Subset population data to other areas
  #
  other.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 2, ]
  #
  # Subset survey data to slum areas
  #
  slum.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 1, ]
  #
  # Subset survey data to other areas
  #
  other.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 2, ]  
  #
  # Get population data for all areas in current zone
  #
  all.pop &lt;- popDF[popDF$zone == i, ]
  #
  # Get survey data for all areas in current zone
  #
  all.data &lt;- indicatorsDF[indicatorsDF$zone == i, ]
  #
  # Cycle through indicator codes
  #
  for(j in steerBoot$varList)
    {
    #
    # Concatenate various boot vectors into data.frame
    #
    boot.all &lt;- data.frame(matrix(nrow = 1, ncol = 3))
    names(boot.all) &lt;- c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Total&quot;)
    #
    # Create a row of results and insert quantiles of boot results
    #
    rowResult &lt;- c(unique(country), unique(ccode), unique(month), unique(year),
                   steerBoot$varNames[steerBoot$varList == j], j, paste(&quot;Survey Area &quot;, i, sep = &quot;&quot;))
    for(k in names(boot.all))
      {
	 rowResult &lt;- c(rowResult, rep(NA, 3))
	 }
    #
    # Record results
    #
    summaryTableX &lt;- rbind(summaryTableX, rowResult)
    }
  #
  # Tidy results (row names, column types, column names, and order of rows)
  #
  if(!is.null(summaryTableX))
    {
    summaryTableX &lt;- data.frame(summaryTableX, row.names = 1:nrow(summaryTableX))
    #
    # Convert estimate results into numeric
    #
    for(col in 8:ncol(summaryTableX))
      {
      summaryTableX[, col] &lt;- as.numeric(summaryTableX[, col])
      }
    }
  }
 
  if(!is.null(summaryTableX))
    {
    #
    # Rename summaryTable
    #
    names(summaryTableX) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;, &quot;Month&quot;, &quot;Year&quot;,
	                         &quot;Indicator&quot;, &quot;Indicator Code&quot;, &quot;Survey Area&quot;, 
	                         &quot;Low Income Area Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                         &quot;Other Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                         &quot;Total Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;)
    #
    # Round-off estimates to the nearest 4 decimal places
    #
    summaryTableX[ , 8:ncol(summaryTableX)] &lt;- round(summaryTableX[  , 8:ncol(summaryTableX)], 4)
    }

#
# Combine results data.frame
#
summaryTable &lt;- data.frame(rbind(summaryTable, summaryTableX))
#
# Keep the rounding off of results for table output
#
options(scipen = 10)
#
# Save summaryTable as CSV file
#
write.csv(x = summaryTable, 
	     file = paste(&quot;outputTables/surveyResultsBoot&quot;, 
	                  unique(ccode), unique(month), unique(year),
	                  &quot;.csv&quot;, sep = &quot;&quot;),
	     row.names = FALSE)
#
# Reset scipen back to 0
#
options(scipen = 0)
}

</command>
							<property title="Estimate by area" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="39" date="1510899093931" uid="6058d1ec00fae35a" x="110" y="230">
							<command></command>
							<property/>
							<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
								<entry key="io">out</entry>
							</option>
						</node>
						<node id="40" date="1510899093931" uid="20d0541524fbfb4b" x="30" y="0">
							<command>
################################################################################
#
# Specify bootstrapping parameters
#
################################################################################
#
# Set default number of replicates
#
replicates &lt;- tclVar(&quot;399&quot;)
#
# Create dialog box
#
choice &lt;- tktoplevel()
#
# Add title to dialog box
#
tkwm.title(choice, &quot;Bootstrap replicates&quot;)
#
# Create input box
#
replicates.entry &lt;- tkentry(choice, textvariable = replicates)
#
# RESET function for RESET button
#
reset &lt;- function()
  {
  #
  # Reset user input back to default
  #
  tclvalue(replicates) &lt;- &quot;399&quot;
  }
#
# Create reset button
#
reset.button &lt;- tkbutton(choice, text = &quot;Reset&quot;, command = reset)
#
# SUBMIT function for SUBMIT button
#
submit &lt;- function() 
  {
  #
  # Extract user input
  #
  x &lt;- as.numeric(tclvalue(replicates))
  #
  # Prompt user with input specified and ask whether to proceed
  #
  proceed &lt;- tkmessageBox(title = &quot;Bootstrap replicates&quot;,
                          message = paste(&quot;You specified &quot;, x, &quot; replicates for bootstrapping. Do you wish to continue?&quot;, sep = &quot;&quot;),
                          icon = &quot;question&quot;,
                          type = &quot;yesno&quot;)
  #
  # Determine if user does not want to continue with specified values
  #
  if(tclvalue(proceed) == &quot;no&quot;)
    {
    #
    # Prompt user that no replicates specified
    #
    tkmessageBox(title = &quot;Bootstrap replicates&quot;,
                 message = &quot;No number of replicates specified. Specify number of replicates&quot;,
                 icon = &quot;warning&quot;,
                 type = &quot;ok&quot;)
    }
  #
  # Determine if user wishes to proceed with specified replicates
  #
  if(tclvalue(proceed) == &quot;yes&quot;)
    {
    #
    # Close dialog box
    #
    tkdestroy(choice)
    }
  }
#
# Create submit button
#
submit.button &lt;- tkbutton(choice, text = &quot;Submit&quot;, command = submit)
#
# Create layout of input boxes and control buttons
# 
tkgrid(tklabel(choice, text = &quot;Specify number of bootstrap replicates&quot;), columnspan = 2, pady = 5)
tkgrid(tklabel(choice, text = &quot;Number of replicates:&quot;), replicates.entry, pady = 5, padx = 5)
tkgrid(submit.button, reset.button, pady = 5, padx = 5)

tkwait.window(choice)


 </command>
							<property title="Specify boot parameters" shape="INPUT"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="41" date="1510899093932" uid="42b79a3424a5e678" x="30" y="230">
							<command>
################################################################################
#
# Perform bootstrap
#
################################################################################
#
# Subset steerIndicators to those that can be bootstrapped
#
steerBoot &lt;- subset(steerIndicators, varStatistic == &quot;oneMean&quot;)
#
# Extract number of replicates specified by user
#
REPLICATES &lt;- as.numeric(tclvalue(replicates))


################################################################################
#
# All results in a single output - Bootstrap
#
################################################################################
#
# Create empty container object for bootstrap results
#
summaryTable &lt;- NULL
#
# Subset population data to slum areas
#
slum.pop &lt;- popDF[popDF$type == 1, ]
#
# Subset population data to other areas
#
other.pop &lt;- popDF[popDF$type == 2, ]
#
# Subset survey data to slum areas
#
slum.data &lt;- indicatorsDF[indicatorsDF$type == 1, ]
#
# Subset survey data to other areas
#
other.data &lt;- indicatorsDF[indicatorsDF$type == 2, ]  
#
# Get population data for all areas in current zone
#
all.pop &lt;- popDF
#
# Get survey data for all areas in current zone
#
all.data &lt;- indicatorsDF
#
# Cycle through indicator codes
#
for(i in steerBoot$varList)
  {
  #
  # Select indicator and statistic pair
  #
  INDICATOR &lt;- i
  STATISTIC &lt;- steerBoot$varStatistic[steerBoot$varList == i]
  #
  # Report progress
  #
  cat(&quot;\n\n&quot;, INDICATOR, &quot;\n\n&quot;, sep = &quot;&quot;)
  #
  # Boostrap (BBW) for current indicator and statistic pair - slum
  #
  boot.slum &lt;- bootBW(x = slum.data, 
                      w = slum.pop, 
                      statistic = eval(parse(text = STATISTIC)), 
			       params = INDICATOR, 
			       outputColumns = INDICATOR, 
			       replicates = REPLICATES)
  #
  # Boostrap (BBW) for current indicator and statistic pair - other
  #
  boot.other &lt;- bootBW(x = other.data, 
			        w = other.pop, 
			        statistic = eval(parse(text = STATISTIC)), 
			        params = INDICATOR, 
			        outputColumns = INDICATOR, 
			        replicates = REPLICATES)
  #
  # Boostrap (BBW) for current indicator and statistic pair - total
  #
  boot.total &lt;- bootBW(x = all.data, 
			        w = all.pop, 
			        statistic = eval(parse(text = STATISTIC)), 
			        params = INDICATOR, 
			        outputColumns = INDICATOR, 
			        replicates = REPLICATES)     
  #
  # Concatenate various boot vectors into data.frame
  #
  boot.all &lt;- data.frame(boot.slum, boot.other, boot.total)
  names(boot.all) &lt;- c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Total&quot;)
  #
  # Create a row of results and insert quantiles of boot results
  #
  rowResult &lt;- c(unique(country), unique(ccode), unique(month), unique(year),
                 steerBoot$varNames[steerBoot$varList == i], i, &quot;Overall&quot;)
  for(j in names(boot.all))
    {
    rowResult &lt;- c(rowResult, quantile(boot.all[[j]], probs = c(0.5, 0.025, 0.975), na.rm = TRUE))
    }
  #
  # Record results
  #
  summaryTable &lt;- rbind(summaryTable, rowResult)
  }
#
# Tidy results (row names, column types, column names, and order of rows)
#
summaryTable &lt;- data.frame(summaryTable, row.names = 1:nrow(summaryTable))
#
# Convert estimate results into numeric
#
for(col in 8:ncol(summaryTable))
  {
  summaryTable[, col] &lt;- as.numeric(summaryTable[, col])
  }
#
# Rename summaryTable
#
names(summaryTable) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;, &quot;Month&quot;, &quot;Year&quot;,
	                    &quot;Indicator&quot;, &quot;Indicator Code&quot;, &quot;Survey Area&quot;,
           	          &quot;Low Income Area Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Other Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Total Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;)
#
# Round-off estimates to the nearest 4 decimal places
#
summaryTable[ , 8:ncol(summaryTable)] &lt;- round(summaryTable[  , 8:ncol(summaryTable)], 4)
#
# Keep the rounding off of results for table output
#
options(scipen = 10)
#
# Save summaryTable as CSV file
#
write.csv(x = summaryTable, 
  	     file = paste(&quot;outputTables/surveyResultsBootOverall&quot;, 
  	                  unique(ccode), unique(month), unique(year),
  	                  &quot;.csv&quot;, sep = &quot;&quot;),
	     row.names = FALSE)
#
# Reset scipen back to 0
#
options(scipen = 0)

</command>
							<property title="Estimate overall" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="42" date="1510899093931" uid="41f98b5fea8d16a0" x="140" y="0">
							<command>
################################################################################
#
# If Country is Bangladesh...
#
################################################################################

################################################################################
#
# Identify sampling points within North and South Corporations
#
################################################################################

if(unique(country) == &quot;Bangladesh&quot;)
  {
  #
  #
  #
  temp &lt;- indicatorsDF[ , c(&quot;psu&quot;, &quot;corporation&quot;)]
  #
  #
  #	
  popDF &lt;- merge(popDF, temp, by = &quot;psu&quot;)


################################################################################
#
# Perform bootstrap
#
################################################################################
#
# Subset steerIndicators to those that can be bootstrapped
#
steerBoot &lt;- subset(steerIndicators, varStatistic == &quot;oneMean&quot;)
#
# Extract number of replicates specified by user
#
REPLICATES &lt;- as.numeric(tclvalue(replicates))


################################################################################
#
# All results in a single output - Bootstrap
#
################################################################################
#
# Create empty container object for bootstrap results
#
summaryTable &lt;- NULL
#
# Cycle through each enumeration zones
#
for(i in unique(indicatorsDF$corporation))
  {
  #
  # Subset population data to slum areas
  #
  slum.pop &lt;- popDF[popDF$corporation == i &amp; popDF$type == 1, ]
  #
  # Subset population data to other areas
  #
  other.pop &lt;- popDF[popDF$corporation == i &amp; popDF$type == 2, ]
  #
  # Subset survey data to slum areas
  #
  slum.data &lt;- indicatorsDF[indicatorsDF$corporation == i &amp; indicatorsDF$type == 1, ]
  #
  # Subset survey data to other areas
  #
  other.data &lt;- indicatorsDF[indicatorsDF$corporation == i &amp; indicatorsDF$type == 2, ]  
  #
  # Get population data for all areas in current zone
  #
  all.pop &lt;- popDF[popDF$corporation == i, ]
  #
  # Get survey data for all areas in current zone
  #
  all.data &lt;- indicatorsDF[indicatorsDF$corporation == i, ]
  #
  # Cycle through indicator codes
  #
  for(j in steerBoot$varList)
    {
    #
    # Select indicator and statistic pair
    #
    INDICATOR &lt;- j
    STATISTIC &lt;- steerBoot$varStatistic[steerBoot$varList == j]
    #
    # Report progress
    #
    cat(&quot;\n\n&quot;, INDICATOR, &quot; : Survey Area &quot;, i, &quot;\n\n&quot;, sep = &quot;&quot;)
    #
    # Boostrap (BBW) for current indicator and statistic pair - slum
    #
    boot.slum &lt;- bootBW(x = slum.data, 
                        w = slum.pop, 
                        statistic = eval(parse(text = STATISTIC)), 
			         params = INDICATOR, 
			         outputColumns = INDICATOR, 
			         replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - other
    #
    boot.other &lt;- bootBW(x = other.data, 
			          w = other.pop, 
			          statistic = eval(parse(text = STATISTIC)), 
			          params = INDICATOR, 
			          outputColumns = INDICATOR, 
			          replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - total
    #
    boot.total &lt;- bootBW(x = all.data, 
			          w = all.pop, 
			          statistic = eval(parse(text = STATISTIC)), 
			          params = INDICATOR, 
			          outputColumns = INDICATOR, 
			          replicates = REPLICATES)     
    #
    # Concatenate various boot vectors into data.frame
    #
    boot.all &lt;- data.frame(boot.slum, boot.other, boot.total)
    names(boot.all) &lt;- c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Total&quot;)
    #
    # Create a row of results and insert quantiles of boot results
    #
    rowResult &lt;- c(unique(country), unique(ccode), unique(month), unique(year), 
                   steerBoot$varNames[steerBoot$varList == j], j, i)
    for(k in names(boot.all))
      {
	 rowResult &lt;- c(rowResult, quantile(boot.all[[k]], probs = c(0.5, 0.025, 0.975), na.rm = TRUE))
      }
    #
    # Record results
    #
    summaryTable &lt;- rbind(summaryTable, rowResult)
    }
  #
  # Tidy results (row names, column types, column names, and order of rows)
  #
  summaryTable &lt;- data.frame(summaryTable, row.names = 1:nrow(summaryTable))
  #
  # Convert estimate results into numeric
  #
  for(col in 8:ncol(summaryTable))
    {
    summaryTable[, col] &lt;- as.numeric(summaryTable[, col])
    }
  }
#
# Rename summaryTable
#
names(summaryTable) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;, &quot;Month&quot;, &quot;Year&quot;,
	                    &quot;Indicator&quot;, &quot;Indicator Code&quot;, &quot;Survey Area&quot;, 
           	          &quot;Low Income Area Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Other Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Total Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;)
#
# Round-off estimates to the nearest 4 decimal places
#
summaryTable[ , 8:ncol(summaryTable)] &lt;- round(summaryTable[  , 8:ncol(summaryTable)], 4)
#
# Keep the rounding off of results for table output
#
options(scipen = 10)
#
# Save summaryTable as CSV file
#
write.csv(x = summaryTable, 
  	     file = paste(&quot;outputTables/surveyResultsBootCorporation&quot;, 
  	                  unique(ccode), unique(month), unique(year),
  	                  &quot;.csv&quot;, sep = &quot;&quot;),
	     row.names = FALSE)
#
# Reset scipen back to 0
#
options(scipen = 0)


################################################################################
#
# Perform bootstrap
#
################################################################################
#
# Subset steerIndicators to those that can be bootstrapped
#
steerBoot &lt;- subset(steerIndicators, varStatistic != &quot;oneMean&quot;)

################################################################################
#
# All results in a single output - Bootstrap
#
################################################################################
#
# Determine if steerBoot is empty and decide whether to continue with next step
#
if(nrow(steerBoot) &gt; 0)
  {
  #
  # Create empty container object for bootstrap results  
  #
  summaryTableX &lt;- NULL
  #  
# Cycle through each enumeration zones
#
for(i in unique(indicatorsDF$corporation))
  {
  #
  # Subset population data to slum areas
  #
  slum.pop &lt;- popDF[popDF$corporation == i &amp; popDF$type == 1, ]
  #
  # Subset population data to other areas
  #
  other.pop &lt;- popDF[popDF$corporation == i &amp; popDF$type == 2, ]
  #
  # Subset survey data to slum areas
  #
  slum.data &lt;- indicatorsDF[indicatorsDF$corporation == i &amp; indicatorsDF$type == 1, ]
  #
  # Subset survey data to other areas
  #
  other.data &lt;- indicatorsDF[indicatorsDF$corporation == i &amp; indicatorsDF$type == 2, ]  
  #
  # Get population data for all areas in current zone
  #
  all.pop &lt;- popDF[popDF$corporation == i, ]
  #
  # Get survey data for all areas in current zone
  #
  all.data &lt;- indicatorsDF[indicatorsDF$corporation == i, ]
  #
  # Cycle through indicator codes
  #
  for(j in steerBoot$varList)
    {
    #
    # Concatenate various boot vectors into data.frame
    #
    boot.all &lt;- data.frame(matrix(nrow = 1, ncol = 3))
    names(boot.all) &lt;- c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Total&quot;)
    #
    # Create a row of results and insert quantiles of boot results
    #
    rowResult &lt;- c(unique(country), unique(ccode), unique(month), unique(year),
                   steerBoot$varNames[steerBoot$varList == j], j, i)
    for(k in names(boot.all))
      {
	 rowResult &lt;- c(rowResult, rep(NA, 3))
	 }
    #
    # Record results
    #
    summaryTableX &lt;- rbind(summaryTableX, rowResult)
    }
  #
  # Tidy results (row names, column types, column names, and order of rows)
  #
  if(!is.null(summaryTableX))
    {
    summaryTableX &lt;- data.frame(summaryTableX, row.names = 1:nrow(summaryTableX))
    #
    # Convert estimate results into numeric
    #
    for(col in 8:ncol(summaryTableX))
      {
      summaryTableX[, col] &lt;- as.numeric(summaryTableX[, col])
      }
    }
  }
 
  if(!is.null(summaryTableX))
    {
    #
    # Rename summaryTable
    #
    names(summaryTableX) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;, &quot;Month&quot;, &quot;Year&quot;,
	                         &quot;Indicator&quot;, &quot;Indicator Code&quot;, &quot;Survey Area&quot;, 
	                         &quot;Low Income Area Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                         &quot;Other Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                         &quot;Total Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;)
    #
    # Round-off estimates to the nearest 4 decimal places
    #
    summaryTableX[ , 8:ncol(summaryTableX)] &lt;- round(summaryTableX[  , 8:ncol(summaryTableX)], 4)
    }

#
# Combine results data.frame
#
summaryTable &lt;- data.frame(rbind(summaryTable, summaryTableX))
#
# Keep the rounding off of results for table output
#
options(scipen = 10)
#
# Save summaryTable as CSV file
#
write.csv(x = summaryTable, 
	     file = paste(&quot;outputTables/surveyResultsBootCorporation&quot;, 
	                  unique(ccode), unique(month), unique(year),
	                  &quot;.csv&quot;, sep = &quot;&quot;),
	     row.names = FALSE)
#
# Reset scipen back to 0
#
options(scipen = 0)
}
}

</command>
							<property title="Estimate by corporation" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<edge from="37" to="40"/>
						<edge from="38" to="36"/>
						<edge from="36" to="41"/>
						<edge from="40" to="38"/>
						<edge from="40" to="42"/>
						<edge from="41" to="39"/>
					</graph>
				</subflow>
			</option>
		</node>
		<node id="43" date="1510899093933" uid="e3078de51ae15bb7" x="-410" y="-60">
			<command></command>
			<property/>
			<option type="com.ef_prime.rflow.node.base.CommentNodeModel">
				<entry key="state">opened</entry>
				<entry key="comment">################################################################################
#                                                                              #
#                      URBAN WATER AND SANITATION SURVEY                       #
#                             ANALYSIS WORKFLOW                                #
#                               VERSION 1.8.1                                  #
#                              20 December 2017                                #
#                                                                              #
################################################################################ </entry>
			</option>
		</node>
		<node id="44" date="1510899093926" uid="9d13f84557886b44" x="-410" y="90">
			<command></command>
			<property/>
			<option type="com.ef_prime.rflow.node.base.CommentNodeModel">
				<entry key="state">opened</entry>
				<entry key="comment">####################
#                  #
#        A.        #
#      SETUP       #
#       AND        #
#  CONFIGURATION   #
#                  #
####################</entry>
			</option>
		</node>
		<node id="45" date="1510899093933" uid="27ad6bdbce39c686" x="-90" y="870">
			<command></command>
			<property title="Run STEP 4c" shape="STAR">
				<comment state="opened" x="60" y="-30">STEP 4c: Combine         
         classification
         and estimation
         results</comment>
			</property>
			<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
		</node>
		<node id="46" date="1510899093933" uid="df977d3b678abd6d" x="-90" y="320">
			<command>
################################################################################
#                                                                              #
# STEP 2a: Read datasets needed for analysis                                   #
#                                                                              #
#    This step asks the user to provide the required datasets for the          #
#    analysis. Two datasets are required:                                      #
#                                                                              #
#      a) Survey data                                                          #
#         This will be the dataset collected using the questionnaire created   # 
#         by WSUP for the urban water and sanitation surveys.                  #
#                                                                              #
#      b) Population data                                                      #
#         This is the corresponding population data set for each of the PSUs   #
#         in the survey data set. This is either collected during the survey   #
#         itself (e.g., roof counting) or through secondary sources of         #
#         population data that can be matched / paired to the survey data      #
#         PSUs. This dataset should have the following variables:              #
#                                                                              #
#           &apos;psu&apos; - this is the identifying data for the psu corresponding     #
#                   to the &apos;psu&apos; in the survey data.                           #
#                                                                              #
#           &apos;pop&apos; - this is the population values which are numeric.           #
#                                                                              #
#         It is important to enusre that the variable names are kept as        #
#         specified above.                                                     #
#                                                                              #
#    The user will be prompted and guided through the data selection process.  #
#    If no data file is selected or the wrong data file type is selected       #
#    (data file should be in comma-separated value or CSV format), user will   #
#    be prompted and warned accordingly.                                       #
#                                                                              #
#    Survey data and population data are needed to continue with the rest of   #
#    the analysis workflow.                                                    #
#                                                                              #
################################################################################
</command>
			<property title="Run STEP 2a" shape="STAR">
				<comment state="opened" x="60" y="-10">STEP 2a: Read survey data</comment>
			</property>
			<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
		</node>
		<node id="47" date="1510899093932" uid="c8bb2eee695ca7c1" x="-410" y="500">
			<command></command>
			<property/>
			<option type="com.ef_prime.rflow.node.base.CommentNodeModel">
				<entry key="state">opened</entry>
				<entry key="comment">####################
#                  #
#  C. INDICATORS   #
#                  #
####################</entry>
			</option>
		</node>
		<node id="48" date="1510899095246" uid="40e3127e35ec2ca1" x="-190" y="1000" disabled="true">
			<command></command>
			<property title="Recycle Bin" shape="MODELING"/>
			<option type="com.ef_prime.rflow.node.base.SubflowNodeModel">
				<subflow>
					<graph version="0.8" width="1443" height="513" locationtype="a" offsetx="-83" offsety="-156">
						<node id="49" date="1510899093939" uid="bed4e874fac2a3d5" x="430" y="460">
							<command>
################################################################################
#
# Read processed data
#
################################################################################

indicatorsDF &lt;- read.table(&quot;data/indicatorsDataBGD.csv&quot;, header = TRUE, sep = &quot;,&quot;)


################################################################################
#
# Create graphics for all indicators
#
################################################################################
#
# Read steering file for water indicators
#
#steerIndicators &lt;- read.csv(file = &quot;outputLists/steerIndicatorsV4.csv&quot;, 
#                            header = TRUE, sep = &quot;,&quot;)


steerHist &lt;- subset(steerIndicators, varFunction == &quot;histogram&quot;)


################################################################################
#
# Create histograms by survey area
#
################################################################################
#
# Re-code zone variable for ggplot
#
indicatorsDF$zone &lt;- with(indicatorsDF, paste(&quot;Survey Area&quot;, zone, sep = &quot; &quot;))
#
# Re-code type variable for ggplot
#
indicatorsDF$type &lt;- with(indicatorsDF, ifelse(type == 1, &quot;Slum&quot;, &quot;Other&quot;))
indicatorsDF$type &lt;- factor(indicatorsDF$type, levels = c(&quot;Slum&quot;, &quot;Other&quot;))


################################################################################
#
# Create WSUP theme
#
################################################################################

theme_wsup &lt;- theme_bw() + 
              theme(strip.text = element_text(size = 14), 
                    strip.background = element_rect(colour = &quot;black&quot;, size = 0.5),
                    panel.border = element_rect(colour = &quot;gray90&quot;, fill = NA),
                    legend.key = element_rect(colour = NA, fill = NA))

  
################################################################################
#
# Create plotting layers
#
################################################################################
#
# Create ggplot mapping base
#
basePlot &lt;- ggplot(data = indicatorsDF, mapping = aes(x = nMembers))
#
# Layers
#
histPlot &lt;- geom_histogram(binwidth = 1, color = wsupColour, fill = wsupColour, alpha = 0.6)
#
#
#
allPlot &lt;- basePlot + histPlot


################################################################################
#
# nMembers: number of household members by survey area and area type
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/nMembersByArea&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 18, height = 8, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap(zone ~ type, nrow = 3) + labs(x = &quot;No. of Household Members&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()
 

################################################################################
#
# nMembers: number of household members for all of Dhaka by survey area
#
################################################################################ 
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/nMembersByAreaTotal&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 12, height = 9, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap( ~ zone, ncol = 3) + labs(x = &quot;No. of Household Members&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# nMembers: number of household members for all of Dhaka by area type
#
################################################################################ 
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/nMembersByTypeTotal&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 8, height = 3, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap( ~ type) + labs(x = &quot;No. of Household Members&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# nMembers: number of household members total
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/nMembersOverall&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 9, height = 6, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + labs(x = &quot;No. of Household Members&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphis device
#
dev.off()



################################################################################
#
# Create plotting layers
#
################################################################################
#
# Create ggplot mapping base
#
basePlot &lt;- ggplot(data = indicatorsDF, mapping = aes(x = ppi))
#
# Layers
#
histPlot &lt;- geom_histogram(binwidth = 10, color = wsupColour, fill = wsupColour, alpha = 0.6)
#
#
#
allPlot &lt;- basePlot + histPlot


################################################################################
#
# ppi: ppi by survey area and area type
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/ppiByArea&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 18, height = 8, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap(zone ~ type, nrow = 3) + labs(x = &quot;PPI Score&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()
 

################################################################################
#
# ppi: ppi for all of Dhaka by survey area
#
################################################################################ 
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/ppiByAreaTotal&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 12, height = 9, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap( ~ zone, ncol = 3) + labs(x = &quot;PPI Score&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# ppi: ppi for all of Dhaka by area type
#
################################################################################ 
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/ppiByTypeTotal&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 8, height = 3, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap( ~ type) + labs(x = &quot;PPI Score&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# ppi: ppi total
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/ppiOverall&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 9, height = 6, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + labs(x = &quot;PPI Score&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphis device
#
dev.off()



################################################################################
#
# Create plotting layers - pQuintile
#
################################################################################
#
# Create ggplot mapping base
#
basePlot &lt;- ggplot(data = indicatorsDF, mapping = aes(x = pQuintile))
#
# Layers
#
histPlot &lt;- geom_histogram(binwidth = 1, color = wsupColour, fill = wsupColour, alpha = 0.6)
#
#
#
allPlot &lt;- basePlot + histPlot


################################################################################
#
# pQuintile: pQuintile by survey area and area type
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/pQuintileByArea&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 18, height = 8, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap(zone ~ type, nrow = 3) + labs(x = &quot;Wealth Quintiles based on PPI Score&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()
 

################################################################################
#
# pQuintile: wealth quintiles for all of Dhaka by survey area
#
################################################################################ 
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/pQuintileByAreaTotal&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 12, height = 9, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap( ~ zone, ncol = 3) + labs(x = &quot;Wealth Quintiles based on PPI Score&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# pQuintile: wealth quintiles for all of Dhaka by area type
#
################################################################################ 
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/pQuintileByTypeTotal&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 8, height = 3, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap( ~ type) + labs(x = &quot;Wealth Quintiles based on PPI Score&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# Create plotting layers - acceptScore
#
################################################################################
#
# Create ggplot mapping base
#
basePlot &lt;- ggplot(data = indicatorsDF, mapping = aes(x = acceptScore))
#
# Layers
#
histPlot &lt;- geom_histogram(binwidth = 1, color = wsupColour, fill = wsupColour, alpha = 0.6)
#
#
#
allPlot &lt;- basePlot + histPlot


################################################################################
#
# acceptScore: acceptScore by survey area and area type
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/acceptScoreByArea&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 18, height = 8, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap(zone ~ type, nrow = 3) + labs(x = &quot;Household acceptable sanitation score&quot;, y = &quot;&quot;) + xlim(c(0,5)) + theme_wsup
#
# Close graphics device
#
dev.off()
 

################################################################################
#
# acceptScore: acceptable sanitation score for all of Dhaka by survey area
#
################################################################################ 
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/acceptScoreByAreaTotal&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 12, height = 9, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap( ~ zone, ncol = 3) + labs(x = &quot;Household acceptable sanitation score&quot;, y = &quot;&quot;) + xlim(c(0,5)) + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# acceptScore: acceptable sanitation score for all of Dhaka by area type
#
################################################################################ 
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/acceptScoreByTypeTotal&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 8, height = 3, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap( ~ type) + labs(x = &quot;Household acceptable sanitation score&quot;, y = &quot;&quot;) + xlim(c(0,5)) + theme_wsup
#
# Close graphics device
#
dev.off()

</command>
							<property title="Histograms" shape="CHART"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="50" date="1510899093938" uid="a9bb7af1b5f813ca" x="750" y="200">
							<command>
################################################################################
#
# Perform bootstrap
#
################################################################################
#
# Subset steerIndicators to those that can be bootstrapped
#
steerBoot &lt;- subset(steerIndicators, varStatistic == &quot;oneMean&quot;)
steerBoot &lt;- subset(steerBoot, varList == &quot;san13a&quot;)
#
# Extract number of replicates specified by user
#
REPLICATES &lt;- as.numeric(tclvalue(replicates))


################################################################################
#
# All results in a single output - Bootstrap
#
################################################################################
#
# Create empty container object for bootstrap results
#
summaryTable &lt;- NULL
#
# Cycle through each enumeration zones
#
for(i in unique(indicatorsDF$zone))
  {
  #
  # Subset population data to slum areas
  #
  slum.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 1, ]
  #
  # Subset population data to other areas
  #
  other.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 2, ]
  #
  # Subset survey data to slum areas
  #
  slum.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 1, ]
  #
  # Subset survey data to other areas
  #
  other.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 2, ]  
  #
  # Get population data for all areas in current zone
  #
  all.pop &lt;- popDF[popDF$zone == i, ]
  #
  # Get survey data for all areas in current zone
  #
  all.data &lt;- indicatorsDF[indicatorsDF$zone == i, ]
  #
  # Cycle through indicator codes
  #
  for(j in steerBoot$varList)
    {
    #
    # Select indicator and statistic pair
    #
    INDICATOR &lt;- j
    STATISTIC &lt;- steerBoot$varStatistic[steerBoot$varList == j]
    #
    # Report progress
    #
    cat(&quot;\n\n&quot;, INDICATOR, &quot; : Survey Area &quot;, i, &quot;\n\n&quot;, sep = &quot;&quot;)
    #
    # Boostrap (BBW) for current indicator and statistic pair - slum
    #
    boot.slum &lt;- bootBW(x = slum.data, 
                        w = slum.pop, 
                        statistic = eval(parse(text = STATISTIC)), 
			         params = INDICATOR, 
			         outputColumns = INDICATOR, 
			         replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - other
    #
    boot.other &lt;- bootBW(x = other.data, 
			          w = other.pop, 
			          statistic = eval(parse(text = STATISTIC)), 
			          params = INDICATOR, 
			          outputColumns = INDICATOR, 
			          replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - total
    #
    boot.total &lt;- bootBW(x = all.data, 
			          w = all.pop, 
			          statistic = eval(parse(text = STATISTIC)), 
			          params = INDICATOR, 
			          outputColumns = INDICATOR, 
			          replicates = REPLICATES)     
    #
    # Concatenate various boot vectors into data.frame
    #
    boot.all &lt;- data.frame(boot.slum, boot.other, boot.total)
    names(boot.all) &lt;- c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Total&quot;)
    #
    # Create a row of results and insert quantiles of boot results
    #
    rowResult &lt;- c(unique(country), unique(ccode), steerBoot$varNames[steerBoot$varList == j], j, paste(&quot;Survey Area &quot;, i, sep = &quot;&quot;))
    for(k in names(boot.all))
      {
	 rowResult &lt;- c(rowResult, quantile(boot.all[[k]], probs = c(0.5, 0.025, 0.975), na.rm = TRUE))
      }
    #
    # Record results
    #
    summaryTable &lt;- rbind(summaryTable, rowResult)
    }
  #
  # Tidy results (row names, column types, column names, and order of rows)
  #
  summaryTable &lt;- data.frame(summaryTable, row.names = 1:nrow(summaryTable))
  #
  # Convert estimate results into numeric
  #
  for(col in 6:ncol(summaryTable))
    {
    summaryTable[, col] &lt;- as.numeric(summaryTable[, col])
    }
  }
#
# Rename summaryTable
#
names(summaryTable) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;,
	                    &quot;Indicator&quot;, &quot;Indicator Code&quot;, &quot;Survey Area&quot;, 
           	          &quot;Slum Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Other Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Total Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;)
#
# Round-off estimates to the nearest 4 decimal places
#
summaryTable[ , 6:ncol(summaryTable)] &lt;- round(summaryTable[  , 6:ncol(summaryTable)], 4)
#
# Keep the rounding off of results for table output
#
options(scipen = 10)
#
# Save summaryTable as CSV file
#
write.csv(x = summaryTable, 
  	     file = paste(&quot;outputTables/surveyResultsBootNew&quot;, unique(ccode), &quot;.csv&quot;, sep = &quot;&quot;),
	     row.names = FALSE)
#
# Reset scipen back to 0
#
options(scipen = 0)

</command>
							<property title="Estimate" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="51" date="1510899095246" uid="9d444cc54d3af3a0" x="660" y="370">
							<command>################################################################################
#
# water9: person who usually collects water
#
################################################################################
#
# waterCollect: person who usually collects water
#
waterCollect &lt;- ifelse(surveyData$water21 == &quot;Other (please specify)&quot;, surveyData$water22, surveyData$water21)
waterCollect &lt;- ifelse(waterCollect == &quot;&quot;, &quot;Don&apos;t know/no answer/not applicable&quot;, waterCollect)
waterCollect &lt;- str_split(string = waterCollect, pattern = &quot;, &quot;, simplify = TRUE)
#
# Create temporary container for vector outputs
#
temp &lt;- NULL
#
# Cycle through columns of waterCollect
#
for(i in 1:ncol(waterCollect))
  {
  #
  # Concatenate waterCollect columns into a single vector
  #
  temp &lt;- c(temp, waterCollect[ , i])
  }
#
# Re-assign NA value to &quot;&quot; answers 
#
temp &lt;- ifelse(temp == &quot;&quot;, NA, temp)
#
# Get responses
#
tempNames &lt;- names(table(temp))
#
# Create empty vector container
#
water9 &lt;- NULL
#
# Cycle through responses
#
for(i in 1:length(tempNames))
  {
  #
  # Create empty vector with length of surveyData
  #
  assign(paste(&quot;water9&quot;, letters[i], sep = &quot;&quot;), vector(mode = &quot;numeric&quot;, length = nrow(surveyData)))
  #
  # Cycle through data columns in waterCollect
  #
  for(j in 1:ncol(waterCollect))
    {
    #
    # Assign values
    #
    x &lt;- ifelse(waterCollect[ , j] == tempNames[i], i, 0)
    #
    # Concatenate responses
    #
    assign(paste(&quot;water9&quot;, letters[i], sep = &quot;&quot;), get(paste(&quot;water9&quot;, letters[i], sep = &quot;&quot;)) + x)
    }
  #
  # Rename responses to character strings
  #
  assign(paste(&quot;water9&quot;, letters[i], sep = &quot;&quot;), ifelse(get(paste(&quot;water9&quot;, letters[i], sep = &quot;&quot;)) == i, tempNames[i], NA))
  #
  #
  #
  water9 &lt;- data.frame(cbind(water9, get(paste(&quot;water9&quot;, letters[i], sep = &quot;&quot;))))
  }
#
# Rename the data.frame
#  
names(water9) &lt;- paste(&quot;water9&quot;, letters[1:length(tempNames)], sep = &quot;&quot;)
#
# Create water9 data.frame
#
water9 &lt;- data.frame(&quot;uniqueID&quot; = surveyData[ , &quot;uniqueID&quot;], &quot;psu&quot; = surveyData[ , &quot;psu&quot;], water9)
#
#
#
adminDF &lt;- surveyData[ , c(&quot;uniqueID&quot;, &quot;zone&quot;, &quot;type&quot;, &quot;quadrat&quot;, &quot;hhid&quot;, 
                           &quot;longitude&quot;, &quot;latitude&quot;)]
#
#
#
pPoverty &lt;- subset(indicatorsDF, select = c(uniqueID, pQuintile))
#
#
#
temp &lt;- merge(adminDF, pPoverty)
waterCollectDF &lt;- merge(temp, water9)</command>
							<property/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="52" date="1510899093939" uid="4e700b14e7cb43ea" x="470" y="170">
							<command>

################################################################################
#
# Create base HTML with frames and menu file 
#
################################################################################
#
# Create HTML frameset for results
#
sink(file = &quot;report/index.html&quot;)
cat(&quot;&lt;HTML&gt;\n&lt;HEAD&gt;\n&lt;TITLE&gt;\n&lt;/TITLE&gt;\n&lt;/HEAD&gt;\n&quot;)
cat(&quot;&lt;FRAMESET cols=\&quot;300,*\&quot; BORDER=0 FRAMEBORDER=no FRAMESPACING=0 MARGINWIDTH=\&quot;0\&quot; MARGINHEIGHT=\&quot;0\&quot;&gt;\n&quot;)
cat(&quot;&lt;FRAME SRC=\&quot;results/menu.html\&quot; NAME=\&quot;menu\&quot; SCROLLING=\&quot;auto\&quot; MARGINWIDTH=\&quot;0\&quot; MARGINHEIGHT=\&quot;0\&quot;&gt;\n&quot;, sep = &quot;&quot;)
cat(&quot;&lt;FRAME SRC=\&quot;&quot;, paste(&quot;results/&quot;, steerIndicators$varFile[1], &quot;.html&quot;, sep = &quot;&quot;), &quot;\&quot; NAME=\&quot;results\&quot; SCROLLING=\&quot;auto\&quot; MARGINWIDTH=\&quot;75\&quot; MARGINHEIGHT=\&quot;0\&quot;&gt;\n&quot;, sep = &quot;&quot;)
cat(&quot;&lt;/FRAMESET&gt;\n&quot;)
cat(&quot;&lt;/HTML&gt;\n&quot;)
sink()
#
# Create HTML menu file
#
sink(file = &quot;report/results/menu.html&quot;)
cat(&quot;&lt;HTML&gt;\n&quot;)
cat(&quot;&lt;HEAD&gt;&lt;BR&gt;&lt;P ALIGN=CENTER&gt;&lt;IMG SRC=\&quot;../logo.png\&quot; HEIGHT=\&quot;AUTO\&quot; WIDTH=\&quot;70%\&quot; /&gt;&lt;BR&gt;&lt;H3 ALIGN=CENTER&gt;Urban Water and Sanitation Survey&lt;BR&gt;\nDhaka, Bangladesh&lt;BR&gt;&lt;/H3&gt;&lt;/CENTER&gt;&lt;/HEAD&gt;\n&quot;)
cat(&quot;&lt;BODY&gt;\n&quot;)
cat(&quot;&lt;BR&gt;\n&quot;)
#
# Cycle through steering file
#
for(i in 1:length(unique(steerIndicators$varSet)))
{
cat(&quot;&lt;P ALIGN=CENTER&gt;&lt;A HREF=\&quot;&quot;, paste(unique(steerIndicators$varFile)[i], &quot;.html&quot;, sep = &quot;&quot;) ,&quot;\&quot; TARGET=\&quot;results\&quot;&gt;&quot;, unique(steerIndicators$varTitle)[i], &quot;&lt;/A&gt;&lt;/P&gt;\n&quot;, sep = &quot;&quot;)
}
cat(&quot;&lt;/BODY&gt;\n&quot;)
cat(&quot;&lt;/HTML&gt;\n&quot;)
sink()


################################################################################
#
# Create results pages
#
################################################################################
#
# Cycle through each variable set
#
for(i in 1:length(unique(steerIndicators$varFile)))
  {
  #
  # Open results file stream
  #
  sink(paste(&quot;report/results/&quot;, unique(steerIndicators$varFile)[i], &quot;.html&quot;, sep = &quot;&quot;))
  #
  # Start an HTML file for current variable set
  #  
  startHTML(label = unique(steerIndicators$varTitle)[i])
  #
  # Subset results table to current indicator set
  #    
  temp &lt;- subset(surveyResults, indicatorCode %in% unique(steerIndicators$varList[steerIndicators$varSet == unique(steerIndicators$varSet)[i]]))
  #
  # Subset steerIndicators to match current indicator set
  #
  currentSteer &lt;- subset(steerIndicators, varFile == unique(steerIndicators$varFile)[i])
  #
  # Cycle through variable code list of current indicator set
  #
  for(j in currentSteer$varList)
      {
      #
      # Determine if current indicator requires a pareto or histogram function
      #
      if(currentSteer$varFunction[currentSteer$varList == j] == &quot;pareto&quot; | currentSteer$varFunction[currentSteer$varList == j] == &quot;histogram&quot;)
        {
        #
        # Cylce through survey areas
        #
        for(k in 1:nrow(temp))
          {
          #
          # Insert pareto chart or histogram of slum, other and total for each survey area
          #
          insertFigureHTML(label = paste(currentSteer$varNames[currentSteer$varList == j], &quot;-&quot;, &quot;Survey Area&quot;, k, sep = &quot; &quot;),
                           filename = paste(&quot;../../outputFigures/charts/&quot;, j, &quot;SurveyArea&quot;, k, &quot;.png&quot;, sep = &quot;&quot;))
          }
        }
      #
      # Determine if current indicator requires a histogram (mean)
      #
      if(currentSteer$varFunction[currentSteer$varList == j] == &quot;histogram&quot;)
        {
        #
        # Insert map of mean indicator
        #
        insertFigureHTML(label = steerIndicators$varNames[steerIndicators$varList == j],
                         filename = paste(&quot;../../outputFigures/maps/&quot;, j, &quot;.png&quot;, sep = &quot;&quot;))
        #
        # Start an HTML table for current indicator
        #
        startTableHTML(label = steerIndicators$varNames[steerIndicators$varList == j])
        #
        # Subset results to current indicator
        #
        currentTable &lt;- subset(temp, indicatorCode == j)
        #
        # Cycle through rows of the results for current indicator
        #
        for(l in 1:nrow(currentTable))
          {
          #
          # Create row of results
          #
          rowResults &lt;- currentTable[l, c(&quot;slumTotal&quot;, &quot;slumEst&quot;, &quot;slumLCL&quot;, &quot;slumUCL&quot;, 
                                          &quot;otherTotal&quot;, &quot;otherEst&quot;, &quot;otherLCL&quot;, &quot;otherUCL&quot;,
                                          &quot;total&quot;, &quot;totalEst&quot;, &quot;totalLCL&quot;, &quot;totalUCL&quot;)]
          #
          #
          #
          if(currentSteer$varSet[currentSteer$varList == j] == &quot;poverty&quot; &amp; j != &quot;ppi&quot;)
            {
            #
            # Insert indicator results into the HTML table 
            #
            tableRowHTMLpoverty(label = currentTable$surveyArea[l], 
                                x = c(rowResults[,1], rowResults[,2], rowResults[,3], 
                                      rowResults[,4], rowResults[,5], rowResults[,6], 
                                      rowResults[,7], rowResults[,8], rowResults[,9], 
                                      rowResults[,10], rowResults[,11], rowResults[,12]))
            }
          else
            {
		  #
		  # Insert indicator results into the HTML table 
		  #
		  tableRowHTMLmean(label = currentTable$surveyArea[l], 
				         x = c(rowResults[,1], rowResults[,2], rowResults[,3], 
					          rowResults[,4], rowResults[,5], rowResults[,6], 
					          rowResults[,7], rowResults[,8], rowResults[,9], 
					          rowResults[,10], rowResults[,11], rowResults[,12]))
		  }		          
          }
        #
        # Close table HTML
        #
        stopTableHTML()
        }
      #
      # Determine if current indicator requires a proportion
      #
      if(currentSteer$varFunction[currentSteer$varList == j] == &quot;proportion&quot;)
        {
        #
        # Insert map of proportion indicator
        #
        insertFigureHTML(label = steerIndicators$varNames[steerIndicators$varList == j],
                         filename = paste(&quot;../../outputFigures/maps/&quot;, j, &quot;.png&quot;, sep = &quot;&quot;))
        #
        # Start an HTML table for current indicator
        #
        startTableHTML(label = steerIndicators$varNames[steerIndicators$varList == j])
        #
        # Subset results to current indicator
        #
        currentTable &lt;- subset(temp, indicatorCode == j)
        #
        # Cycle through rows of the results for current indicator
        #
        for(l in 1:nrow(currentTable))
          {
          #
          # Create row of results
          #
          rowResults &lt;- currentTable[l, c(&quot;slumTotal&quot;, &quot;slumEst&quot;, &quot;slumLCL&quot;, &quot;slumUCL&quot;, 
                                          &quot;otherTotal&quot;, &quot;otherEst&quot;, &quot;otherLCL&quot;, &quot;otherUCL&quot;,
                                          &quot;total&quot;, &quot;totalEst&quot;, &quot;totalLCL&quot;, &quot;totalUCL&quot;)]
          #
          # Convert proportions to percentages (x 100)
          #
          rowResults[c(&quot;slumEst&quot;, &quot;slumLCL&quot;, &quot;slumUCL&quot;, 
                       &quot;otherEst&quot;, &quot;otherLCL&quot;, &quot;otherUCL&quot;, 
                       &quot;totalEst&quot;, &quot;totalLCL&quot;, &quot;totalUCL&quot;)] &lt;- rowResults[c(&quot;slumEst&quot;, &quot;slumLCL&quot;, &quot;slumUCL&quot;, 
                                                                            &quot;otherEst&quot;, &quot;otherLCL&quot;, &quot;otherUCL&quot;, 
                                                                            &quot;totalEst&quot;, &quot;totalLCL&quot;, &quot;totalUCL&quot;)] * 100 
          #
          # Insert indicator results into the HTML table 
          #
          tableRowHTMLcoverage(label = currentTable$surveyArea[l], 
                               x = c(rowResults[,1], rowResults[,2], rowResults[,3], 
                                     rowResults[,4], rowResults[,5], rowResults[,6], 
                                     rowResults[,7], rowResults[,8], rowResults[,9], 
                                     rowResults[,10], rowResults[,11], rowResults[,12]))
          }
      #
      # Close HTML file
      #
      stopTableHTML()
      }
    }
  #
  # Close HTML file
  #
  stopHTML()
  #
  # Close HTML output stream
  #
  sink()
  }

</command>
							<property title="Report" shape="OUTPUT"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="53" date="1510899095243" uid="839bfb38861dd5e5" x="540" y="180">
							<command>#
# Extract country choice
#
country &lt;- as.character(tclvalue(choice.value))
#
# Determine country code
#
ccode &lt;- ifelse(country == &quot;Bangladesh&quot;, &quot;BGD&quot;,
	      ifelse(country == &quot;Ghana&quot;, &quot;GHA&quot;,
		   ifelse(country == &quot;India&quot;, &quot;IND&quot;,
			ifelse(country == &quot;Kenya&quot;, &quot;KEN&quot;,
			  ifelse(country == &quot;Madagascar&quot;, &quot;MDG&quot;, &quot;ZMB&quot;)))))


################################################################################
#
# Read processed data
#
################################################################################

surveyData &lt;- read.csv(file = paste(&quot;data/workingSurveyData&quot;, unique(ccode), &quot;.csv&quot;, sep = &quot;&quot;),
	header = TRUE, sep = &quot;,&quot;)

	


################################################################################
#
# Admin data
#
################################################################################
#
# Extract identifier data
#
adminDF &lt;- surveyData[ , c(&quot;country&quot;, &quot;ccode&quot;, &quot;uniqueID&quot;, &quot;psu&quot;, 
	&quot;zone&quot;, &quot;type&quot;, &quot;quadrat&quot;, &quot;hhid&quot;, 
	&quot;longitude&quot;, &quot;latitude&quot;)]



################################################################################
#
# Demographics data
#
################################################################################
#
# Extract demographic data
#
demoDF &lt;- surveyData[ , c(&quot;uniqueID&quot;, &quot;gender&quot;, &quot;landOwnStatus&quot;,
	&quot;nWomen&quot;, &quot;nMen&quot;, &quot;nOldWomen&quot;, &quot;nOldMen&quot;,
	&quot;nGirls&quot;, &quot;nBoys&quot;, &quot;nInfants&quot;, &quot;nMobility&quot;)]
#
# Count total number of household members
#
nMembers &lt;- surveyData$nWomen + surveyData$nMen + 
surveyData$nOldMen + surveyData$nOldWomen + 
surveyData$nGirls + surveyData$nBoys + 
surveyData$nInfants
#
# Create demographic data.frame
#
demoDF &lt;- data.frame(demoDF, nMembers)
#
# Clean-up
#
rm(nMembers)



################################################################################
#
# Progress out of Poverty Index (PPI) - Bangladesh
#
################################################################################
#
# Check if country is Bangladesh
#
if(unique(surveyData$country) == &quot;Bangladesh&quot;)
  {
  #
  # ppi1: Number of household members 12-years old or younger 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;None&quot;, 32,
  	       ifelse(surveyData$ppi1 == &quot;One&quot;, 16,
		    ifelse(surveyData$ppi1 == &quot;Two&quot;, 10, 0)))
  #
  # ppi2: Do household members 6-12 years old attend school?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;Yes&quot;, 6, 0)
  #
  # ppi3: In past year, any household member do paid work?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;No&quot;, 8, 0)
  #
  # ppi4: Number of rooms used by household
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Three or more&quot;, 5,
	       ifelse(surveyData$ppi4 == &quot;Two&quot;, 3, 0))
  #
  # ppi5: Main construction material of the walls of the main room
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;Brick/cement&quot;, 9,
	       ifelse(surveyData$ppi5 == &quot;Mud brick, or C.I. sheet/wood&quot;, 2, 0))
  #
  # ppi6: Does the household own television?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Yes&quot;, 7, 0)
  #
  # ppi7: Number of fans the household owns
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;Two or more&quot;, 7,
       	  ifelse(surveyData$ppi7 == &quot;One&quot;, 4, 0))
  #
  # ppi8: Number of mobile phones the household owns
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;Two or more&quot;, 15,
  	       ifelse(surveyData$ppi8 == &quot;One&quot;, 8, 0))
  #
  # ppi9: Does household own bicycles, motorcycles/scooters, cars?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;Yes&quot;, 4, 0)
  #
  # ppi10: Does the household own/rent/sharecrop/mortgage in or out 51 or more
  #        decimals of cultivable agricultural land
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;Yes&quot;, 7, 0)
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: load lookup table
  #
  ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableBGD.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrix[ppiMatrix[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }




################################################################################
#
# Progress out of Poverty Index (PPI) - Ghana
#
################################################################################
#
# Check if country is Ghana
#
if(unique(surveyData$country) == &quot;Ghana&quot;)
  {
  #
  # ppi1: Number of household members 12-years old or younger 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;None&quot;, 32,
		  ifelse(surveyData$ppi1 == &quot;One&quot;, 16,
		    ifelse(surveyData$ppi1 == &quot;Two&quot;, 10, 0)))
  #
  # ppi2: Do household members 6-12 years old attend school?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;Yes&quot;, 6, 0)
  #
  # ppi3: In past year, any household member do paid work?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;No&quot;, 8, 0)
  #
  # ppi4: Number of rooms used by household
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Three or more&quot;, 5,
	  	  ifelse(surveyData$ppi4 == &quot;Two&quot;, 3, 0))
  #
  # ppi5: Main construction material of the walls of the main room
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;Brick/cement&quot;, 9,
		  ifelse(surveyData$ppi5 == &quot;Mud brick, or C.I. sheet/wood&quot;, 2, 0))
  #
  # ppi6: Does the household own television?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Yes&quot;, 7, 0)
  #
  # ppi7: Number of fans the household owns
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;Two or more&quot;, 7,
		  ifelse(surveyData$ppi7 == &quot;One&quot;, 4, 0))
  #
  # ppi8: Number of mobile phones the household owns
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;Two or more&quot;, 15,
		  ifelse(surveyData$ppi8 == &quot;One&quot;, 8, 0))
  #
  # ppi9: Does household own bicycles, motorcycles/scooters, cars?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;Yes&quot;, 4, 0)
  #
  # ppi10: Does the household own/rent/sharecrop/mortgage in or out 51 or more
  #        decimals of cultivable agricultural land
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;Yes&quot;, 7, 0)
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: lookup table
  #
  ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableBGD.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrix[ppiMatrix[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }




################################################################################
#
# Progress out of Poverty Index (PPI) - India
#
################################################################################
#
# Check if country is India
#
if(unique(surveyData$country) == &quot;India&quot;)
  {
  #
  # ppi1: Number of household members 12-years old or younger 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;None&quot;, 32,
		  ifelse(surveyData$ppi1 == &quot;One&quot;, 16,
		    ifelse(surveyData$ppi1 == &quot;Two&quot;, 10, 0)))
  #
  # ppi2: Do household members 6-12 years old attend school?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;Yes&quot;, 6, 0)
  #
  # ppi3: In past year, any household member do paid work?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;No&quot;, 8, 0)
  #
  # ppi4: Number of rooms used by household
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Three or more&quot;, 5,
	  	  ifelse(surveyData$ppi4 == &quot;Two&quot;, 3, 0))
  #
  # ppi5: Main construction material of the walls of the main room
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;Brick/cement&quot;, 9,
		  ifelse(surveyData$ppi5 == &quot;Mud brick, or C.I. sheet/wood&quot;, 2, 0))
  #
  # ppi6: Does the household own television?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Yes&quot;, 7, 0)
  #
  # ppi7: Number of fans the household owns
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;Two or more&quot;, 7,
		  ifelse(surveyData$ppi7 == &quot;One&quot;, 4, 0))
  #
  # ppi8: Number of mobile phones the household owns
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;Two or more&quot;, 15,
		  ifelse(surveyData$ppi8 == &quot;One&quot;, 8, 0))
  #
  # ppi9: Does household own bicycles, motorcycles/scooters, cars?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;Yes&quot;, 4, 0)
  #
  # ppi10: Does the household own/rent/sharecrop/mortgage in or out 51 or more
  #        decimals of cultivable agricultural land
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;Yes&quot;, 7, 0)
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: lookup table
  #
  ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableBGD.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrix[ppiMatrix[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }




################################################################################
#
# Progress out of Poverty Index (PPI) - Kenya
#
################################################################################
#
# Check if country is Kenya
#
if(unique(surveyData$country) == &quot;Kenya&quot;)
  {
  #
  # ppi1: Number of household members 12-years old or younger 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;None&quot;, 32,
		  ifelse(surveyData$ppi1 == &quot;One&quot;, 16,
		    ifelse(surveyData$ppi1 == &quot;Two&quot;, 10, 0)))
  #
  # ppi2: Do household members 6-12 years old attend school?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;Yes&quot;, 6, 0)
  #
  # ppi3: In past year, any household member do paid work?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;No&quot;, 8, 0)
  #
  # ppi4: Number of rooms used by household
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Three or more&quot;, 5,
	  	  ifelse(surveyData$ppi4 == &quot;Two&quot;, 3, 0))
  #
  # ppi5: Main construction material of the walls of the main room
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;Brick/cement&quot;, 9,
		  ifelse(surveyData$ppi5 == &quot;Mud brick, or C.I. sheet/wood&quot;, 2, 0))
  #
  # ppi6: Does the household own television?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Yes&quot;, 7, 0)
  #
  # ppi7: Number of fans the household owns
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;Two or more&quot;, 7,
		  ifelse(surveyData$ppi7 == &quot;One&quot;, 4, 0))
  #
  # ppi8: Number of mobile phones the household owns
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;Two or more&quot;, 15,
		  ifelse(surveyData$ppi8 == &quot;One&quot;, 8, 0))
  #
  # ppi9: Does household own bicycles, motorcycles/scooters, cars?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;Yes&quot;, 4, 0)
  #
  # ppi10: Does the household own/rent/sharecrop/mortgage in or out 51 or more
  #        decimals of cultivable agricultural land
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;Yes&quot;, 7, 0)
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: lookup table
  #
  ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableBGD.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrix[ppiMatrix[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }




################################################################################
#
# Progress out of Poverty Index (PPI) - Madagascar
#
################################################################################
#
# Check if country is Madagascar
#
if(unique(surveyData$country) == &quot;Madagascar&quot;)
  {
  #
  # ppi1: Number of household members 12-years old or younger 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;None&quot;, 32,
		  ifelse(surveyData$ppi1 == &quot;One&quot;, 16,
		    ifelse(surveyData$ppi1 == &quot;Two&quot;, 10, 0)))
  #
  # ppi2: Do household members 6-12 years old attend school?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;Yes&quot;, 6, 0)
  #
  # ppi3: In past year, any household member do paid work?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;No&quot;, 8, 0)
  #
  # ppi4: Number of rooms used by household
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Three or more&quot;, 5,
	  	  ifelse(surveyData$ppi4 == &quot;Two&quot;, 3, 0))
  #
  # ppi5: Main construction material of the walls of the main room
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;Brick/cement&quot;, 9,
		  ifelse(surveyData$ppi5 == &quot;Mud brick, or C.I. sheet/wood&quot;, 2, 0))
  #
  # ppi6: Does the household own television?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Yes&quot;, 7, 0)
  #
  # ppi7: Number of fans the household owns
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;Two or more&quot;, 7,
		  ifelse(surveyData$ppi7 == &quot;One&quot;, 4, 0))
  #
  # ppi8: Number of mobile phones the household owns
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;Two or more&quot;, 15,
		  ifelse(surveyData$ppi8 == &quot;One&quot;, 8, 0))
  #
  # ppi9: Does household own bicycles, motorcycles/scooters, cars?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;Yes&quot;, 4, 0)
  #
  # ppi10: Does the household own/rent/sharecrop/mortgage in or out 51 or more
  #        decimals of cultivable agricultural land
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;Yes&quot;, 7, 0)
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: lookup table
  #
  ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableBGD.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrix[ppiMatrix[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }




################################################################################
#
# Progress out of Poverty Index (PPI) - Zambia
#
################################################################################
#
# Check if country is Zambia
#
if(unique(surveyData$country) == &quot;Zambia&quot;)
  {
  #
  # ppi1: Number of household members 12-years old or younger 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;None&quot;, 32,
		  ifelse(surveyData$ppi1 == &quot;One&quot;, 16,
		    ifelse(surveyData$ppi1 == &quot;Two&quot;, 10, 0)))
  #
  # ppi2: Do household members 6-12 years old attend school?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;Yes&quot;, 6, 0)
  #
  # ppi3: In past year, any household member do paid work?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;No&quot;, 8, 0)
  #
  # ppi4: Number of rooms used by household
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Three or more&quot;, 5,
	  	  ifelse(surveyData$ppi4 == &quot;Two&quot;, 3, 0))
  #
  # ppi5: Main construction material of the walls of the main room
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;Brick/cement&quot;, 9,
		  ifelse(surveyData$ppi5 == &quot;Mud brick, or C.I. sheet/wood&quot;, 2, 0))
  #
  # ppi6: Does the household own television?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Yes&quot;, 7, 0)
  #
  # ppi7: Number of fans the household owns
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;Two or more&quot;, 7,
		  ifelse(surveyData$ppi7 == &quot;One&quot;, 4, 0))
  #
  # ppi8: Number of mobile phones the household owns
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;Two or more&quot;, 15,
		  ifelse(surveyData$ppi8 == &quot;One&quot;, 8, 0))
  #
  # ppi9: Does household own bicycles, motorcycles/scooters, cars?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;Yes&quot;, 4, 0)
  #
  # ppi10: Does the household own/rent/sharecrop/mortgage in or out 51 or more
  #        decimals of cultivable agricultural land
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;Yes&quot;, 7, 0)
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: lookup table
  #
  ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableBGD.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrix[ppiMatrix[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }



################################################################################
#                                                                              #
# Group population by wealth quintiles                                         #
#                                                                              #
################################################################################
#
# Find the quintile cutoffs for PPI
#
qCutOff &lt;- quantile(ppi, probs = c(0.2, 0.4, 0.6, 0.8, 1))
#
# Classify households by wealth quintile
#
pQuintile &lt;- ifelse(ppi &lt;= qCutOff[1], 1,
	ifelse(ppi &gt; qCutOff[1] &amp; ppi &lt;= qCutOff[2], 2,
		ifelse(ppi &gt; qCutOff[2] &amp; ppi &lt;= qCutOff[3], 3,
			ifelse(ppi &gt; qCutOff[3] &amp; ppi &lt;= qCutOff[4], 4, 5))))
#
# Concatenate PPI indicators into single data.frame
#
pPoverty &lt;- data.frame(&quot;uniqueID&quot; = surveyData[ , &quot;uniqueID&quot;], ppi, pQuintile, pPoverty)



################################################################################
#
# Calculate indicators: Water
#
################################################################################
#
# waterSource: source of drinking water
#
waterSource &lt;- ifelse(surveyData$water1 == &quot;Other (please specify)&quot;, surveyData$water2, surveyData$water1)
waterSource &lt;- ifelse(waterSource == &quot;Deep tube well &quot;, &quot;Deep tube well&quot;, waterSource)
waterSource &lt;- ifelse(waterSource == &quot;Shallow tubwell&quot;, &quot;Shallow tube well&quot;, waterSource)
#
# water1: improved source of drinking water
#
water1 &lt;- ifelse(waterSource %in% c(&quot;Bottled water&quot;, &quot;Deep tube well&quot;,
	&quot;Piped water into dwelling&quot;, &quot;Piped water to yard/plot&quot;,
	&quot;Public tap/standpipe/kiosk&quot;, &quot;Water lifted by motor&quot;), 1, 0)
#
# water2: formal/informal source of drinking water for Pareto chart
#
water2 &lt;- ifelse(surveyData$water3 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water3)
#
# water2a: formal/informal source of drinking water for estimation
#
water2a &lt;- ifelse(surveyData$water3 == &quot;&quot;, NA,
	ifelse(surveyData$water3 == &quot;Formal&quot;, 1, 0))
#
# water3: source of water a WSUP-supported facility
#
water3 &lt;- ifelse(surveyData$water5 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water5)
#
# water3a: source of water a WSUP-supported facility estimation
#
water3a &lt;- ifelse(surveyData$water5 == &quot;&quot;, NA,
	ifelse(surveyData$water5 == &quot;Yes&quot;, 1, 0))
#
# water4: mean number of hours per day water is available
#
water4 &lt;- surveyData$water7
#
# water4a: water available at least 12 hours (half a day)
#
water4a &lt;- ifelse(surveyData$water7 &gt;= 12, 1, 0)
#
# water4b: water available for full day
#
water4b &lt;- ifelse(is.na(surveyData$water7), 0, 
	ifelse(surveyData$water7 == 24, 1, 0))
#
# water5: mean number of days per week water available
#
water5 &lt;- ifelse(surveyData$water9 == &quot;&quot;, NA,
	ifelse(surveyData$water9 == &quot;7 day per week&quot;, 7,
		ifelse(surveyData$water9 == &quot;6 day per week&quot;, 6,
			ifelse(surveyData$water9 == &quot;5 day per week&quot;, 5,
				ifelse(surveyData$water9 == &quot;4 day per week&quot;, 4,
					ifelse(surveyData$water9 == &quot;3 day per week&quot;, 3,
						ifelse(surveyData$water9 == &quot;2 day per week&quot;, 2,
							ifelse(surveyData$water9 == &quot;1 day per week&quot;, 1, 0))))))))
#
# water5a: water available more than 3 days a week
#
water5a &lt;- ifelse(water5 &gt; 3, 1, 0)
#
# water5b: water available the whole week
#
water5b &lt;- ifelse(is.na(water5), 0, 
	ifelse(water5 == 7, 1, 0))
#
# water6: water available for the whole year
#
water6 &lt;- ifelse(surveyData$water11 == &quot;&quot;, &quot;Don&apos;t know&quot;,
	ifelse(surveyData$water11 == &quot;Yes&quot;, &quot;Yes&quot;, &quot;No&quot;))
#
# water6a: water available for the whole year (estimation)
#
water6a &lt;- ifelse(surveyData$water11 == &quot;&quot;, 0,
	ifelse(surveyData$water11 == &quot;Yes&quot;, 1, 0))
#
# water7: mean number of minutes to collect water
#
water7 &lt;- ifelse(is.na(surveyData$water14), 0, surveyData$water14)
#
# water7a: distance to water source is within 30 minutes or less
#
water7a &lt;- ifelse(water7 &lt;= 30, 1, 0)
#
# water7b: satisfied with distance between home and water source
#
water7b &lt;- ifelse(surveyData$water16 == &quot;&quot;, 1,
	ifelse(surveyData$water16 == &quot;Yes&quot;, 1, 0))
#
# water7c: satisfied with distance between home and water source (estimate)
#
water7c &lt;- ifelse(water7b == 2, NA, water7b)
#
# water8: satisfied with queuing time
#
water8 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water8[surveyData$water18 == &quot;No&quot;] &lt;- 0
water8[surveyData$water18 == &quot;Yes&quot;] &lt;- 1
water8[surveyData$water18 == &quot;&quot; &amp; surveyData$water19 == TRUE] &lt;- 2
water8[surveyData$water18 == &quot;&quot; &amp; surveyData$water20 == TRUE] &lt;- 3
water8[is.na(surveyData$water18) &amp; is.na(surveyData$water19) &amp; is.na(surveyData$water20)] &lt;- 4
#
# water8a: satisfied with queuing time
#
water8a &lt;- ifelse(water8 %in% 2:4, NA, water8)

################################################################################
#
# water9: person who usually collects water
#
################################################################################
#
# waterCollect: person who usually collects water
#
waterCollect &lt;- ifelse(surveyData$water21 == &quot;Other (please specify)&quot;, surveyData$water22, surveyData$water21)
waterCollect &lt;- ifelse(waterCollect == &quot;&quot;, &quot;Don&apos;t know/no answer/not applicable&quot;, waterCollect)
waterCollect &lt;- str_split(string = waterCollect, pattern = &quot;, &quot;, simplify = TRUE)
#
# water9a: Adult men
#
water9a &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water9a[waterCollect[,1] == &quot;Adult men&quot; | 
	waterCollect[,2] == &quot;Adult men&quot; | 
	waterCollect[,3] == &quot;Adult men&quot; | 
	waterCollect[,4] == &quot;Adult men&quot;] &lt;- 1
#
# water9b: Adult women
#
water9b &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water9b[waterCollect[,1] == &quot;Adult women&quot; | 
	waterCollect[,2] == &quot;Adult women&quot; | 
	waterCollect[,3] == &quot;Adult women&quot; | 
	waterCollect[,4] == &quot;Adult women&quot;] &lt;- 2
#
# water9c: Boys _15
#
water9c &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water9c[waterCollect[,1] == &quot;Boys _15&quot; | 
	waterCollect[,2] == &quot;Boys _15&quot; | 
	waterCollect[,3] == &quot;Boys _15&quot; | 
	waterCollect[,4] == &quot;Boys _15&quot;] &lt;- 3
#
# water9d: Girls _15
#
water9d &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water9d[waterCollect[,1] == &quot;Girls _15&quot; | 
	waterCollect[,2] == &quot;Girls _15&quot; | 
	waterCollect[,3] == &quot;Girls _15&quot; | 
	waterCollect[,4] == &quot;Girls _15&quot;] &lt;- 4
#
# water9e: Whole family
#
water9e &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water9e[waterCollect[,1] == &quot;Whole family&quot; | 
	waterCollect[,2] == &quot;Whole family&quot; | 
	waterCollect[,3] == &quot;Whole family&quot; | 
	waterCollect[,4] == &quot;Whole family&quot;] &lt;- 5
#
# water9f: Pay someone outside the family to collect water
#
water9f &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water9f[waterCollect[,1] == &quot;Pay someone outside the family to collect water&quot; | 
	waterCollect[,2] == &quot;Pay someone outside the family to collect water&quot; | 
	waterCollect[,3] == &quot;Pay someone outside the family to collect water&quot; | 
	waterCollect[,4] == &quot;Pay someone outside the family to collect water&quot;] &lt;- 6
#
# water9g: Source inside house
#
water9g &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water9g[waterCollect[,1] == &quot;Source inside house&quot; | 
	waterCollect[,2] == &quot;Source inside house&quot; | 
	waterCollect[,3] == &quot;Source inside house&quot; | 
	waterCollect[,4] == &quot;Source inside house&quot;] &lt;- 7
#
# water9h: Don&apos;t know/no answer/not applicable
#
water9h &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water9h[waterCollect[,1] == &quot;Don&apos;t know/no answer/not applicable&quot; | 
	waterCollect[,2] == &quot;Don&apos;t know/no answer/not applicable&quot; | 
	waterCollect[,3] == &quot;Don&apos;t know/no answer/not applicable&quot; | 
	waterCollect[,4] == &quot;Don&apos;t know/no answer/not applicable&quot;] &lt;- 8
#
# Create vector of water collectors
#
water9 &lt;- data.frame(water9a, water9b, water9c, water9d, water9e, water9f, water9g, water9h)


################################################################################
#
# water10: amount of water used by household per day
#
################################################################################
#
# water10: amount of water (litres) used by household per day
#
water10 &lt;- ifelse(surveyData$water23 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water23)
#
# water10a: amount of water sufficient
#
water10a &lt;- ifelse(surveyData$water25 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water25)
#
# water10b: amount of water sufficient (estimate)
#
water10b &lt;- ifelse(water10a == &quot;Don&apos;t know&quot;, NA,
	ifelse(water10a == &quot;Yes&quot;, 1, 0))


################################################################################
#
# water11: water from other sources
#
################################################################################
#
#
#
water11 &lt;- ifelse(surveyData$water27 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water27)
#
#
#
water11a &lt;- ifelse(water11 == &quot;Don&apos;t know&quot;, NA,
	ifelse(water11 == &quot;Yes&quot;, 1, 0))
#
#
#
water11b &lt;- ifelse(surveyData$water29 == &quot;&quot;, NA,
	ifelse(surveyData$water29 == &quot;Other (please specify)&quot;, surveyData$water30, surveyData$water29))
#
#
#
water11b &lt;- ifelse(water11b == &quot;&quot;, NA, water11b)
water11b[water11b == &quot;Mosque&quot;] &lt;- &quot;Mosque, school, etc.&quot;
water11b[water11b %in% c(&quot;Neighbour&apos;s house&quot;, &quot;Pump point of water&quot;)] &lt;- &quot;Other&apos;s water point&quot;
water11b[water11b == &quot;Deep tube well&quot;] &lt;- &quot;Tube well&quot;
water11b[water11b == &quot;Cann&apos;t arranged&quot;] &lt;- &quot;Can&apos;t arrange&quot;
#
#
#
water11c &lt;- ifelse(water11b %in% c(&quot;Bottled water&quot;, &quot;Piped water into dwelling&quot;,
	&quot;Piped water to yard/plot&quot;, &quot;Protected well or spring in yard&quot;,
	&quot;Public tap/standpipe/kiosk&quot;, &quot;Tube well&quot;, &quot;Water lifted by motor&quot;), 1,
ifelse(is.na(water11b), 0, 0))
#
# 
#
water11d &lt;- ifelse(water1 == 1 &amp; water7a == 1 &amp; water4b == 1 &amp; water5b == 1 &amp; water6a == 1, 1,
	ifelse(water1 == 1 &amp; water7a == 1 &amp; ((water4b == 0 | water5b == 0 | water6a == 0) &amp; water11c == 1), 1, 0))


################################################################################
#
# water12: spend on water
#
################################################################################
#
# mean spend on water
#
water12 &lt;- ifelse(surveyData$water32 == &quot;&quot;, NA, surveyData$water32)
#
# satisfied with price of water
#
water12a &lt;- ifelse(surveyData$water35 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water35)
#
# satisfied with price of water - estimate
#
water12b &lt;- ifelse(water12a == &quot;Don&apos;t know&quot;, NA,
	ifelse(water12a == &quot;Yes&quot;, 1, 0))


################################################################################
#
# water13: investment in improving water source
#
################################################################################
#
# 
#
water13 &lt;- ifelse(surveyData$water37 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water37)
#
#
#
water13a &lt;- ifelse(water13 == &quot;Don&apos;t know&quot;, NA,
	ifelse(water13 == &quot;Yes&quot;, 1, 0))


################################################################################
#
# water14: water quality
#
################################################################################
#
#
#
water14 &lt;- ifelse(surveyData$water40 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water40)
#
#
#
water14a &lt;- ifelse(water14 == &quot;Don&apos;t know&quot;, NA,
	ifelse(water14 == &quot;Yes&quot;, 1, 0))


################################################################################
#
# water15: water quality improvement
#
################################################################################
#
# waterImprovement: water quality improvement
#
waterImprovement &lt;- ifelse(surveyData$water42 == &quot;Other improvement (please specify)&quot;, surveyData$water43, surveyData$water42)
waterImprovement &lt;- ifelse(waterImprovement == &quot;&quot;, &quot;Don&apos;t know/no answer/not applicable&quot;, waterImprovement)
waterImprovement &lt;- str_split(string = waterImprovement, pattern = &quot;, &quot;, simplify = TRUE)
waterImprovement[,1] &lt;- ifelse(waterImprovement[,1] == &quot;Other improvement (please specify)&quot;, surveyData$water43, waterImprovement[,1])
waterImprovement[,2] &lt;- ifelse(waterImprovement[,2] == &quot;Other improvement (please specify)&quot;, surveyData$water43, waterImprovement[,2])
waterImprovement[,3] &lt;- ifelse(waterImprovement[,3] == &quot;Other improvement (please specify)&quot;, surveyData$water43, waterImprovement[,3])
waterImprovement[,4] &lt;- ifelse(waterImprovement[,4] == &quot;Other improvement (please specify)&quot;, surveyData$water43, waterImprovement[,4])
#
# water15a: clean water
#
water15a &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water15a[waterImprovement[,1] == &quot;Clean water&quot; | 
	waterImprovement[,2] == &quot;Clean water&quot; | 
	waterImprovement[,3] == &quot;Clean water&quot; | 
	waterImprovement[,4] == &quot;Clean water&quot;] &lt;- 1
#
# water15b: Easy handling
#
water15b &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water15b[waterImprovement[,1] == &quot;Easy handling&quot; | 
	waterImprovement[,2] == &quot;Easy handling&quot; | 
	waterImprovement[,3] == &quot;Easy handling&quot; | 
	waterImprovement[,4] == &quot;Easy handling&quot;] &lt;- 2
#
# water15c: Improvement bacterial/microbial/chemical water quality so it&apos;s safer to drink
#
water15c &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water15c[waterImprovement[,1] == &quot;Improvement bacterial/microbial/chemical water quality so it&apos;s safer to drink&quot; | 
	waterImprovement[,2] == &quot;Improvement bacterial/microbial/chemical water quality so it&apos;s safer to drink&quot; | 
	waterImprovement[,3] == &quot;Improvement bacterial/microbial/chemical water quality so it&apos;s safer to drink&quot; | 
	waterImprovement[,4] == &quot;Improvement bacterial/microbial/chemical water quality so it&apos;s safer to drink&quot;] &lt;- 3
#
# water15d: Improved colour
#
water15d &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water15d[waterImprovement[,1] == &quot;Improved colour&quot; | 
	waterImprovement[,2] == &quot;Improved colour&quot; | 
	waterImprovement[,3] == &quot;Improved colour&quot; | 
	waterImprovement[,4] == &quot;Improved colour&quot;] &lt;- 4
#
# water15e: Improved smell
#
water15e &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water15e[waterImprovement[,1] == &quot;Improved smell&quot; | 
	waterImprovement[,2] == &quot;Improved smell&quot; | 
	waterImprovement[,3] == &quot;Improved smell&quot; | 
	waterImprovement[,4] == &quot;Improved smell&quot;] &lt;- 5
#
# water15f: Iron free and clean water
#
water15f &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water15f[waterImprovement[,1] == &quot;Iron free and clean water&quot; | 
	waterImprovement[,2] == &quot;Iron free and clean water&quot; | 
	waterImprovement[,3] == &quot;Iron free and clean water&quot; | 
	waterImprovement[,4] == &quot;Iron free and clean water&quot;] &lt;- 6
#
# water15g: Less time to collect water
#
water15g &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water15g[waterImprovement[,1] == &quot;Less time to collect water&quot; | 
	waterImprovement[,2] == &quot;Less time to collect water&quot; | 
	waterImprovement[,3] == &quot;Less time to collect water&quot; | 
	waterImprovement[,4] == &quot;Less time to collect water&quot;] &lt;- 7
#
# water15h: own motor
#
water15h &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water15h[waterImprovement[,1] == &quot;Own motor&quot; | 
	waterImprovement[,2] == &quot;Own motor&quot; | 
	waterImprovement[,3] == &quot;Own motor&quot; | 
	waterImprovement[,4] == &quot;Own motor&quot;] &lt;- 8
#
# water15i: Repair the leakage in water line
#
water15i &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water15i[waterImprovement[,1] == &quot;Repair the likage in water line&quot; | 
	waterImprovement[,2] == &quot;Repair the likage in water line&quot; | 
	waterImprovement[,3] == &quot;Repair the likage in water line&quot; | 
	waterImprovement[,4] == &quot;Repair the likage in water line&quot;] &lt;- 9
#
# water15j: Water supply line
#
water15j &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water15j[waterImprovement[,1] == &quot;Water supply line&quot; | 
	waterImprovement[,2] == &quot;Water supply line&quot; | 
	waterImprovement[,3] == &quot;Water supply line&quot; | 
	waterImprovement[,4] == &quot;Water supply line&quot;] &lt;- 10
#
# water15k: Don&apos;t know/no answer/not applicable
#
water15k&lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water15k[waterImprovement[,1] == &quot;Don&apos;t know/no answer/not applicable&quot; | 
	waterImprovement[,2] == &quot;Don&apos;t know/no answer/not applicable&quot; | 
	waterImprovement[,3] == &quot;Don&apos;t know/no answer/not applicable&quot; | 
	waterImprovement[,4] == &quot;Don&apos;t know/no answer/not applicable&quot;] &lt;- 11
#
#
#
water15 &lt;- data.frame(water15a, water15b, water15c, water15d, water15e, water15f,
	water15g, water15h, water15i, water15j, water15k)


################################################################################
#
# water16: water pressure
#
################################################################################
#
#
#
water16 &lt;- ifelse(surveyData$water45 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water45)
#
#
#
water16a &lt;- ifelse(water16 == &quot;Don&apos;t know&quot;, NA,
	ifelse(water16 == &quot;Yes&quot;, 1, 0))


################################################################################
#
# water17: support provider
#
################################################################################
#
#
#
water17 &lt;- ifelse(surveyData$water47 == &quot;&quot;, &quot;Don&apos;t know/not applicable&quot;,
	ifelse(surveyData$water47 == &quot;Other (please specify)&quot;, surveyData$water48, surveyData$water47))
#
#
#
water17 &lt;- ifelse(water17 == &quot;&quot;, &quot;Don&apos;t know/not applicable&quot;, water17)
#
#
#
water17 &lt;- ifelse(water17 == &quot;Landlord/House owner &quot;, &quot;Landlord/House owner&quot;,
	ifelse(water17 == &quot;Caretaker &quot;, &quot;Caretaker&quot;,
		ifelse(water17 %in% c(&quot;Gaurd&quot;, &quot;Gaurd &quot;), &quot;Guard&quot;,
			ifelse(water17 %in% c(&quot;No complain arise&quot;, &quot;No complain  arise&quot;, &quot;Till lemdon&apos;t face any problem&quot;), &quot;No complaints&quot;,
				ifelse(water17 == &quot;Water office &quot;, &quot;Water office&quot;,
					ifelse(water17 == &quot;Do no&apos;t cpmlain&quot;, &quot;Do not complain&quot;,
						ifelse(water17 == &quot;Parlament Member (MP)&quot;, &quot;Parliament Member (MP)&quot;,
							ifelse(water17 == &quot;Relavent office&quot;, &quot;Relevant office&quot;,
								ifelse(water17 == &quot;Messengaer &quot;, &quot;Messenger&quot;, 
									ifelse(water17 == &quot;Local Gverenment Engineering office&quot;, &quot;Local Government Engineering office&quot;, water17))))))))))


################################################################################
#
# water18: water storage
#
################################################################################
#
# waterStorage
#
waterStorage &lt;- ifelse(surveyData$wash60 == &quot;&quot;, &quot;Don&apos;t know/not applicable&quot;, surveyData$wash60)
waterStorage &lt;- str_split(string = waterStorage, pattern = &quot;, &quot;, simplify = TRUE)
#
# water18a: Clean container (with lid)
#
water18a &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water18a[waterStorage[,1] == &quot;Clean container (with lid)&quot; |
	waterStorage[,2] == &quot;Clean container (with lid)&quot; |
	waterStorage[,3] == &quot;Clean container (with lid)&quot;] &lt;- 1
#
# water18b: Clean container (without lid)
#
water18b &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water18b[waterStorage[,1] == &quot;Clean container (without lid)&quot; |
	waterStorage[,2] == &quot;Clean container (without lid)&quot; |
	waterStorage[,3] == &quot;Clean container (without lid)&quot;] &lt;- 2
#
# water18c: Dirty container
#
water18c &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water18c[waterStorage[,1] == &quot;Dirty container&quot; |
	waterStorage[,2] == &quot;Dirty container&quot; |
	waterStorage[,3] == &quot;Dirty container&quot;] &lt;- 3
#
# water18d: Don&apos;t know/not applicable
#
water18d &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water18d[waterStorage[,1] == &quot;Don&apos;t know/not applicable&quot; |
	waterStorage[,2] == &quot;Don&apos;t know/not applicable&quot; |
	waterStorage[,3] == &quot;Don&apos;t know/not applicable&quot;] &lt;- 4
#
# water18
#        
water18 &lt;- ifelse(water18d == 4, NA,
	ifelse(water18a == 1 &amp; water18b != 2 &amp; water18c != 3, 1, 0))


################################################################################
#
# JMP indicators for drinking water - post-2015
#
################################################################################
#
# Surface water: river, dam, lake, pond, stream, canal or irrigation channel
#
jmpWater1 &lt;- ifelse(waterSource == &quot;Surface water&quot;, 1, 0)
#
# Unimproved: unprotected dug wells, unprotected springs, carts with small tank,
#             tanker trucks; basic sources with collection time &gt; 30 minutes;
#             primary source is bottled water but secondary source is unimproved
#
jmpWater2 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
jmpWater2[water1 == 1 &amp; waterSource != &quot;Bottled water&quot; &amp; water7a == 1] &lt;- 0
jmpWater2[water1 == 1 &amp; waterSource == &quot;Bottled water&quot; &amp; water11c == 1 &amp; water7a == 1] &lt;- 0
jmpWater2[water1 == 1 &amp; waterSource != &quot;Bottled water&quot; &amp; water7a == 0] &lt;- 1
jmpWater2[water1 == 1 &amp; waterSource == &quot;Bottled water&quot; &amp; water11c == 1 &amp; water7a == 0] &lt;- 1
jmpWater2[water1 == 0] &lt;- 1
jmpWater2[water1 == 1 &amp; waterSource == &quot;Bottled water&quot; &amp; water11c == 0] &lt;- 1
#
# Basic: piped water, boreholes or tubewells, protected dug wells, protected spring,
#        rainwater with collection time nor more than 30 minutes
#
jmpWater3 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
jmpWater3[water1 == 1 &amp; waterSource != &quot;Bottled water&quot; &amp; water7a == 1] &lt;- 1
jmpWater3[water1 == 1 &amp; waterSource == &quot;Bottled water&quot; &amp; water11c == 1 &amp; water7a == 1] &lt;- 1
jmpWater3[water1 == 1 &amp; waterSource != &quot;Bottled water&quot; &amp; water7a == 0] &lt;- 0
jmpWater3[water1 == 1 &amp; waterSource == &quot;Bottled water&quot; &amp; water11c == 1 &amp; water7a == 0] &lt;- 0
jmpWater3[water1 == 0] &lt;- 0
jmpWater3[water1 == 1 &amp; waterSource == &quot;Bottled water&quot; &amp; water11c == 0] &lt;- 0


################################################################################
#
# Tanahashi model-based bottleneck analysis of drinking water access based on JMP 
#
################################################################################
#
# wLevel1: use of water services other than surface water (availablity of water services)
#
wLevel1 &lt;- ifelse(waterSource == &quot;Surface water&quot;, 0, 1)
#
# wLevel2: use of water services that are improved (availability of improved water sources)
#
wLevel2 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
wLevel2[water1 == 1 &amp; waterSource != &quot;Bottled water&quot;] &lt;- 1
wLevel2[water1 == 1 &amp; waterSource == &quot;Bottled water&quot; &amp; water11c == 1] &lt;- 1
wLevel2[water1 == 0] &lt;- 0
wLevel2[water1 == 1 &amp; waterSource == &quot;Bottled water&quot; &amp; water11c == 0] &lt;- 0
#
# wLevel3: accessiblity of improved water sources
#
wLevel3 &lt;- ifelse(wLevel2 == 1 &amp; water7a == 1, 1, 0)
#
# wLevel4: accessible improved water sources that is always available
#
wLevel4 &lt;- ifelse(wLevel3 == 1 &amp; 
	waterSource %in% c(&quot;Deep tube well&quot;, &quot;Piped water into dwelling&quot;,
		&quot;Piped water to yard/plot&quot;, &quot;Tube well&quot;, &quot;Water lifted by moter&quot;,
		&quot;Protected dug well or spring in yard&quot;) &amp;
	water7 == 0 &amp;
	water4b == 1 &amp; water5b == 1 &amp; water6a == 1, 1, 0)
#
# wLevel5: accessible improved water sources that is free from faecal and chemical
#          contamination and is always available
#
#          Indicator can be considered effective water services coverage
#          Indicator cannot be measured/estimated as no water quality testing done
#


################################################################################
#
# Create waterDF
#
################################################################################
#
# Concatenate water indicators
#
waterDF &lt;- data.frame(&quot;uniqueID&quot; = surveyData[ , &quot;uniqueID&quot;], &quot;psu&quot; = surveyData[ , &quot;psu&quot;],
	waterSource, water1, water2, water2a, water3, water3a,
	water4, water4a, water4b, water5, water5a, water5b,
	water6, water6a, water7, water7a, water7b, water7c, water8, water8a,
	water9a, water9b, water9c, water9d, water9e, water9f, water9g, water9h,
	water10, water10a, water10b,
	water11, water11a, water11b, water11c, water11d,
	water12, water12a, water12b,
	water13, water13a,
	water14, water14a,
	water15a, water15b, water15c, water15d, water15e, water15f, water15g, water15h, water15i, water15j, water15k,
	water16, water16a,
	water17,
	water18,
	jmpWater1, jmpWater2, jmpWater3,
	wLevel1, wLevel2, wLevel3, wLevel4)
#
# Clean-up
#
rm(waterSource, water1, water2, water2a, water3, water3a, water4, water4a, water4b,
	water5, water5a, water5b, water6, water6a, water7, water7a, water7b, water7c,
	water8, water8a, water9a, water9b, water9c, water9d, water9e, water9f, water9g, water9h,
	water10, water10a, water10b, water11, water11a, water11b, water11c, water11d,
	water12, water12a, water12b, water13, water13a, water14, water14a,
	water15a, water15b, water15c, water15d, water15e, water15f, water15g, water15h, water15i, water15j, water15k,
	water16, water16a, water17, water18,
	jmpWater1, jmpWater2, jmpWater3,
	wLevel1, wLevel2, wLevel3, wLevel4)

	



################################################################################
#
# Sanitation indicators 
#
################################################################################

################################################################################
#
# san1: shared sanitation facility - user arrangements.
#
################################################################################
#
#
#
san1 &lt;- ifelse(surveyData$san1 == &quot;&quot;, &quot;Don&apos;t know&quot;,
	ifelse(surveyData$san1 == &quot;Other (please specify)&quot;, surveyData$san2, surveyData$san1))
#
# Clean-up
#
san1 &lt;- ifelse(san1 == &quot;Communal / shared toilet &quot;, &quot;Communal / shared toilet&quot;, san1)
#
# san1a: is toilet facility shared with other households
#
san1a &lt;- ifelse(san1 == &quot;Household toilet&quot;, 0, 1)


################################################################################
#
# san2: Number of people who share toilet facilities 
#
################################################################################
#
# san2: Mean number of people who share toilet facilities
#
san2 &lt;- ifelse(is.na(surveyData$san4), 0, surveyData$san4)
#
# san2a: shared toilet facility 
#
san2a &lt;- ifelse(san2 == 0, 0, 1)


################################################################################
#
# san3: type of facility
#
################################################################################
#
# san3: type  of facility
#
san3 &lt;- ifelse(surveyData$san6 == &quot;Other (please specify)&quot;, surveyData$san7, surveyData$san6)
#
# clean-up
#
san3 &lt;- ifelse(san3 %in% c(&quot;Drain&quot;, &quot;Drain connected with waterbody&quot;, 
	&quot;Drain with water body (Jhill)&quot;, &quot;Open drain&quot;), &quot;Drain&quot;,
ifelse(san3 %in% c(&quot;In water body (Jhill)&quot;, 
	&quot;Lake&quot;, &quot;Pond&quot;,
	&quot;No facilities or bush or field&quot;), &quot;No facilities or bush or field or lake or pond&quot;,
ifelse(san3 %in% c(&quot;Ditch with ring&quot;, &quot;Ring and slub&quot;, &quot;Slub and in the bottom drain&quot;), &quot;Ring and slab without pit latrine&quot;, san3)))


################################################################################
#
# san4: where effluent flushes to
#
################################################################################
#
# san4: where effluent flushes to
#
san4 &lt;- ifelse(surveyData$san9 == &quot;&quot;, &quot;Don&apos;t know&quot;,
	ifelse(surveyData$san9 == &quot;Other (please specify)&quot;, surveyData$san10, surveyData$san9))
#
# clean-up
#
san4 &lt;- ifelse(san4 %in% c(&quot;Open drain&quot;, &quot;Adjacent to pond&quot;, &quot;Ditch&quot;, &quot;Ditch &quot;,
	&quot;pond&quot;, &quot;River&quot;, &quot;Water body (Cannel)&quot;), &quot;Open drain/ditch/water body&quot;, 
ifelse(san4 == &quot;Tanki&quot;, &quot;Septic tank&quot;, san4))


################################################################################
#
# san5: WSUP-supported facility
#
################################################################################
#
# san5: WSUP-supported facility
#
san5 &lt;- ifelse(surveyData$san12 == &quot;&quot; &amp; surveyData$san13 == &quot;TRUE&quot;, &quot;Not applicable&quot;,
	ifelse(surveyData$san12 == &quot;&quot; &amp; surveyData$san14 == &quot;TRUE&quot;, &quot;Don&apos;t know&quot;, surveyData$san12))
#
# re-code
#
san5 &lt;- ifelse(san5 == &quot;Yes&quot;, 1,
	ifelse(san5 == &quot;No&quot;, 0, NA))


################################################################################
#
# san6: water in facility
#
#################################################################################
#
# san6: water in facility (Yes / No)
#
san6 &lt;- ifelse(surveyData$san15 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san7: satisfied with handwashing facility
#
################################################################################
#
# san7: satisfied with handwashing facility
#
san7 &lt;- ifelse(surveyData$san17 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san8: what would increase your satisfaction
#
################################################################################
#
# Re-code
#
sanSatisfaction &lt;- ifelse(surveyData$san19 == &quot;Other (please specify)&quot;, surveyData$san20, surveyData$san19)
sanSatisfaction &lt;- ifelse(sanSatisfaction == &quot;&quot;, &quot;Don&apos;t know/no answer/not applicable&quot;, sanSatisfaction)
sanSatisfaction &lt;- str_split(string = sanSatisfaction, pattern = &quot;, &quot;, simplify = TRUE)
sanSatisfaction[,1] &lt;- ifelse(sanSatisfaction[,1] == &quot;Other (please specify)&quot;, surveyData$san20, sanSatisfaction[,1]) 
sanSatisfaction[,2] &lt;- ifelse(sanSatisfaction[,2] == &quot;Other (please specify)&quot;, surveyData$san20, sanSatisfaction[,2])
sanSatisfaction[,3] &lt;- ifelse(sanSatisfaction[,3] == &quot;Other (please specify)&quot;, surveyData$san20, sanSatisfaction[,3])
sanSatisfaction[,4] &lt;- ifelse(sanSatisfaction[,4] == &quot;Other (please specify)&quot;, surveyData$san20, sanSatisfaction[,4])
#
# san8a: Availability of soap
#
san8a &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san8a[sanSatisfaction[,1] == &quot;Availability of soap&quot; |
	sanSatisfaction[,2] == &quot;Availability of soap&quot; |
	sanSatisfaction[,3] == &quot;Availability of soap&quot; |
	sanSatisfaction[,4] == &quot;Availability of soap&quot;] &lt;- 1
#
# san8b: Availability of washbasin
#
san8b &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san8b[sanSatisfaction[,1] == &quot;Availability of washbasin&quot; |
	sanSatisfaction[,2] == &quot;Availability of washbasin&quot; |
	sanSatisfaction[,3] == &quot;Availability of washbasin&quot; |
	sanSatisfaction[,4] == &quot;Availability of washbasin&quot;] &lt;- 2
#
# san8c: Cleaner water
#
san8c &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san8c[sanSatisfaction[,1] == &quot;Cleaner water&quot; |
	sanSatisfaction[,2] == &quot;Cleaner water&quot; |
	sanSatisfaction[,3] == &quot;Cleaner water&quot; |
	sanSatisfaction[,4] == &quot;Cleaner water&quot;] &lt;- 3
#
# san8d: Cleaner water
#
san8d &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san8d[sanSatisfaction[,1] == &quot;More water&quot; |
	sanSatisfaction[,2] == &quot;More water&quot; |
	sanSatisfaction[,3] == &quot;More water&quot; |
	sanSatisfaction[,4] == &quot;More water&quot;] &lt;- 4
#
# san8e: Supply water in latrine
#
san8e &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san8e[sanSatisfaction[,1] == &quot;Supply water in latrine&quot; |
	sanSatisfaction[,2] == &quot;Supply water in latrine&quot; |
	sanSatisfaction[,3] == &quot;Supply water in latrine&quot; |
	sanSatisfaction[,4] == &quot;Supply water in latrine&quot;] &lt;- 5
#
# san8f: water arrangement in latrine
#
san8f &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san8f[sanSatisfaction[,1] == &quot;Water arrangement in toilet&quot; |
	sanSatisfaction[,2] == &quot;Water arrangement in toilet&quot; |
	sanSatisfaction[,3] == &quot;Water arrangement in toilet&quot; |
	sanSatisfaction[,4] == &quot;Water arrangement in toilet&quot;] &lt;- 6
#
# san8g: sanitary latrine
#
san8g &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san8g[sanSatisfaction[,1] == &quot;Sanitary latrine&quot; |
	sanSatisfaction[,2] == &quot;Sanitary latrine&quot; |
	sanSatisfaction[,3] == &quot;Sanitary latrine&quot; |
	sanSatisfaction[,4] == &quot;Sanitary latrine&quot;] &lt;- 7
#
# san8h: Don&apos;t know/no answer/not applicable
#
san8h &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san8h[sanSatisfaction[,1] == &quot;Don&apos;t know/no answer/not applicable&quot; |
	sanSatisfaction[,2] == &quot;Don&apos;t know/no answer/not applicable&quot; |
	sanSatisfaction[,3] == &quot;Don&apos;t know/no answer/not applicable&quot; |
	sanSatisfaction[,4] == &quot;Don&apos;t know/no answer/not applicable&quot;] &lt;- 8
#
# concatenate into data.frame
#
san8 &lt;- data.frame(san8a, san8b, san8c, san8d, san8e, san8f, san8g, san8h)


################################################################################
#
# san9: lights in toilet facility
#
################################################################################
#
# san9: lights in toilet facility
#
san9 &lt;- ifelse(surveyData$san22 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san10: toilet facility with lockable door
#
################################################################################
#
# san10: lockable door
#
san10 &lt;- ifelse(surveyData$san24 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san11: container for menstrual hygiene management
#
################################################################################
#
# san11: container for menstrual hygiene management
#
san11 &lt;- ifelse(surveyData$san26 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san12: Sanitary disposal of child&apos;s faeces
#
################################################################################
#
# san12: sanitary disposal of child&apos;s faeces
#
san12 &lt;- ifelse(surveyData$san28 %in% c(&quot;Child used toilet/latrine&quot;, 
	&quot;Put/rinsed into the toilet&quot;), 1, 0)


################################################################################
#
# san13: Waiting time to use the toilet
#
################################################################################
#
# san13: Waiting time to use the toilet
#
san13 &lt;- ifelse(is.na(surveyData$san31), 0, surveyData$san31)


################################################################################
#
# san14: spend on sanitation facility
#
################################################################################
#
# san14: spend on sanitation facility
#
san14 &lt;- ifelse(is.na(surveyData$san33), 0, surveyData$san33)


################################################################################
#
# san15: satisfied with spend
#
################################################################################
#
# san15: satisfied with spend
#
san15 &lt;- ifelse(surveyData$san36 == &quot;&quot;, NA,
	ifelse(surveyData$san36 == &quot;Yes&quot;, 1, 0))


################################################################################
#
# san16: initial investment in toilet facility
#
################################################################################
#
# san16: initial investment in toilet facility
#
san16 &lt;- ifelse(surveyData$san38 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san17: amount of investment
#
################################################################################
#
# san17: amount of investment
#
san17 &lt;- ifelse(is.na(surveyData$san40), 0, surveyData$san40)


################################################################################
#
# san18: willingness to invest
#
################################################################################
#
# san18: willingness to invest
#
san18 &lt;- ifelse(surveyData$san43 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san19: satisfied with cleanliness
#
################################################################################
#
# san19: satisfied with cleanliness
#
san19 &lt;- ifelse(surveyData$san46 == &quot;Yes&quot;, 1,
	ifelse(surveyData$san46 == &quot;No&quot;, 0, NA))


################################################################################
#
# san20: increase satisfaction
#
################################################################################
#
# Re-code
#
cleanSatisfaction &lt;- ifelse(surveyData$san48 == &quot;Other (please specify)&quot;, surveyData$san49, surveyData$san48)
cleanSatisfaction &lt;- ifelse(cleanSatisfaction == &quot;&quot;, &quot;Don&apos;t know/no answer/not applicable&quot;, cleanSatisfaction)
cleanSatisfaction &lt;- str_split(string = cleanSatisfaction, pattern = &quot;, &quot;, simplify = TRUE)
cleanSatisfaction[,1] &lt;- ifelse(cleanSatisfaction[,1] == &quot;Other (please specify)&quot;, surveyData$san49, cleanSatisfaction[,1]) 
cleanSatisfaction[,2] &lt;- ifelse(cleanSatisfaction[,2] == &quot;Other (please specify)&quot;, surveyData$san49, cleanSatisfaction[,2])
cleanSatisfaction[,3] &lt;- ifelse(cleanSatisfaction[,3] == &quot;Other (please specify)&quot;, surveyData$san49, cleanSatisfaction[,3])
cleanSatisfaction[,4] &lt;- ifelse(cleanSatisfaction[,4] == &quot;Other (please specify)&quot;, surveyData$san49, cleanSatisfaction[,4])
cleanSatisfaction[,1] &lt;- ifelse(cleanSatisfaction[,1] == &quot;Increased availability of water next tothe sanitation facility&quot;, &quot;Increased availability of water next to the sanitation facility&quot;, cleanSatisfaction[,1]) 
cleanSatisfaction[,2] &lt;- ifelse(cleanSatisfaction[,2] == &quot;Increased availability of water next tothe sanitation facility&quot;, &quot;Increased availability of water next to the sanitation facility&quot;, cleanSatisfaction[,2])
cleanSatisfaction[,3] &lt;- ifelse(cleanSatisfaction[,3] == &quot;Increased availability of water next tothe sanitation facility&quot;, &quot;Increased availability of water next to the sanitation facility&quot;, cleanSatisfaction[,3])
cleanSatisfaction[,4] &lt;- ifelse(cleanSatisfaction[,4] == &quot;Increased availability of water next tothe sanitation facility&quot;, &quot;Increased availability of water next to the sanitation facility&quot;, cleanSatisfaction[,4])
cleanSatisfaction[,1] &lt;- ifelse(cleanSatisfaction[,1] == &quot;Slub and ring larine&quot;, &quot;Ring and slab latrine&quot;, cleanSatisfaction[,1]) 
cleanSatisfaction[,2] &lt;- ifelse(cleanSatisfaction[,2] == &quot;Slub and ring larine&quot;, &quot;Ring and slab latrine&quot;, cleanSatisfaction[,2])
cleanSatisfaction[,3] &lt;- ifelse(cleanSatisfaction[,3] == &quot;Slub and ring larine&quot;, &quot;Ring and slab latrine&quot;, cleanSatisfaction[,3])
cleanSatisfaction[,4] &lt;- ifelse(cleanSatisfaction[,4] == &quot;Slub and ring larine&quot;, &quot;Ring and slab latrine&quot;, cleanSatisfaction[,4])
#
# san20a: Increased availability of bins
#
san20a &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san20a[cleanSatisfaction[,1] == &quot;Increased availability of bins&quot; |
	cleanSatisfaction[,2] == &quot;Increased availability of bins&quot; |
	cleanSatisfaction[,3] == &quot;Increased availability of bins&quot; |
	cleanSatisfaction[,4] == &quot;Increased availability of bins&quot;] &lt;- 1
#
# san20b: Increased availability of water next to the sanitation facility
# 
san20b &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san20b[cleanSatisfaction[,1] == &quot;Increased availability of water next to the sanitation facility&quot; |
	cleanSatisfaction[,2] == &quot;Increased availability of water next to the sanitation facility&quot; |
	cleanSatisfaction[,3] == &quot;Increased availability of water next to the sanitation facility&quot; |
	cleanSatisfaction[,4] == &quot;Increased availability of water next to the sanitation facility&quot;] &lt;- 2
#
# san20c: Increased availability or affordability of cleaning products
#
san20c &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san20c[cleanSatisfaction[,1] == &quot;Increased availability or affordability of cleaning products&quot; |
	cleanSatisfaction[,2] == &quot;Increased availability or affordability of cleaning products&quot; |
	cleanSatisfaction[,3] == &quot;Increased availability or affordability of cleaning products&quot; |
	cleanSatisfaction[,4] == &quot;Increased availability or affordability of cleaning products&quot;] &lt;- 3
#
# san20d: Increased cleaning frequency
#
san20d &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san20d[cleanSatisfaction[,1] == &quot;Increased cleaning frequency&quot; |
	cleanSatisfaction[,2] == &quot;Increased cleaning frequency&quot; |
	cleanSatisfaction[,3] == &quot;Increased cleaning frequency&quot; |
	cleanSatisfaction[,4] == &quot;Increased cleaning frequency&quot;] &lt;- 4
#
# san20e: Ring and slab latrine
#
san20e &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san20e[cleanSatisfaction[,1] == &quot;Ring and slab latrine&quot; |
	cleanSatisfaction[,2] == &quot;Ring and slab latrine&quot; |
	cleanSatisfaction[,3] == &quot;Ring and slab latrine&quot; |
	cleanSatisfaction[,4] == &quot;Ring and slab latrine&quot;] &lt;- 5
#
# san20f: Supply water at latrine
#
san20f &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san20f[cleanSatisfaction[,1] == &quot;Supply water at latrine&quot; |
	cleanSatisfaction[,2] == &quot;Supply water at latrine&quot; |
	cleanSatisfaction[,3] == &quot;Supply water at latrine&quot; |
	cleanSatisfaction[,4] == &quot;Supply water at latrine&quot;] &lt;- 6
#
# san20g: Latrine close to house
#
san20g &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san20g[cleanSatisfaction[,1] == &quot;Latrine close to house&quot; |
	cleanSatisfaction[,2] == &quot;Latrine close to house&quot; |
	cleanSatisfaction[,3] == &quot;Latrine close to house&quot; |
	cleanSatisfaction[,4] == &quot;Latrine close to house&quot;] &lt;- 7
#
# san20h: Don&apos;t know/no answer/not applicable
#
san20h &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san20h[cleanSatisfaction[,1] == &quot;Don&apos;t know/no answer/not applicable&quot; |
	cleanSatisfaction[,2] == &quot;Don&apos;t know/no answer/not applicable&quot; |
	cleanSatisfaction[,3] == &quot;Don&apos;t know/no answer/not applicable&quot; |
	cleanSatisfaction[,4] == &quot;Don&apos;t know/no answer/not applicable&quot;] &lt;- 8
#
# san20
#
san20 &lt;- data.frame(san20a, san20b, san20c, san20d, san20e, san20f, san20g, san20h)


################################################################################
#
# san21: Everyone in household able to get to sanitation facility?
#
################################################################################
#
# san21: everyone in household able to get to sanitation facility
#
san21 &lt;- ifelse(surveyData$san51 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san22: who is not using the sanitation facility?
#
################################################################################
#
#
#
sanitationUse &lt;- ifelse(surveyData$san53 == &quot;&quot;, &quot;Don&apos;t know&quot;,
	ifelse(surveyData$san53 == &quot;Other (please specify)&quot;, surveyData$san54, surveyData$san53))
sanitationUse &lt;- str_split(string = sanitationUse, pattern = &quot;, &quot;, simplify = TRUE)
sanitationUse[,1] &lt;- ifelse(sanitationUse[,1] == &quot;Other (please specify)&quot;, surveyData$san54, sanitationUse[,1])
sanitationUse[,2] &lt;- ifelse(sanitationUse[,2] == &quot;Other (please specify)&quot;, surveyData$san54, sanitationUse[,2])
sanitationUse[,1] &lt;- ifelse(sanitationUse[,1] == &quot;Disable&quot;, &quot;Disabled&quot;, sanitationUse[,1])
sanitationUse[,2] &lt;- ifelse(sanitationUse[,2] == &quot;Disable&quot;, &quot;Disabled&quot;, sanitationUse[,2])
#
# san22a: Children
#
san22a &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san22a[sanitationUse[,1] == &quot;Children&quot; | sanitationUse[,2] == &quot;Children&quot;] &lt;- 1
#
# san22b: Elderly family members
#
san22b &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san22b[sanitationUse[,1] == &quot;Elderly family members&quot; | sanitationUse[,2] == &quot;Elderly family members&quot;] &lt;- 2
#
# san22c: Husband
#
san22c &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san22c[sanitationUse[,1] == &quot;Husband&quot; | sanitationUse[,2] == &quot;Husband&quot;] &lt;- 3
#
# san22d: Disabled
#
san22d &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san22d[sanitationUse[,1] == &quot;Disabled&quot; | sanitationUse[,2] == &quot;Disabled&quot;] &lt;- 4
#
# san22e: Don&apos;t know
#
san22e &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san22e[sanitationUse[,1] == &quot;Don&apos;t know&quot; | sanitationUse[,2] == &quot;Don&apos;t know&quot;] &lt;- 1
#
#
#
san22 &lt;- data.frame(san22a, san22b, san22c, san22d, san22e)


################################################################################
#
# san23: do all household members usually use the available sanitation facilities
#
################################################################################
#
#
#
san23 &lt;- ifelse(surveyData$san59 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$san59)
san23 &lt;- ifelse(san23 == &quot;Yes&quot;, 1,
	ifelse(san23 == &quot;No&quot;, 0, NA))


################################################################################
#
# san24: who is not using sanitation facilities
#
################################################################################
#
#
#
sanitationUsage &lt;- ifelse(surveyData$san61 == &quot;&quot;, &quot;Don&apos;t know&quot;,
	ifelse(surveyData$san61 == &quot;Other (please specify)&quot;, surveyData$san62, surveyData$san61))
sanitationUsage &lt;- str_split(string = sanitationUsage, pattern = &quot;, &quot;, simplify = TRUE)
sanitationUsage[,1] &lt;- ifelse(sanitationUsage[,1] == &quot;Other (please specify)&quot;, surveyData$san62, sanitationUsage[,1])
sanitationUsage[,2] &lt;- ifelse(sanitationUsage[,2] == &quot;Other (please specify)&quot;, surveyData$san62, sanitationUsage[,2])
sanitationUsage[,1] &lt;- ifelse(sanitationUsage[,1] == &quot;Disable&quot;, &quot;Disabled&quot;, sanitationUsage[,1])
sanitationUsage[,2] &lt;- ifelse(sanitationUsage[,2] == &quot;Disable&quot;, &quot;Disabled&quot;, sanitationUsage[,2])
#
# san24a: Children
#
san24a &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san24a[sanitationUsage[,1] == &quot;Children&quot; | sanitationUsage[,2] == &quot;Children&quot;] &lt;- 1
#
# san24b: Elderly family members
#
san24b &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san24b[sanitationUsage[,1] == &quot;Elderly family members&quot; | sanitationUsage[,2] == &quot;Elderly family members&quot;] &lt;- 2
#
# san24c: Husband
#
san24c &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san24c[sanitationUsage[,1] == &quot;Husband&quot; | sanitationUsage[,2] == &quot;Husband&quot;] &lt;- 3
#
# san24d: Disabled
#
san24d &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san24d[sanitationUsage[,1] == &quot;Disabled&quot; | sanitationUsage[,2] == &quot;Disabled&quot;] &lt;- 4
#
# san24e: Don&apos;t know
#
san24e &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san24e[sanitationUsage[,1] == &quot;Don&apos;t know&quot; | sanitationUsage[,2] == &quot;Don&apos;t know&quot;] &lt;- 1
#
#
#
san24 &lt;- data.frame(san24a, san24b, san24c, san24d, san24e) 


################################################################################
#
# san25: problem with sanitation facility
#
################################################################################
#
# san25:
#
san25 &lt;- ifelse(surveyData$san66 == &quot;&quot;, &quot;Don&apos;t know&quot;, 
	ifelse(surveyData$san66 == &quot;Other (please specify)&quot;, surveyData$san67, surveyData$san66))
san25 &lt;- ifelse(san25 == &quot;&quot;, &quot;Don&apos;t know&quot;, san25)
#
# Clean-up
#
san25 &lt;- ifelse(san25 %in% c(&quot;Call sweeper by own intiative &quot;, &quot;Do work by calling sweeper&quot;), &quot;Call sweeper by own intiative&quot;,
	ifelse(san25 == &quot;Manager &quot;, &quot;Manager&quot;,
		ifelse(san25 == &quot;Quarter inside university, so the relevant person of university&quot;, &quot;Responsible university staff&quot;, san25)))

################################################################################
#
# san26: feel safe with sanitation facility
#
################################################################################
#
#
#
san26 &lt;- ifelse(surveyData$san70 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san27: feel safe using facility during menstruation
#
################################################################################
#
#
#
san27 &lt;- ifelse(surveyData$san74 == &quot;Yes&quot;, 1,
	ifelse(surveyData$san74 == &quot;No&quot;, 0, NA))


################################################################################
#
# san28: material used for menstruation
#
################################################################################
#
#
#
san28 &lt;- ifelse(surveyData$san79 == &quot;&quot;, &quot;Don&apos;t know&quot;,
	ifelse(surveyData$san79 == &quot;Other (please specify)&quot;, surveyData$san80, surveyData$san79))
san28 &lt;- ifelse(san28 == &quot;&quot;, &quot;Don&apos;t know&quot;, san28)
#
# Clean-up - report as NA those who report not having a period/no need
#
san28 &lt;- ifelse(san28 %in% c(&quot;Cycle did not resume after birth&quot;, &quot;Menstrual cycle stopped&quot;, &quot;None aged of cycle&quot;, &quot;Pragnent&quot;, &quot;Ovary removed&quot;), NA,
	ifelse(san28 == &quot;Tissu paper&quot;, &quot;Tissue paper&quot;, san28))


################################################################################
#
# san29: how is menstrual cloth washed
#
################################################################################
#
#
#
san29 &lt;- ifelse(surveyData$san81 == &quot;&quot;, NA,
	ifelse(surveyData$san81 == &quot;Other (please specify)&quot;, surveyData$san82, surveyData$san81))


################################################################################
#
# san30: where is napkin pads disposed of?
#
################################################################################
#
#
#
san30 &lt;- ifelse(surveyData$san83 == &quot;&quot;, NA,
	ifelse(surveyData$san83 == &quot;Other (please specify)&quot;, surveyData$san84, surveyData$san83))
#
# Clean-up
#
san30 &lt;- ifelse(san30 %in% c(&quot;Garbage  basket&quot;, &quot;Garbage basket in the sanitation facility&quot;, &quot;Garbage disposal&quot;, &quot;Under the soil by making ditch&quot;), &quot;Garbage disposal&quot;,
	ifelse(san30 == &quot;Water body (Khal/Jhill)&quot;, &quot;Water body (lake/river/pond)&quot;,
		ifelse(san30 %in% c(&quot;Menstrual cycle stopped&quot;, &quot;Pragnent&quot;), NA, san30)))


################################################################################
#
# san31: when should you wash hands?
#
################################################################################
#
# washEvents
#
washEvents &lt;- ifelse(surveyData$san85 == &quot;&quot;, &quot;Don&apos;t know&quot;,
	ifelse(surveyData$san85 == &quot;Other (please specify)&quot;, surveyData$san86, surveyData$san85))
washEvents &lt;- str_split(string = washEvents, pattern = &quot;, &quot;, simplify = TRUE)
washEvents[,1] &lt;- ifelse(washEvents[,1] == &quot;Other (please specify)&quot;, surveyData$san86, washEvents[,1])
washEvents[,2] &lt;- ifelse(washEvents[,2] == &quot;Other (please specify)&quot;, surveyData$san86, washEvents[,2])
washEvents[,3] &lt;- ifelse(washEvents[,3] == &quot;Other (please specify)&quot;, surveyData$san86, washEvents[,3])
washEvents[,4] &lt;- ifelse(washEvents[,4] == &quot;Other (please specify)&quot;, surveyData$san86, washEvents[,4])
washEvents[,5] &lt;- ifelse(washEvents[,5] == &quot;Other (please specify)&quot;, surveyData$san86, washEvents[,5])
washEvents[,6] &lt;- ifelse(washEvents[,6] == &quot;Other (please specify)&quot;, surveyData$san86, washEvents[,6])
washEvents[,7] &lt;- ifelse(washEvents[,7] == &quot;Other (please specify)&quot;, surveyData$san86, washEvents[,7])


################################################################################
#
# san32: households with handwashing facility with soap and water at home
#
################################################################################
#
# san 32
#
san32 &lt;- ifelse(surveyData$san88 == &quot;Handwashing station with clean water and soap available&quot;, 1, 0)


################################################################################
#
# san33: how often is septic tank emptied
#
################################################################################
#
# san33
#
san33 &lt;- ifelse(surveyData$san90 == &quot;Other (please specify)&quot;, surveyData$san91,
	ifelse(surveyData$san90 == &quot;&quot; &amp; surveyData$san92 == TRUE, &quot;Not applicable&quot;,
		ifelse(surveyData$san90 == &quot;&quot; &amp; surveyData$san93 == TRUE, &quot;Don&apos;t know&quot;, surveyData$san90)))
#
# clean-up
#
san33 &lt;- ifelse(san33 %in% c(&quot;Before 5 moths&quot;, &quot;Before 6 moths&quot;, &quot;Nine years.&quot;, &quot;Three years&quot;), &quot;Don&apos;t know&quot;,
	ifelse(san33 %in% c(&quot;Did not empty till now&quot;, &quot;Have never emptied it before&quot;, &quot;new house&quot;), &quot;Have never emptied it before&quot;,
		ifelse(san33 %in% c(&quot;Stool go to pond&quot;, &quot;Stool go to the cannal&quot;), &quot;Not applicable&quot;, san33)))


################################################################################
#
# san34: cost of empyting tank
#
################################################################################
#
# san34
#
san34 &lt;- ifelse(surveyData$san94 == &quot;&quot;, NA, surveyData$san94)


################################################################################
#
# san35: who empties pit
#
################################################################################
#
# san35
#
san35 &lt;- ifelse(surveyData$san98 == &quot;&quot;, &quot;Don&apos;t know/not applicable&quot;,
	ifelse(surveyData$san98 == &quot;Other (please specify)&quot;, surveyData$san99, surveyData$san98))
#
# Clean-up
#
san35 &lt;- ifelse(san35 == &quot;House owner &quot;, &quot;House owner&quot;,
	ifelse(san35 == &quot;Sweeper &quot;, &quot;Sweeper&quot;,
		ifelse(san35 == &quot;By own&quot;, &quot;Family member or informal manual emptier&quot;, san35)))


################################################################################
#
# san36: who pays for pit to be emptied
#
################################################################################
#
# san36
#
san36 &lt;- ifelse(surveyData$san102 == &quot;&quot;, &quot;Don&apos;t know/not applicable&quot;,
	ifelse(surveyData$san102 == &quot;Other (please specify)&quot;, surveyData$san103, surveyData$san102))
#
# Clean-up
#
san36 &lt;- ifelse(san36 == &quot;Water and Sanitation Authority  (WASHA)&quot;, &quot;Water and Sanitation Authority (WASHA)&quot;,
	ifelse(san36 == &quot;City corporation &quot;, &quot;City corporation&quot;,
		ifelse(san36 == &quot;Owner of house &quot;, &quot;Owner of house&quot;, san36)))


################################################################################
#
# san37: satisfaction with pit emptying service
#
################################################################################
#
# san37
#
san37 &lt;- ifelse(surveyData$san106 == &quot;&quot;, NA,
	ifelse(surveyData$san106 == &quot;Yes&quot;, 1, 0))


################################################################################
#
# JMP Post-2015 sanitation indicators
#
################################################################################
#
# jmpSan1: open defecation
#
jmpSan1 &lt;- ifelse(san3 == &quot;No facilities or bush or field or lake or pond&quot;, 1, 0)
#
# jmpSan2: unimproved sanitation facilities
#
jmpSan2 &lt;- ifelse(san3 %in% c(&quot;Hanging toilet/hanging latrine&quot;,
	&quot;Pit latrine without slab/open pit&quot;,
	&quot;Ring and slab without pit latrine&quot;), 1, 0)

#
# jmpSan3: shared improved sanitation facility
#
jmpSan3 &lt;- ifelse(san3 %in% c(&quot;Flush/pour flush&quot;, &quot;Pit latrine with slab or ventilated improved pit latrine (VIP)&quot;) &amp;
	san4 != &quot;Open drain / ditch / water body&quot; &amp;
	san1a == 1, 1, 0)
#
# jmpSan4: improved sanitation facility
#
jmpSan4 &lt;- ifelse(san3 %in% c(&quot;Flush/pour flush&quot;, &quot;Pit latrine with slab or ventilated improved pit latrine (VIP)&quot;) &amp;
	san4 != &quot;Open drain / ditch / water body&quot; &amp;
	san1a == 0, 1, 0)
#
# jmpSan5: safely managed
#                  


################################################################################
#
# Create sanDF
#
################################################################################
#
# Concatenate sanitation indicators
#
sanDF &lt;- data.frame(&quot;uniqueID&quot; = surveyData[ , &quot;uniqueID&quot;], &quot;psu&quot; = surveyData[ , &quot;psu&quot;],
	san1, san1a, san2, san2a, san3, san4, san5, san6, san7, san8,
	san9, san10, san11, san12, san13, san14, san15, san16, san17,
	san18, san19, san20, san21, san22, san23, san24, san25, san26,
	san27, san28, san29, san30, san32, san33, san34, san35,
	san36, san37,
	jmpSan1, jmpSan2, jmpSan3, jmpSan4)
#
# Clean-up
#
rm(san1, san1a, san2, san2a, san3, san4, san5, san6, san7, san8, san9, san10, 
	san11, san12, san13, san14, san15, san16, san17, san18, san19, san20, san21, 
	san22, san23, san24, san25, san26, san27, san28, san29, san30, san32, 
	san33, san34, san35, san36, san37)



################################################################################
#
# Create master data
#
################################################################################
#
# Merge all data.frames
#
temp &lt;- merge(admin, demoDF, by = &quot;uniqueID&quot;)
temp &lt;- merge(temp, pPoverty, by = &quot;uniqueID&quot;)
temp &lt;- merge(temp, waterDF, by = &quot;uniqueID&quot;)
indicatorsDF &lt;- merge(temp, sanDF)
#
# Save indicators dataset 
#
write.csv(x = indicatorsDF,
	     file = paste(&quot;data/indicatorsData&quot;, unique(ccode), &quot;.csv&quot;, sep = &quot;&quot;),
	     row.names = FALSE)

	     
</command>
							<property title="Indicators" shape="TRANSFORM"/>
							<option type="com.ef_prime.rflow.node.base.SubflowNodeModel">
								<subflow>
									<graph version="0.8" width="1651" height="513" locationtype="a" offsetx="100" offsety="50">
										<node id="54" date="1510899095243" uid="2e9eaf7dfa4e7768" x="300" y="120">
											<command>
################################################################################
#
# Create master data
#
################################################################################
#
# Merge all data.frames
#
temp &lt;- merge(admin, demoDF, by = &quot;uniqueID&quot;)
temp &lt;- merge(temp, pPoverty, by = &quot;uniqueID&quot;)
temp &lt;- merge(temp, waterDF, by = &quot;uniqueID&quot;)
indicatorsDF &lt;- merge(temp, sanDF)
#
# Save indicators dataset 
#
write.csv(x = indicatorsDF,
	     file = paste(&quot;data/indicatorsData&quot;, unique(ccode), &quot;.csv&quot;, sep = &quot;&quot;),
	     row.names = FALSE)

	     </command>
											<property title="Concatenate" shape="SUMMARY"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<node id="55" date="1510899095243" uid="64e82a5b4f20498" x="140" y="40">
											<command>
################################################################################
#
# Admin data
#
################################################################################
#
# Extract identifier data
#
adminDF &lt;- surveyData[ , c(&quot;country&quot;, &quot;ccode&quot;, &quot;uniqueID&quot;, &quot;psu&quot;, 
	&quot;zone&quot;, &quot;type&quot;, &quot;quadrat&quot;, &quot;hhid&quot;, 
	&quot;longitude&quot;, &quot;latitude&quot;)]

</command>
											<property title="Admin" shape="TRANSFORM"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<node id="56" date="1510899093942" uid="9770a9b64904425a" x="300" y="40">
											<command>

################################################################################
#
# Sanitation indicators 
#
################################################################################

################################################################################
#
# san1: shared sanitation facility - user arrangements.
#
################################################################################
#
#
#
san1 &lt;- ifelse(surveyData$san1 == &quot;&quot;, &quot;Don&apos;t know&quot;,
	ifelse(surveyData$san1 == &quot;Other (please specify)&quot;, surveyData$san2, surveyData$san1))
#
# Clean-up
#
san1 &lt;- ifelse(san1 == &quot;Communal / shared toilet &quot;, &quot;Communal / shared toilet&quot;, san1)
#
# san1a: is toilet facility shared with other households
#
san1a &lt;- ifelse(san1 == &quot;Household toilet&quot;, 0, 1)


################################################################################
#
# san2: Number of people who share toilet facilities 
#
################################################################################
#
# san2: Mean number of people who share toilet facilities
#
san2 &lt;- ifelse(is.na(surveyData$san4), 0, surveyData$san4)
#
# san2a: shared toilet facility 
#
san2a &lt;- ifelse(san2 == 0, 0, 1)


################################################################################
#
# san3: type of facility
#
################################################################################
#
# san3: type  of facility
#
san3 &lt;- ifelse(surveyData$san6 == &quot;Other (please specify)&quot;, surveyData$san7, surveyData$san6)
#
# clean-up
#
san3 &lt;- ifelse(san3 %in% c(&quot;Drain&quot;, &quot;Drain connected with waterbody&quot;, 
	&quot;Drain with water body (Jhill)&quot;, &quot;Open drain&quot;), &quot;Drain&quot;,
ifelse(san3 %in% c(&quot;In water body (Jhill)&quot;, 
	&quot;Lake&quot;, &quot;Pond&quot;,
	&quot;No facilities or bush or field&quot;), &quot;No facilities or bush or field or lake or pond&quot;,
ifelse(san3 %in% c(&quot;Ditch with ring&quot;, &quot;Ring and slub&quot;, &quot;Slub and in the bottom drain&quot;), &quot;Ring and slab without pit latrine&quot;, san3)))


################################################################################
#
# san4: where effluent flushes to
#
################################################################################
#
# san4: where effluent flushes to
#
san4 &lt;- ifelse(surveyData$san9 == &quot;&quot;, &quot;Don&apos;t know&quot;,
	ifelse(surveyData$san9 == &quot;Other (please specify)&quot;, surveyData$san10, surveyData$san9))
#
# clean-up
#
san4 &lt;- ifelse(san4 %in% c(&quot;Open drain&quot;, &quot;Adjacent to pond&quot;, &quot;Ditch&quot;, &quot;Ditch &quot;,
	&quot;pond&quot;, &quot;River&quot;, &quot;Water body (Cannel)&quot;), &quot;Open drain/ditch/water body&quot;, 
ifelse(san4 == &quot;Tanki&quot;, &quot;Septic tank&quot;, san4))


################################################################################
#
# san5: WSUP-supported facility
#
################################################################################
#
# san5: WSUP-supported facility
#
san5 &lt;- ifelse(surveyData$san12 == &quot;&quot; &amp; surveyData$san13 == &quot;TRUE&quot;, &quot;Not applicable&quot;,
	ifelse(surveyData$san12 == &quot;&quot; &amp; surveyData$san14 == &quot;TRUE&quot;, &quot;Don&apos;t know&quot;, surveyData$san12))
#
# re-code
#
san5 &lt;- ifelse(san5 == &quot;Yes&quot;, 1,
	ifelse(san5 == &quot;No&quot;, 0, NA))


################################################################################
#
# san6: water in facility
#
#################################################################################
#
# san6: water in facility (Yes / No)
#
san6 &lt;- ifelse(surveyData$san15 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san7: satisfied with handwashing facility
#
################################################################################
#
# san7: satisfied with handwashing facility
#
san7 &lt;- ifelse(surveyData$san17 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san8: what would increase your satisfaction
#
################################################################################
#
# Re-code
#
sanSatisfaction &lt;- ifelse(surveyData$san19 == &quot;Other (please specify)&quot;, surveyData$san20, surveyData$san19)
sanSatisfaction &lt;- ifelse(sanSatisfaction == &quot;&quot;, &quot;Don&apos;t know/no answer/not applicable&quot;, sanSatisfaction)
sanSatisfaction &lt;- str_split(string = sanSatisfaction, pattern = &quot;, &quot;, simplify = TRUE)
sanSatisfaction[,1] &lt;- ifelse(sanSatisfaction[,1] == &quot;Other (please specify)&quot;, surveyData$san20, sanSatisfaction[,1]) 
sanSatisfaction[,2] &lt;- ifelse(sanSatisfaction[,2] == &quot;Other (please specify)&quot;, surveyData$san20, sanSatisfaction[,2])
sanSatisfaction[,3] &lt;- ifelse(sanSatisfaction[,3] == &quot;Other (please specify)&quot;, surveyData$san20, sanSatisfaction[,3])
sanSatisfaction[,4] &lt;- ifelse(sanSatisfaction[,4] == &quot;Other (please specify)&quot;, surveyData$san20, sanSatisfaction[,4])
#
# san8a: Availability of soap
#
san8a &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san8a[sanSatisfaction[,1] == &quot;Availability of soap&quot; |
	sanSatisfaction[,2] == &quot;Availability of soap&quot; |
	sanSatisfaction[,3] == &quot;Availability of soap&quot; |
	sanSatisfaction[,4] == &quot;Availability of soap&quot;] &lt;- 1
#
# san8b: Availability of washbasin
#
san8b &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san8b[sanSatisfaction[,1] == &quot;Availability of washbasin&quot; |
	sanSatisfaction[,2] == &quot;Availability of washbasin&quot; |
	sanSatisfaction[,3] == &quot;Availability of washbasin&quot; |
	sanSatisfaction[,4] == &quot;Availability of washbasin&quot;] &lt;- 2
#
# san8c: Cleaner water
#
san8c &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san8c[sanSatisfaction[,1] == &quot;Cleaner water&quot; |
	sanSatisfaction[,2] == &quot;Cleaner water&quot; |
	sanSatisfaction[,3] == &quot;Cleaner water&quot; |
	sanSatisfaction[,4] == &quot;Cleaner water&quot;] &lt;- 3
#
# san8d: Cleaner water
#
san8d &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san8d[sanSatisfaction[,1] == &quot;More water&quot; |
	sanSatisfaction[,2] == &quot;More water&quot; |
	sanSatisfaction[,3] == &quot;More water&quot; |
	sanSatisfaction[,4] == &quot;More water&quot;] &lt;- 4
#
# san8e: Supply water in latrine
#
san8e &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san8e[sanSatisfaction[,1] == &quot;Supply water in latrine&quot; |
	sanSatisfaction[,2] == &quot;Supply water in latrine&quot; |
	sanSatisfaction[,3] == &quot;Supply water in latrine&quot; |
	sanSatisfaction[,4] == &quot;Supply water in latrine&quot;] &lt;- 5
#
# san8f: water arrangement in latrine
#
san8f &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san8f[sanSatisfaction[,1] == &quot;Water arrangement in toilet&quot; |
	sanSatisfaction[,2] == &quot;Water arrangement in toilet&quot; |
	sanSatisfaction[,3] == &quot;Water arrangement in toilet&quot; |
	sanSatisfaction[,4] == &quot;Water arrangement in toilet&quot;] &lt;- 6
#
# san8g: sanitary latrine
#
san8g &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san8g[sanSatisfaction[,1] == &quot;Sanitary latrine&quot; |
	sanSatisfaction[,2] == &quot;Sanitary latrine&quot; |
	sanSatisfaction[,3] == &quot;Sanitary latrine&quot; |
	sanSatisfaction[,4] == &quot;Sanitary latrine&quot;] &lt;- 7
#
# san8h: Don&apos;t know/no answer/not applicable
#
san8h &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san8h[sanSatisfaction[,1] == &quot;Don&apos;t know/no answer/not applicable&quot; |
	sanSatisfaction[,2] == &quot;Don&apos;t know/no answer/not applicable&quot; |
	sanSatisfaction[,3] == &quot;Don&apos;t know/no answer/not applicable&quot; |
	sanSatisfaction[,4] == &quot;Don&apos;t know/no answer/not applicable&quot;] &lt;- 8
#
# concatenate into data.frame
#
san8 &lt;- data.frame(san8a, san8b, san8c, san8d, san8e, san8f, san8g, san8h)


################################################################################
#
# san9: lights in toilet facility
#
################################################################################
#
# san9: lights in toilet facility
#
san9 &lt;- ifelse(surveyData$san22 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san10: toilet facility with lockable door
#
################################################################################
#
# san10: lockable door
#
san10 &lt;- ifelse(surveyData$san24 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san11: container for menstrual hygiene management
#
################################################################################
#
# san11: container for menstrual hygiene management
#
san11 &lt;- ifelse(surveyData$san26 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san12: Sanitary disposal of child&apos;s faeces
#
################################################################################
#
# san12: sanitary disposal of child&apos;s faeces
#
san12 &lt;- ifelse(surveyData$san28 %in% c(&quot;Child used toilet/latrine&quot;, 
	&quot;Put/rinsed into the toilet&quot;), 1, 0)


################################################################################
#
# san13: Waiting time to use the toilet
#
################################################################################
#
# san13: Waiting time to use the toilet
#
san13 &lt;- ifelse(is.na(surveyData$san31), 0, surveyData$san31)


################################################################################
#
# san14: spend on sanitation facility
#
################################################################################
#
# san14: spend on sanitation facility
#
san14 &lt;- ifelse(is.na(surveyData$san33), 0, surveyData$san33)


################################################################################
#
# san15: satisfied with spend
#
################################################################################
#
# san15: satisfied with spend
#
san15 &lt;- ifelse(surveyData$san36 == &quot;&quot;, NA,
	ifelse(surveyData$san36 == &quot;Yes&quot;, 1, 0))


################################################################################
#
# san16: initial investment in toilet facility
#
################################################################################
#
# san16: initial investment in toilet facility
#
san16 &lt;- ifelse(surveyData$san38 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san17: amount of investment
#
################################################################################
#
# san17: amount of investment
#
san17 &lt;- ifelse(is.na(surveyData$san40), 0, surveyData$san40)


################################################################################
#
# san18: willingness to invest
#
################################################################################
#
# san18: willingness to invest
#
san18 &lt;- ifelse(surveyData$san43 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san19: satisfied with cleanliness
#
################################################################################
#
# san19: satisfied with cleanliness
#
san19 &lt;- ifelse(surveyData$san46 == &quot;Yes&quot;, 1,
	ifelse(surveyData$san46 == &quot;No&quot;, 0, NA))


################################################################################
#
# san20: increase satisfaction
#
################################################################################
#
# Re-code
#
cleanSatisfaction &lt;- ifelse(surveyData$san48 == &quot;Other (please specify)&quot;, surveyData$san49, surveyData$san48)
cleanSatisfaction &lt;- ifelse(cleanSatisfaction == &quot;&quot;, &quot;Don&apos;t know/no answer/not applicable&quot;, cleanSatisfaction)
cleanSatisfaction &lt;- str_split(string = cleanSatisfaction, pattern = &quot;, &quot;, simplify = TRUE)
cleanSatisfaction[,1] &lt;- ifelse(cleanSatisfaction[,1] == &quot;Other (please specify)&quot;, surveyData$san49, cleanSatisfaction[,1]) 
cleanSatisfaction[,2] &lt;- ifelse(cleanSatisfaction[,2] == &quot;Other (please specify)&quot;, surveyData$san49, cleanSatisfaction[,2])
cleanSatisfaction[,3] &lt;- ifelse(cleanSatisfaction[,3] == &quot;Other (please specify)&quot;, surveyData$san49, cleanSatisfaction[,3])
cleanSatisfaction[,4] &lt;- ifelse(cleanSatisfaction[,4] == &quot;Other (please specify)&quot;, surveyData$san49, cleanSatisfaction[,4])
cleanSatisfaction[,1] &lt;- ifelse(cleanSatisfaction[,1] == &quot;Increased availability of water next tothe sanitation facility&quot;, &quot;Increased availability of water next to the sanitation facility&quot;, cleanSatisfaction[,1]) 
cleanSatisfaction[,2] &lt;- ifelse(cleanSatisfaction[,2] == &quot;Increased availability of water next tothe sanitation facility&quot;, &quot;Increased availability of water next to the sanitation facility&quot;, cleanSatisfaction[,2])
cleanSatisfaction[,3] &lt;- ifelse(cleanSatisfaction[,3] == &quot;Increased availability of water next tothe sanitation facility&quot;, &quot;Increased availability of water next to the sanitation facility&quot;, cleanSatisfaction[,3])
cleanSatisfaction[,4] &lt;- ifelse(cleanSatisfaction[,4] == &quot;Increased availability of water next tothe sanitation facility&quot;, &quot;Increased availability of water next to the sanitation facility&quot;, cleanSatisfaction[,4])
cleanSatisfaction[,1] &lt;- ifelse(cleanSatisfaction[,1] == &quot;Slub and ring larine&quot;, &quot;Ring and slab latrine&quot;, cleanSatisfaction[,1]) 
cleanSatisfaction[,2] &lt;- ifelse(cleanSatisfaction[,2] == &quot;Slub and ring larine&quot;, &quot;Ring and slab latrine&quot;, cleanSatisfaction[,2])
cleanSatisfaction[,3] &lt;- ifelse(cleanSatisfaction[,3] == &quot;Slub and ring larine&quot;, &quot;Ring and slab latrine&quot;, cleanSatisfaction[,3])
cleanSatisfaction[,4] &lt;- ifelse(cleanSatisfaction[,4] == &quot;Slub and ring larine&quot;, &quot;Ring and slab latrine&quot;, cleanSatisfaction[,4])
#
# san20a: Increased availability of bins
#
san20a &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san20a[cleanSatisfaction[,1] == &quot;Increased availability of bins&quot; |
	cleanSatisfaction[,2] == &quot;Increased availability of bins&quot; |
	cleanSatisfaction[,3] == &quot;Increased availability of bins&quot; |
	cleanSatisfaction[,4] == &quot;Increased availability of bins&quot;] &lt;- 1
#
# san20b: Increased availability of water next to the sanitation facility
# 
san20b &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san20b[cleanSatisfaction[,1] == &quot;Increased availability of water next to the sanitation facility&quot; |
	cleanSatisfaction[,2] == &quot;Increased availability of water next to the sanitation facility&quot; |
	cleanSatisfaction[,3] == &quot;Increased availability of water next to the sanitation facility&quot; |
	cleanSatisfaction[,4] == &quot;Increased availability of water next to the sanitation facility&quot;] &lt;- 2
#
# san20c: Increased availability or affordability of cleaning products
#
san20c &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san20c[cleanSatisfaction[,1] == &quot;Increased availability or affordability of cleaning products&quot; |
	cleanSatisfaction[,2] == &quot;Increased availability or affordability of cleaning products&quot; |
	cleanSatisfaction[,3] == &quot;Increased availability or affordability of cleaning products&quot; |
	cleanSatisfaction[,4] == &quot;Increased availability or affordability of cleaning products&quot;] &lt;- 3
#
# san20d: Increased cleaning frequency
#
san20d &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san20d[cleanSatisfaction[,1] == &quot;Increased cleaning frequency&quot; |
	cleanSatisfaction[,2] == &quot;Increased cleaning frequency&quot; |
	cleanSatisfaction[,3] == &quot;Increased cleaning frequency&quot; |
	cleanSatisfaction[,4] == &quot;Increased cleaning frequency&quot;] &lt;- 4
#
# san20e: Ring and slab latrine
#
san20e &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san20e[cleanSatisfaction[,1] == &quot;Ring and slab latrine&quot; |
	cleanSatisfaction[,2] == &quot;Ring and slab latrine&quot; |
	cleanSatisfaction[,3] == &quot;Ring and slab latrine&quot; |
	cleanSatisfaction[,4] == &quot;Ring and slab latrine&quot;] &lt;- 5
#
# san20f: Supply water at latrine
#
san20f &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san20f[cleanSatisfaction[,1] == &quot;Supply water at latrine&quot; |
	cleanSatisfaction[,2] == &quot;Supply water at latrine&quot; |
	cleanSatisfaction[,3] == &quot;Supply water at latrine&quot; |
	cleanSatisfaction[,4] == &quot;Supply water at latrine&quot;] &lt;- 6
#
# san20g: Latrine close to house
#
san20g &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san20g[cleanSatisfaction[,1] == &quot;Latrine close to house&quot; |
	cleanSatisfaction[,2] == &quot;Latrine close to house&quot; |
	cleanSatisfaction[,3] == &quot;Latrine close to house&quot; |
	cleanSatisfaction[,4] == &quot;Latrine close to house&quot;] &lt;- 7
#
# san20h: Don&apos;t know/no answer/not applicable
#
san20h &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san20h[cleanSatisfaction[,1] == &quot;Don&apos;t know/no answer/not applicable&quot; |
	cleanSatisfaction[,2] == &quot;Don&apos;t know/no answer/not applicable&quot; |
	cleanSatisfaction[,3] == &quot;Don&apos;t know/no answer/not applicable&quot; |
	cleanSatisfaction[,4] == &quot;Don&apos;t know/no answer/not applicable&quot;] &lt;- 8
#
# san20
#
san20 &lt;- data.frame(san20a, san20b, san20c, san20d, san20e, san20f, san20g, san20h)


################################################################################
#
# san21: Everyone in household able to get to sanitation facility?
#
################################################################################
#
# san21: everyone in household able to get to sanitation facility
#
san21 &lt;- ifelse(surveyData$san51 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san22: who is not using the sanitation facility?
#
################################################################################
#
#
#
sanitationUse &lt;- ifelse(surveyData$san53 == &quot;&quot;, &quot;Don&apos;t know&quot;,
	ifelse(surveyData$san53 == &quot;Other (please specify)&quot;, surveyData$san54, surveyData$san53))
sanitationUse &lt;- str_split(string = sanitationUse, pattern = &quot;, &quot;, simplify = TRUE)
sanitationUse[,1] &lt;- ifelse(sanitationUse[,1] == &quot;Other (please specify)&quot;, surveyData$san54, sanitationUse[,1])
sanitationUse[,2] &lt;- ifelse(sanitationUse[,2] == &quot;Other (please specify)&quot;, surveyData$san54, sanitationUse[,2])
sanitationUse[,1] &lt;- ifelse(sanitationUse[,1] == &quot;Disable&quot;, &quot;Disabled&quot;, sanitationUse[,1])
sanitationUse[,2] &lt;- ifelse(sanitationUse[,2] == &quot;Disable&quot;, &quot;Disabled&quot;, sanitationUse[,2])
#
# san22a: Children
#
san22a &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san22a[sanitationUse[,1] == &quot;Children&quot; | sanitationUse[,2] == &quot;Children&quot;] &lt;- 1
#
# san22b: Elderly family members
#
san22b &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san22b[sanitationUse[,1] == &quot;Elderly family members&quot; | sanitationUse[,2] == &quot;Elderly family members&quot;] &lt;- 2
#
# san22c: Husband
#
san22c &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san22c[sanitationUse[,1] == &quot;Husband&quot; | sanitationUse[,2] == &quot;Husband&quot;] &lt;- 3
#
# san22d: Disabled
#
san22d &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san22d[sanitationUse[,1] == &quot;Disabled&quot; | sanitationUse[,2] == &quot;Disabled&quot;] &lt;- 4
#
# san22e: Don&apos;t know
#
san22e &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san22e[sanitationUse[,1] == &quot;Don&apos;t know&quot; | sanitationUse[,2] == &quot;Don&apos;t know&quot;] &lt;- 1
#
#
#
san22 &lt;- data.frame(san22a, san22b, san22c, san22d, san22e)


################################################################################
#
# san23: do all household members usually use the available sanitation facilities
#
################################################################################
#
#
#
san23 &lt;- ifelse(surveyData$san59 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$san59)
san23 &lt;- ifelse(san23 == &quot;Yes&quot;, 1,
	ifelse(san23 == &quot;No&quot;, 0, NA))


################################################################################
#
# san24: who is not using sanitation facilities
#
################################################################################
#
#
#
sanitationUsage &lt;- ifelse(surveyData$san61 == &quot;&quot;, &quot;Don&apos;t know&quot;,
	ifelse(surveyData$san61 == &quot;Other (please specify)&quot;, surveyData$san62, surveyData$san61))
sanitationUsage &lt;- str_split(string = sanitationUsage, pattern = &quot;, &quot;, simplify = TRUE)
sanitationUsage[,1] &lt;- ifelse(sanitationUsage[,1] == &quot;Other (please specify)&quot;, surveyData$san62, sanitationUsage[,1])
sanitationUsage[,2] &lt;- ifelse(sanitationUsage[,2] == &quot;Other (please specify)&quot;, surveyData$san62, sanitationUsage[,2])
sanitationUsage[,1] &lt;- ifelse(sanitationUsage[,1] == &quot;Disable&quot;, &quot;Disabled&quot;, sanitationUsage[,1])
sanitationUsage[,2] &lt;- ifelse(sanitationUsage[,2] == &quot;Disable&quot;, &quot;Disabled&quot;, sanitationUsage[,2])
#
# san24a: Children
#
san24a &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san24a[sanitationUsage[,1] == &quot;Children&quot; | sanitationUsage[,2] == &quot;Children&quot;] &lt;- 1
#
# san24b: Elderly family members
#
san24b &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san24b[sanitationUsage[,1] == &quot;Elderly family members&quot; | sanitationUsage[,2] == &quot;Elderly family members&quot;] &lt;- 2
#
# san24c: Husband
#
san24c &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san24c[sanitationUsage[,1] == &quot;Husband&quot; | sanitationUsage[,2] == &quot;Husband&quot;] &lt;- 3
#
# san24d: Disabled
#
san24d &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san24d[sanitationUsage[,1] == &quot;Disabled&quot; | sanitationUsage[,2] == &quot;Disabled&quot;] &lt;- 4
#
# san24e: Don&apos;t know
#
san24e &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
san24e[sanitationUsage[,1] == &quot;Don&apos;t know&quot; | sanitationUsage[,2] == &quot;Don&apos;t know&quot;] &lt;- 1
#
#
#
san24 &lt;- data.frame(san24a, san24b, san24c, san24d, san24e) 


################################################################################
#
# san25: problem with sanitation facility
#
################################################################################
#
# san25:
#
san25 &lt;- ifelse(surveyData$san66 == &quot;&quot;, &quot;Don&apos;t know&quot;, 
	ifelse(surveyData$san66 == &quot;Other (please specify)&quot;, surveyData$san67, surveyData$san66))
san25 &lt;- ifelse(san25 == &quot;&quot;, &quot;Don&apos;t know&quot;, san25)
#
# Clean-up
#
san25 &lt;- ifelse(san25 %in% c(&quot;Call sweeper by own intiative &quot;, &quot;Do work by calling sweeper&quot;), &quot;Call sweeper by own intiative&quot;,
	ifelse(san25 == &quot;Manager &quot;, &quot;Manager&quot;,
		ifelse(san25 == &quot;Quarter inside university, so the relevant person of university&quot;, &quot;Responsible university staff&quot;, san25)))

################################################################################
#
# san26: feel safe with sanitation facility
#
################################################################################
#
#
#
san26 &lt;- ifelse(surveyData$san70 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san27: feel safe using facility during menstruation
#
################################################################################
#
#
#
san27 &lt;- ifelse(surveyData$san74 == &quot;Yes&quot;, 1,
	ifelse(surveyData$san74 == &quot;No&quot;, 0, NA))


################################################################################
#
# san28: material used for menstruation
#
################################################################################
#
#
#
san28 &lt;- ifelse(surveyData$san79 == &quot;&quot;, &quot;Don&apos;t know&quot;,
	ifelse(surveyData$san79 == &quot;Other (please specify)&quot;, surveyData$san80, surveyData$san79))
san28 &lt;- ifelse(san28 == &quot;&quot;, &quot;Don&apos;t know&quot;, san28)
#
# Clean-up - report as NA those who report not having a period/no need
#
san28 &lt;- ifelse(san28 %in% c(&quot;Cycle did not resume after birth&quot;, &quot;Menstrual cycle stopped&quot;, &quot;None aged of cycle&quot;, &quot;Pragnent&quot;, &quot;Ovary removed&quot;), NA,
	ifelse(san28 == &quot;Tissu paper&quot;, &quot;Tissue paper&quot;, san28))


################################################################################
#
# san29: how is menstrual cloth washed
#
################################################################################
#
#
#
san29 &lt;- ifelse(surveyData$san81 == &quot;&quot;, NA,
	ifelse(surveyData$san81 == &quot;Other (please specify)&quot;, surveyData$san82, surveyData$san81))


################################################################################
#
# san30: where is napkin pads disposed of?
#
################################################################################
#
#
#
san30 &lt;- ifelse(surveyData$san83 == &quot;&quot;, NA,
	ifelse(surveyData$san83 == &quot;Other (please specify)&quot;, surveyData$san84, surveyData$san83))
#
# Clean-up
#
san30 &lt;- ifelse(san30 %in% c(&quot;Garbage  basket&quot;, &quot;Garbage basket in the sanitation facility&quot;, &quot;Garbage disposal&quot;, &quot;Under the soil by making ditch&quot;), &quot;Garbage disposal&quot;,
	ifelse(san30 == &quot;Water body (Khal/Jhill)&quot;, &quot;Water body (lake/river/pond)&quot;,
		ifelse(san30 %in% c(&quot;Menstrual cycle stopped&quot;, &quot;Pragnent&quot;), NA, san30)))


################################################################################
#
# san31: when should you wash hands?
#
################################################################################
#
# washEvents
#
washEvents &lt;- ifelse(surveyData$san85 == &quot;&quot;, &quot;Don&apos;t know&quot;,
	ifelse(surveyData$san85 == &quot;Other (please specify)&quot;, surveyData$san86, surveyData$san85))
washEvents &lt;- str_split(string = washEvents, pattern = &quot;, &quot;, simplify = TRUE)
washEvents[,1] &lt;- ifelse(washEvents[,1] == &quot;Other (please specify)&quot;, surveyData$san86, washEvents[,1])
washEvents[,2] &lt;- ifelse(washEvents[,2] == &quot;Other (please specify)&quot;, surveyData$san86, washEvents[,2])
washEvents[,3] &lt;- ifelse(washEvents[,3] == &quot;Other (please specify)&quot;, surveyData$san86, washEvents[,3])
washEvents[,4] &lt;- ifelse(washEvents[,4] == &quot;Other (please specify)&quot;, surveyData$san86, washEvents[,4])
washEvents[,5] &lt;- ifelse(washEvents[,5] == &quot;Other (please specify)&quot;, surveyData$san86, washEvents[,5])
washEvents[,6] &lt;- ifelse(washEvents[,6] == &quot;Other (please specify)&quot;, surveyData$san86, washEvents[,6])
washEvents[,7] &lt;- ifelse(washEvents[,7] == &quot;Other (please specify)&quot;, surveyData$san86, washEvents[,7])


################################################################################
#
# san32: households with handwashing facility with soap and water at home
#
################################################################################
#
# san 32
#
san32 &lt;- ifelse(surveyData$san88 == &quot;Handwashing station with clean water and soap available&quot;, 1, 0)


################################################################################
#
# san33: how often is septic tank emptied
#
################################################################################
#
# san33
#
san33 &lt;- ifelse(surveyData$san90 == &quot;Other (please specify)&quot;, surveyData$san91,
	ifelse(surveyData$san90 == &quot;&quot; &amp; surveyData$san92 == TRUE, &quot;Not applicable&quot;,
		ifelse(surveyData$san90 == &quot;&quot; &amp; surveyData$san93 == TRUE, &quot;Don&apos;t know&quot;, surveyData$san90)))
#
# clean-up
#
san33 &lt;- ifelse(san33 %in% c(&quot;Before 5 moths&quot;, &quot;Before 6 moths&quot;, &quot;Nine years.&quot;, &quot;Three years&quot;), &quot;Don&apos;t know&quot;,
	ifelse(san33 %in% c(&quot;Did not empty till now&quot;, &quot;Have never emptied it before&quot;, &quot;new house&quot;), &quot;Have never emptied it before&quot;,
		ifelse(san33 %in% c(&quot;Stool go to pond&quot;, &quot;Stool go to the cannal&quot;), &quot;Not applicable&quot;, san33)))


################################################################################
#
# san34: cost of empyting tank
#
################################################################################
#
# san34
#
san34 &lt;- ifelse(surveyData$san94 == &quot;&quot;, NA, surveyData$san94)


################################################################################
#
# san35: who empties pit
#
################################################################################
#
# san35
#
san35 &lt;- ifelse(surveyData$san98 == &quot;&quot;, &quot;Don&apos;t know/not applicable&quot;,
	ifelse(surveyData$san98 == &quot;Other (please specify)&quot;, surveyData$san99, surveyData$san98))
#
# Clean-up
#
san35 &lt;- ifelse(san35 == &quot;House owner &quot;, &quot;House owner&quot;,
	ifelse(san35 == &quot;Sweeper &quot;, &quot;Sweeper&quot;,
		ifelse(san35 == &quot;By own&quot;, &quot;Family member or informal manual emptier&quot;, san35)))


################################################################################
#
# san36: who pays for pit to be emptied
#
################################################################################
#
# san36
#
san36 &lt;- ifelse(surveyData$san102 == &quot;&quot;, &quot;Don&apos;t know/not applicable&quot;,
	ifelse(surveyData$san102 == &quot;Other (please specify)&quot;, surveyData$san103, surveyData$san102))
#
# Clean-up
#
san36 &lt;- ifelse(san36 == &quot;Water and Sanitation Authority  (WASHA)&quot;, &quot;Water and Sanitation Authority (WASHA)&quot;,
	ifelse(san36 == &quot;City corporation &quot;, &quot;City corporation&quot;,
		ifelse(san36 == &quot;Owner of house &quot;, &quot;Owner of house&quot;, san36)))


################################################################################
#
# san37: satisfaction with pit emptying service
#
################################################################################
#
# san37
#
san37 &lt;- ifelse(surveyData$san106 == &quot;&quot;, NA,
	ifelse(surveyData$san106 == &quot;Yes&quot;, 1, 0))


################################################################################
#
# JMP Post-2015 sanitation indicators
#
################################################################################
#
# jmpSan1: open defecation
#
jmpSan1 &lt;- ifelse(san3 == &quot;No facilities or bush or field or lake or pond&quot;, 1, 0)
#
# jmpSan2: unimproved sanitation facilities
#
jmpSan2 &lt;- ifelse(san3 %in% c(&quot;Hanging toilet/hanging latrine&quot;,
	&quot;Pit latrine without slab/open pit&quot;,
	&quot;Ring and slab without pit latrine&quot;), 1, 0)

#
# jmpSan3: shared improved sanitation facility
#
jmpSan3 &lt;- ifelse(san3 %in% c(&quot;Flush/pour flush&quot;, &quot;Pit latrine with slab or ventilated improved pit latrine (VIP)&quot;) &amp;
	san4 != &quot;Open drain / ditch / water body&quot; &amp;
	san1a == 1, 1, 0)
#
# jmpSan4: improved sanitation facility
#
jmpSan4 &lt;- ifelse(san3 %in% c(&quot;Flush/pour flush&quot;, &quot;Pit latrine with slab or ventilated improved pit latrine (VIP)&quot;) &amp;
	san4 != &quot;Open drain / ditch / water body&quot; &amp;
	san1a == 0, 1, 0)
#
# jmpSan5: safely managed
#                  


################################################################################
#
# Create sanDF
#
################################################################################
#
# Concatenate sanitation indicators
#
sanDF &lt;- data.frame(&quot;uniqueID&quot; = surveyData[ , &quot;uniqueID&quot;], &quot;psu&quot; = surveyData[ , &quot;psu&quot;],
	san1, san1a, san2, san2a, san3, san4, san5, san6, san7, san8,
	san9, san10, san11, san12, san13, san14, san15, san16, san17,
	san18, san19, san20, san21, san22, san23, san24, san25, san26,
	san27, san28, san29, san30, san32, san33, san34, san35,
	san36, san37,
	jmpSan1, jmpSan2, jmpSan3, jmpSan4)
#
# Clean-up
#
rm(san1, san1a, san2, san2a, san3, san4, san5, san6, san7, san8, san9, san10, 
	san11, san12, san13, san14, san15, san16, san17, san18, san19, san20, san21, 
	san22, san23, san24, san25, san26, san27, san28, san29, san30, san32, 
	san33, san34, san35, san36, san37)

</command>
											<property title="Sanitation" shape="TRANSFORM"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<node id="57" date="1510899095243" uid="bae927e3fb75b84" x="220" y="40">
											<command>
################################################################################
#
# Calculate indicators: Water
#
################################################################################
#
# waterSource: source of drinking water
#
waterSource &lt;- ifelse(surveyData$water1 == &quot;Other (please specify)&quot;, surveyData$water2, surveyData$water1)
waterSource &lt;- ifelse(waterSource == &quot;Deep tube well &quot;, &quot;Deep tube well&quot;, waterSource)
waterSource &lt;- ifelse(waterSource == &quot;Shallow tubwell&quot;, &quot;Shallow tube well&quot;, waterSource)
#
# water1: improved source of drinking water
#
water1 &lt;- ifelse(waterSource %in% c(&quot;Bottled water&quot;, &quot;Deep tube well&quot;,
	&quot;Piped water into dwelling&quot;, &quot;Piped water to yard/plot&quot;,
	&quot;Public tap/standpipe/kiosk&quot;, &quot;Water lifted by motor&quot;), 1, 0)
#
# water2: formal/informal source of drinking water for Pareto chart
#
water2 &lt;- ifelse(surveyData$water3 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water3)
#
# water2a: formal/informal source of drinking water for estimation
#
water2a &lt;- ifelse(surveyData$water3 == &quot;&quot;, NA,
	ifelse(surveyData$water3 == &quot;Formal&quot;, 1, 0))
#
# water3: source of water a WSUP-supported facility
#
water3 &lt;- ifelse(surveyData$water5 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water5)
#
# water3a: source of water a WSUP-supported facility estimation
#
water3a &lt;- ifelse(surveyData$water5 == &quot;&quot;, NA,
	ifelse(surveyData$water5 == &quot;Yes&quot;, 1, 0))
#
# water4: mean number of hours per day water is available
#
water4 &lt;- surveyData$water7
#
# water4a: water available at least 12 hours (half a day)
#
water4a &lt;- ifelse(surveyData$water7 &gt;= 12, 1, 0)
#
# water4b: water available for full day
#
water4b &lt;- ifelse(is.na(surveyData$water7), 0, 
	ifelse(surveyData$water7 == 24, 1, 0))
#
# water5: mean number of days per week water available
#
water5 &lt;- ifelse(surveyData$water9 == &quot;&quot;, NA,
	ifelse(surveyData$water9 == &quot;7 day per week&quot;, 7,
		ifelse(surveyData$water9 == &quot;6 day per week&quot;, 6,
			ifelse(surveyData$water9 == &quot;5 day per week&quot;, 5,
				ifelse(surveyData$water9 == &quot;4 day per week&quot;, 4,
					ifelse(surveyData$water9 == &quot;3 day per week&quot;, 3,
						ifelse(surveyData$water9 == &quot;2 day per week&quot;, 2,
							ifelse(surveyData$water9 == &quot;1 day per week&quot;, 1, 0))))))))
#
# water5a: water available more than 3 days a week
#
water5a &lt;- ifelse(water5 &gt; 3, 1, 0)
#
# water5b: water available the whole week
#
water5b &lt;- ifelse(is.na(water5), 0, 
	ifelse(water5 == 7, 1, 0))
#
# water6: water available for the whole year
#
water6 &lt;- ifelse(surveyData$water11 == &quot;&quot;, &quot;Don&apos;t know&quot;,
	ifelse(surveyData$water11 == &quot;Yes&quot;, &quot;Yes&quot;, &quot;No&quot;))
#
# water6a: water available for the whole year (estimation)
#
water6a &lt;- ifelse(surveyData$water11 == &quot;&quot;, 0,
	ifelse(surveyData$water11 == &quot;Yes&quot;, 1, 0))
#
# water7: mean number of minutes to collect water
#
water7 &lt;- ifelse(is.na(surveyData$water14), 0, surveyData$water14)
#
# water7a: distance to water source is within 30 minutes or less
#
water7a &lt;- ifelse(water7 &lt;= 30, 1, 0)
#
# water7b: satisfied with distance between home and water source
#
water7b &lt;- ifelse(surveyData$water16 == &quot;&quot;, 1,
	ifelse(surveyData$water16 == &quot;Yes&quot;, 1, 0))
#
# water7c: satisfied with distance between home and water source (estimate)
#
water7c &lt;- ifelse(water7b == 2, NA, water7b)
#
# water8: satisfied with queuing time
#
water8 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water8[surveyData$water18 == &quot;No&quot;] &lt;- 0
water8[surveyData$water18 == &quot;Yes&quot;] &lt;- 1
water8[surveyData$water18 == &quot;&quot; &amp; surveyData$water19 == TRUE] &lt;- 2
water8[surveyData$water18 == &quot;&quot; &amp; surveyData$water20 == TRUE] &lt;- 3
water8[is.na(surveyData$water18) &amp; is.na(surveyData$water19) &amp; is.na(surveyData$water20)] &lt;- 4
#
# water8a: satisfied with queuing time
#
water8a &lt;- ifelse(water8 %in% 2:4, NA, water8)

################################################################################
#
# water9: person who usually collects water
#
################################################################################
#
# waterCollect: person who usually collects water
#
waterCollect &lt;- ifelse(surveyData$water21 == &quot;Other (please specify)&quot;, surveyData$water22, surveyData$water21)
waterCollect &lt;- ifelse(waterCollect == &quot;&quot;, &quot;Don&apos;t know/no answer/not applicable&quot;, waterCollect)
waterCollect &lt;- str_split(string = waterCollect, pattern = &quot;, &quot;, simplify = TRUE)
#
# water9a: Adult men
#
water9a &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water9a[waterCollect[,1] == &quot;Adult men&quot; | 
	waterCollect[,2] == &quot;Adult men&quot; | 
	waterCollect[,3] == &quot;Adult men&quot; | 
	waterCollect[,4] == &quot;Adult men&quot;] &lt;- 1
#
# water9b: Adult women
#
water9b &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water9b[waterCollect[,1] == &quot;Adult women&quot; | 
	waterCollect[,2] == &quot;Adult women&quot; | 
	waterCollect[,3] == &quot;Adult women&quot; | 
	waterCollect[,4] == &quot;Adult women&quot;] &lt;- 2
#
# water9c: Boys _15
#
water9c &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water9c[waterCollect[,1] == &quot;Boys _15&quot; | 
	waterCollect[,2] == &quot;Boys _15&quot; | 
	waterCollect[,3] == &quot;Boys _15&quot; | 
	waterCollect[,4] == &quot;Boys _15&quot;] &lt;- 3
#
# water9d: Girls _15
#
water9d &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water9d[waterCollect[,1] == &quot;Girls _15&quot; | 
	waterCollect[,2] == &quot;Girls _15&quot; | 
	waterCollect[,3] == &quot;Girls _15&quot; | 
	waterCollect[,4] == &quot;Girls _15&quot;] &lt;- 4
#
# water9e: Whole family
#
water9e &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water9e[waterCollect[,1] == &quot;Whole family&quot; | 
	waterCollect[,2] == &quot;Whole family&quot; | 
	waterCollect[,3] == &quot;Whole family&quot; | 
	waterCollect[,4] == &quot;Whole family&quot;] &lt;- 5
#
# water9f: Pay someone outside the family to collect water
#
water9f &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water9f[waterCollect[,1] == &quot;Pay someone outside the family to collect water&quot; | 
	waterCollect[,2] == &quot;Pay someone outside the family to collect water&quot; | 
	waterCollect[,3] == &quot;Pay someone outside the family to collect water&quot; | 
	waterCollect[,4] == &quot;Pay someone outside the family to collect water&quot;] &lt;- 6
#
# water9g: Source inside house
#
water9g &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water9g[waterCollect[,1] == &quot;Source inside house&quot; | 
	waterCollect[,2] == &quot;Source inside house&quot; | 
	waterCollect[,3] == &quot;Source inside house&quot; | 
	waterCollect[,4] == &quot;Source inside house&quot;] &lt;- 7
#
# water9h: Don&apos;t know/no answer/not applicable
#
water9h &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water9h[waterCollect[,1] == &quot;Don&apos;t know/no answer/not applicable&quot; | 
	waterCollect[,2] == &quot;Don&apos;t know/no answer/not applicable&quot; | 
	waterCollect[,3] == &quot;Don&apos;t know/no answer/not applicable&quot; | 
	waterCollect[,4] == &quot;Don&apos;t know/no answer/not applicable&quot;] &lt;- 8
#
# Create vector of water collectors
#
water9 &lt;- data.frame(water9a, water9b, water9c, water9d, water9e, water9f, water9g, water9h)


################################################################################
#
# water10: amount of water used by household per day
#
################################################################################
#
# water10: amount of water (litres) used by household per day
#
water10 &lt;- ifelse(surveyData$water23 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water23)
#
# water10a: amount of water sufficient
#
water10a &lt;- ifelse(surveyData$water25 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water25)
#
# water10b: amount of water sufficient (estimate)
#
water10b &lt;- ifelse(water10a == &quot;Don&apos;t know&quot;, NA,
	ifelse(water10a == &quot;Yes&quot;, 1, 0))


################################################################################
#
# water11: water from other sources
#
################################################################################
#
#
#
water11 &lt;- ifelse(surveyData$water27 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water27)
#
#
#
water11a &lt;- ifelse(water11 == &quot;Don&apos;t know&quot;, NA,
	ifelse(water11 == &quot;Yes&quot;, 1, 0))
#
#
#
water11b &lt;- ifelse(surveyData$water29 == &quot;&quot;, NA,
	ifelse(surveyData$water29 == &quot;Other (please specify)&quot;, surveyData$water30, surveyData$water29))
#
#
#
water11b &lt;- ifelse(water11b == &quot;&quot;, NA, water11b)
water11b[water11b == &quot;Mosque&quot;] &lt;- &quot;Mosque, school, etc.&quot;
water11b[water11b %in% c(&quot;Neighbour&apos;s house&quot;, &quot;Pump point of water&quot;)] &lt;- &quot;Other&apos;s water point&quot;
water11b[water11b == &quot;Deep tube well&quot;] &lt;- &quot;Tube well&quot;
water11b[water11b == &quot;Cann&apos;t arranged&quot;] &lt;- &quot;Can&apos;t arrange&quot;
#
#
#
water11c &lt;- ifelse(water11b %in% c(&quot;Bottled water&quot;, &quot;Piped water into dwelling&quot;,
	&quot;Piped water to yard/plot&quot;, &quot;Protected well or spring in yard&quot;,
	&quot;Public tap/standpipe/kiosk&quot;, &quot;Tube well&quot;, &quot;Water lifted by motor&quot;), 1,
ifelse(is.na(water11b), 0, 0))
#
# 
#
water11d &lt;- ifelse(water1 == 1 &amp; water7a == 1 &amp; water4b == 1 &amp; water5b == 1 &amp; water6a == 1, 1,
	ifelse(water1 == 1 &amp; water7a == 1 &amp; ((water4b == 0 | water5b == 0 | water6a == 0) &amp; water11c == 1), 1, 0))


################################################################################
#
# water12: spend on water
#
################################################################################
#
# mean spend on water
#
water12 &lt;- ifelse(surveyData$water32 == &quot;&quot;, NA, surveyData$water32)
#
# satisfied with price of water
#
water12a &lt;- ifelse(surveyData$water35 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water35)
#
# satisfied with price of water - estimate
#
water12b &lt;- ifelse(water12a == &quot;Don&apos;t know&quot;, NA,
	ifelse(water12a == &quot;Yes&quot;, 1, 0))


################################################################################
#
# water13: investment in improving water source
#
################################################################################
#
# 
#
water13 &lt;- ifelse(surveyData$water37 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water37)
#
#
#
water13a &lt;- ifelse(water13 == &quot;Don&apos;t know&quot;, NA,
	ifelse(water13 == &quot;Yes&quot;, 1, 0))


################################################################################
#
# water14: water quality
#
################################################################################
#
#
#
water14 &lt;- ifelse(surveyData$water40 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water40)
#
#
#
water14a &lt;- ifelse(water14 == &quot;Don&apos;t know&quot;, NA,
	ifelse(water14 == &quot;Yes&quot;, 1, 0))


################################################################################
#
# water15: water quality improvement
#
################################################################################
#
# waterImprovement: water quality improvement
#
waterImprovement &lt;- ifelse(surveyData$water42 == &quot;Other improvement (please specify)&quot;, surveyData$water43, surveyData$water42)
waterImprovement &lt;- ifelse(waterImprovement == &quot;&quot;, &quot;Don&apos;t know/no answer/not applicable&quot;, waterImprovement)
waterImprovement &lt;- str_split(string = waterImprovement, pattern = &quot;, &quot;, simplify = TRUE)
waterImprovement[,1] &lt;- ifelse(waterImprovement[,1] == &quot;Other improvement (please specify)&quot;, surveyData$water43, waterImprovement[,1])
waterImprovement[,2] &lt;- ifelse(waterImprovement[,2] == &quot;Other improvement (please specify)&quot;, surveyData$water43, waterImprovement[,2])
waterImprovement[,3] &lt;- ifelse(waterImprovement[,3] == &quot;Other improvement (please specify)&quot;, surveyData$water43, waterImprovement[,3])
waterImprovement[,4] &lt;- ifelse(waterImprovement[,4] == &quot;Other improvement (please specify)&quot;, surveyData$water43, waterImprovement[,4])
#
# water15a: clean water
#
water15a &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water15a[waterImprovement[,1] == &quot;Clean water&quot; | 
	waterImprovement[,2] == &quot;Clean water&quot; | 
	waterImprovement[,3] == &quot;Clean water&quot; | 
	waterImprovement[,4] == &quot;Clean water&quot;] &lt;- 1
#
# water15b: Easy handling
#
water15b &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water15b[waterImprovement[,1] == &quot;Easy handling&quot; | 
	waterImprovement[,2] == &quot;Easy handling&quot; | 
	waterImprovement[,3] == &quot;Easy handling&quot; | 
	waterImprovement[,4] == &quot;Easy handling&quot;] &lt;- 2
#
# water15c: Improvement bacterial/microbial/chemical water quality so it&apos;s safer to drink
#
water15c &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water15c[waterImprovement[,1] == &quot;Improvement bacterial/microbial/chemical water quality so it&apos;s safer to drink&quot; | 
	waterImprovement[,2] == &quot;Improvement bacterial/microbial/chemical water quality so it&apos;s safer to drink&quot; | 
	waterImprovement[,3] == &quot;Improvement bacterial/microbial/chemical water quality so it&apos;s safer to drink&quot; | 
	waterImprovement[,4] == &quot;Improvement bacterial/microbial/chemical water quality so it&apos;s safer to drink&quot;] &lt;- 3
#
# water15d: Improved colour
#
water15d &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water15d[waterImprovement[,1] == &quot;Improved colour&quot; | 
	waterImprovement[,2] == &quot;Improved colour&quot; | 
	waterImprovement[,3] == &quot;Improved colour&quot; | 
	waterImprovement[,4] == &quot;Improved colour&quot;] &lt;- 4
#
# water15e: Improved smell
#
water15e &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water15e[waterImprovement[,1] == &quot;Improved smell&quot; | 
	waterImprovement[,2] == &quot;Improved smell&quot; | 
	waterImprovement[,3] == &quot;Improved smell&quot; | 
	waterImprovement[,4] == &quot;Improved smell&quot;] &lt;- 5
#
# water15f: Iron free and clean water
#
water15f &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water15f[waterImprovement[,1] == &quot;Iron free and clean water&quot; | 
	waterImprovement[,2] == &quot;Iron free and clean water&quot; | 
	waterImprovement[,3] == &quot;Iron free and clean water&quot; | 
	waterImprovement[,4] == &quot;Iron free and clean water&quot;] &lt;- 6
#
# water15g: Less time to collect water
#
water15g &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water15g[waterImprovement[,1] == &quot;Less time to collect water&quot; | 
	waterImprovement[,2] == &quot;Less time to collect water&quot; | 
	waterImprovement[,3] == &quot;Less time to collect water&quot; | 
	waterImprovement[,4] == &quot;Less time to collect water&quot;] &lt;- 7
#
# water15h: own motor
#
water15h &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water15h[waterImprovement[,1] == &quot;Own motor&quot; | 
	waterImprovement[,2] == &quot;Own motor&quot; | 
	waterImprovement[,3] == &quot;Own motor&quot; | 
	waterImprovement[,4] == &quot;Own motor&quot;] &lt;- 8
#
# water15i: Repair the leakage in water line
#
water15i &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water15i[waterImprovement[,1] == &quot;Repair the likage in water line&quot; | 
	waterImprovement[,2] == &quot;Repair the likage in water line&quot; | 
	waterImprovement[,3] == &quot;Repair the likage in water line&quot; | 
	waterImprovement[,4] == &quot;Repair the likage in water line&quot;] &lt;- 9
#
# water15j: Water supply line
#
water15j &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water15j[waterImprovement[,1] == &quot;Water supply line&quot; | 
	waterImprovement[,2] == &quot;Water supply line&quot; | 
	waterImprovement[,3] == &quot;Water supply line&quot; | 
	waterImprovement[,4] == &quot;Water supply line&quot;] &lt;- 10
#
# water15k: Don&apos;t know/no answer/not applicable
#
water15k&lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water15k[waterImprovement[,1] == &quot;Don&apos;t know/no answer/not applicable&quot; | 
	waterImprovement[,2] == &quot;Don&apos;t know/no answer/not applicable&quot; | 
	waterImprovement[,3] == &quot;Don&apos;t know/no answer/not applicable&quot; | 
	waterImprovement[,4] == &quot;Don&apos;t know/no answer/not applicable&quot;] &lt;- 11
#
#
#
water15 &lt;- data.frame(water15a, water15b, water15c, water15d, water15e, water15f,
	water15g, water15h, water15i, water15j, water15k)


################################################################################
#
# water16: water pressure
#
################################################################################
#
#
#
water16 &lt;- ifelse(surveyData$water45 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water45)
#
#
#
water16a &lt;- ifelse(water16 == &quot;Don&apos;t know&quot;, NA,
	ifelse(water16 == &quot;Yes&quot;, 1, 0))


################################################################################
#
# water17: support provider
#
################################################################################
#
#
#
water17 &lt;- ifelse(surveyData$water47 == &quot;&quot;, &quot;Don&apos;t know/not applicable&quot;,
	ifelse(surveyData$water47 == &quot;Other (please specify)&quot;, surveyData$water48, surveyData$water47))
#
#
#
water17 &lt;- ifelse(water17 == &quot;&quot;, &quot;Don&apos;t know/not applicable&quot;, water17)
#
#
#
water17 &lt;- ifelse(water17 == &quot;Landlord/House owner &quot;, &quot;Landlord/House owner&quot;,
	ifelse(water17 == &quot;Caretaker &quot;, &quot;Caretaker&quot;,
		ifelse(water17 %in% c(&quot;Gaurd&quot;, &quot;Gaurd &quot;), &quot;Guard&quot;,
			ifelse(water17 %in% c(&quot;No complain arise&quot;, &quot;No complain  arise&quot;, &quot;Till lemdon&apos;t face any problem&quot;), &quot;No complaints&quot;,
				ifelse(water17 == &quot;Water office &quot;, &quot;Water office&quot;,
					ifelse(water17 == &quot;Do no&apos;t cpmlain&quot;, &quot;Do not complain&quot;,
						ifelse(water17 == &quot;Parlament Member (MP)&quot;, &quot;Parliament Member (MP)&quot;,
							ifelse(water17 == &quot;Relavent office&quot;, &quot;Relevant office&quot;,
								ifelse(water17 == &quot;Messengaer &quot;, &quot;Messenger&quot;, 
									ifelse(water17 == &quot;Local Gverenment Engineering office&quot;, &quot;Local Government Engineering office&quot;, water17))))))))))


################################################################################
#
# water18: water storage
#
################################################################################
#
# waterStorage
#
waterStorage &lt;- ifelse(surveyData$wash60 == &quot;&quot;, &quot;Don&apos;t know/not applicable&quot;, surveyData$wash60)
waterStorage &lt;- str_split(string = waterStorage, pattern = &quot;, &quot;, simplify = TRUE)
#
# water18a: Clean container (with lid)
#
water18a &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water18a[waterStorage[,1] == &quot;Clean container (with lid)&quot; |
	waterStorage[,2] == &quot;Clean container (with lid)&quot; |
	waterStorage[,3] == &quot;Clean container (with lid)&quot;] &lt;- 1
#
# water18b: Clean container (without lid)
#
water18b &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water18b[waterStorage[,1] == &quot;Clean container (without lid)&quot; |
	waterStorage[,2] == &quot;Clean container (without lid)&quot; |
	waterStorage[,3] == &quot;Clean container (without lid)&quot;] &lt;- 2
#
# water18c: Dirty container
#
water18c &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water18c[waterStorage[,1] == &quot;Dirty container&quot; |
	waterStorage[,2] == &quot;Dirty container&quot; |
	waterStorage[,3] == &quot;Dirty container&quot;] &lt;- 3
#
# water18d: Don&apos;t know/not applicable
#
water18d &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water18d[waterStorage[,1] == &quot;Don&apos;t know/not applicable&quot; |
	waterStorage[,2] == &quot;Don&apos;t know/not applicable&quot; |
	waterStorage[,3] == &quot;Don&apos;t know/not applicable&quot;] &lt;- 4
#
# water18
#        
water18 &lt;- ifelse(water18d == 4, NA,
	ifelse(water18a == 1 &amp; water18b != 2 &amp; water18c != 3, 1, 0))


################################################################################
#
# JMP indicators for drinking water - post-2015
#
################################################################################
#
# Surface water: river, dam, lake, pond, stream, canal or irrigation channel
#
jmpWater1 &lt;- ifelse(waterSource == &quot;Surface water&quot;, 1, 0)
#
# Unimproved: unprotected dug wells, unprotected springs, carts with small tank,
#             tanker trucks; basic sources with collection time &gt; 30 minutes;
#             primary source is bottled water but secondary source is unimproved
#
jmpWater2 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
jmpWater2[water1 == 1 &amp; waterSource != &quot;Bottled water&quot; &amp; water7a == 1] &lt;- 0
jmpWater2[water1 == 1 &amp; waterSource == &quot;Bottled water&quot; &amp; water11c == 1 &amp; water7a == 1] &lt;- 0
jmpWater2[water1 == 1 &amp; waterSource != &quot;Bottled water&quot; &amp; water7a == 0] &lt;- 1
jmpWater2[water1 == 1 &amp; waterSource == &quot;Bottled water&quot; &amp; water11c == 1 &amp; water7a == 0] &lt;- 1
jmpWater2[water1 == 0] &lt;- 1
jmpWater2[water1 == 1 &amp; waterSource == &quot;Bottled water&quot; &amp; water11c == 0] &lt;- 1
#
# Basic: piped water, boreholes or tubewells, protected dug wells, protected spring,
#        rainwater with collection time nor more than 30 minutes
#
jmpWater3 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
jmpWater3[water1 == 1 &amp; waterSource != &quot;Bottled water&quot; &amp; water7a == 1] &lt;- 1
jmpWater3[water1 == 1 &amp; waterSource == &quot;Bottled water&quot; &amp; water11c == 1 &amp; water7a == 1] &lt;- 1
jmpWater3[water1 == 1 &amp; waterSource != &quot;Bottled water&quot; &amp; water7a == 0] &lt;- 0
jmpWater3[water1 == 1 &amp; waterSource == &quot;Bottled water&quot; &amp; water11c == 1 &amp; water7a == 0] &lt;- 0
jmpWater3[water1 == 0] &lt;- 0
jmpWater3[water1 == 1 &amp; waterSource == &quot;Bottled water&quot; &amp; water11c == 0] &lt;- 0


################################################################################
#
# Tanahashi model-based bottleneck analysis of drinking water access based on JMP 
#
################################################################################
#
# wLevel1: use of water services other than surface water (availablity of water services)
#
wLevel1 &lt;- ifelse(waterSource == &quot;Surface water&quot;, 0, 1)
#
# wLevel2: use of water services that are improved (availability of improved water sources)
#
wLevel2 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
wLevel2[water1 == 1 &amp; waterSource != &quot;Bottled water&quot;] &lt;- 1
wLevel2[water1 == 1 &amp; waterSource == &quot;Bottled water&quot; &amp; water11c == 1] &lt;- 1
wLevel2[water1 == 0] &lt;- 0
wLevel2[water1 == 1 &amp; waterSource == &quot;Bottled water&quot; &amp; water11c == 0] &lt;- 0
#
# wLevel3: accessiblity of improved water sources
#
wLevel3 &lt;- ifelse(wLevel2 == 1 &amp; water7a == 1, 1, 0)
#
# wLevel4: accessible improved water sources that is always available
#
wLevel4 &lt;- ifelse(wLevel3 == 1 &amp; 
	waterSource %in% c(&quot;Deep tube well&quot;, &quot;Piped water into dwelling&quot;,
		&quot;Piped water to yard/plot&quot;, &quot;Tube well&quot;, &quot;Water lifted by moter&quot;,
		&quot;Protected dug well or spring in yard&quot;) &amp;
	water7 == 0 &amp;
	water4b == 1 &amp; water5b == 1 &amp; water6a == 1, 1, 0)
#
# wLevel5: accessible improved water sources that is free from faecal and chemical
#          contamination and is always available
#
#          Indicator can be considered effective water services coverage
#          Indicator cannot be measured/estimated as no water quality testing done
#


################################################################################
#
# Create waterDF
#
################################################################################
#
# Concatenate water indicators
#
waterDF &lt;- data.frame(&quot;uniqueID&quot; = surveyData[ , &quot;uniqueID&quot;], &quot;psu&quot; = surveyData[ , &quot;psu&quot;],
	waterSource, water1, water2, water2a, water3, water3a,
	water4, water4a, water4b, water5, water5a, water5b,
	water6, water6a, water7, water7a, water7b, water7c, water8, water8a,
	water9a, water9b, water9c, water9d, water9e, water9f, water9g, water9h,
	water10, water10a, water10b,
	water11, water11a, water11b, water11c, water11d,
	water12, water12a, water12b,
	water13, water13a,
	water14, water14a,
	water15a, water15b, water15c, water15d, water15e, water15f, water15g, water15h, water15i, water15j, water15k,
	water16, water16a,
	water17,
	water18,
	jmpWater1, jmpWater2, jmpWater3,
	wLevel1, wLevel2, wLevel3, wLevel4)
#
# Clean-up
#
rm(waterSource, water1, water2, water2a, water3, water3a, water4, water4a, water4b,
	water5, water5a, water5b, water6, water6a, water7, water7a, water7b, water7c,
	water8, water8a, water9a, water9b, water9c, water9d, water9e, water9f, water9g, water9h,
	water10, water10a, water10b, water11, water11a, water11b, water11c, water11d,
	water12, water12a, water12b, water13, water13a, water14, water14a,
	water15a, water15b, water15c, water15d, water15e, water15f, water15g, water15h, water15i, water15j, water15k,
	water16, water16a, water17, water18,
	jmpWater1, jmpWater2, jmpWater3,
	wLevel1, wLevel2, wLevel3, wLevel4)

	</command>
											<property title="Water" shape="TRANSFORM"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<node id="58" date="1510899095242" uid="1d9b9867557dcb86" x="220" y="120">
											<command>
################################################################################
#
# Progress out of Poverty Index (PPI) - Bangladesh
#
################################################################################
#
# Check if country is Bangladesh
#
if(unique(surveyData$country) == &quot;Bangladesh&quot;)
  {
  #
  # ppi1: Number of household members 12-years old or younger 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;None&quot;, 32,
  	       ifelse(surveyData$ppi1 == &quot;One&quot;, 16,
		    ifelse(surveyData$ppi1 == &quot;Two&quot;, 10, 0)))
  #
  # ppi2: Do household members 6-12 years old attend school?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;Yes&quot;, 6, 0)
  #
  # ppi3: In past year, any household member do paid work?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;No&quot;, 8, 0)
  #
  # ppi4: Number of rooms used by household
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Three or more&quot;, 5,
	       ifelse(surveyData$ppi4 == &quot;Two&quot;, 3, 0))
  #
  # ppi5: Main construction material of the walls of the main room
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;Brick/cement&quot;, 9,
	       ifelse(surveyData$ppi5 == &quot;Mud brick, or C.I. sheet/wood&quot;, 2, 0))
  #
  # ppi6: Does the household own television?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Yes&quot;, 7, 0)
  #
  # ppi7: Number of fans the household owns
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;Two or more&quot;, 7,
       	  ifelse(surveyData$ppi7 == &quot;One&quot;, 4, 0))
  #
  # ppi8: Number of mobile phones the household owns
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;Two or more&quot;, 15,
  	       ifelse(surveyData$ppi8 == &quot;One&quot;, 8, 0))
  #
  # ppi9: Does household own bicycles, motorcycles/scooters, cars?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;Yes&quot;, 4, 0)
  #
  # ppi10: Does the household own/rent/sharecrop/mortgage in or out 51 or more
  #        decimals of cultivable agricultural land
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;Yes&quot;, 7, 0)
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: load lookup table
  #
  ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableBGD.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrix[ppiMatrix[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }




################################################################################
#
# Progress out of Poverty Index (PPI) - Ghana
#
################################################################################
#
# Check if country is Ghana
#
if(unique(surveyData$country) == &quot;Ghana&quot;)
  {
  #
  # ppi1: Number of household members 12-years old or younger 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;None&quot;, 32,
		  ifelse(surveyData$ppi1 == &quot;One&quot;, 16,
		    ifelse(surveyData$ppi1 == &quot;Two&quot;, 10, 0)))
  #
  # ppi2: Do household members 6-12 years old attend school?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;Yes&quot;, 6, 0)
  #
  # ppi3: In past year, any household member do paid work?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;No&quot;, 8, 0)
  #
  # ppi4: Number of rooms used by household
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Three or more&quot;, 5,
	  	  ifelse(surveyData$ppi4 == &quot;Two&quot;, 3, 0))
  #
  # ppi5: Main construction material of the walls of the main room
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;Brick/cement&quot;, 9,
		  ifelse(surveyData$ppi5 == &quot;Mud brick, or C.I. sheet/wood&quot;, 2, 0))
  #
  # ppi6: Does the household own television?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Yes&quot;, 7, 0)
  #
  # ppi7: Number of fans the household owns
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;Two or more&quot;, 7,
		  ifelse(surveyData$ppi7 == &quot;One&quot;, 4, 0))
  #
  # ppi8: Number of mobile phones the household owns
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;Two or more&quot;, 15,
		  ifelse(surveyData$ppi8 == &quot;One&quot;, 8, 0))
  #
  # ppi9: Does household own bicycles, motorcycles/scooters, cars?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;Yes&quot;, 4, 0)
  #
  # ppi10: Does the household own/rent/sharecrop/mortgage in or out 51 or more
  #        decimals of cultivable agricultural land
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;Yes&quot;, 7, 0)
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: lookup table
  #
  ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableBGD.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrix[ppiMatrix[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }




################################################################################
#
# Progress out of Poverty Index (PPI) - India
#
################################################################################
#
# Check if country is India
#
if(unique(surveyData$country) == &quot;India&quot;)
  {
  #
  # ppi1: Number of household members 12-years old or younger 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;None&quot;, 32,
		  ifelse(surveyData$ppi1 == &quot;One&quot;, 16,
		    ifelse(surveyData$ppi1 == &quot;Two&quot;, 10, 0)))
  #
  # ppi2: Do household members 6-12 years old attend school?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;Yes&quot;, 6, 0)
  #
  # ppi3: In past year, any household member do paid work?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;No&quot;, 8, 0)
  #
  # ppi4: Number of rooms used by household
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Three or more&quot;, 5,
	  	  ifelse(surveyData$ppi4 == &quot;Two&quot;, 3, 0))
  #
  # ppi5: Main construction material of the walls of the main room
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;Brick/cement&quot;, 9,
		  ifelse(surveyData$ppi5 == &quot;Mud brick, or C.I. sheet/wood&quot;, 2, 0))
  #
  # ppi6: Does the household own television?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Yes&quot;, 7, 0)
  #
  # ppi7: Number of fans the household owns
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;Two or more&quot;, 7,
		  ifelse(surveyData$ppi7 == &quot;One&quot;, 4, 0))
  #
  # ppi8: Number of mobile phones the household owns
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;Two or more&quot;, 15,
		  ifelse(surveyData$ppi8 == &quot;One&quot;, 8, 0))
  #
  # ppi9: Does household own bicycles, motorcycles/scooters, cars?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;Yes&quot;, 4, 0)
  #
  # ppi10: Does the household own/rent/sharecrop/mortgage in or out 51 or more
  #        decimals of cultivable agricultural land
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;Yes&quot;, 7, 0)
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: lookup table
  #
  ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableBGD.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrix[ppiMatrix[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }




################################################################################
#
# Progress out of Poverty Index (PPI) - Kenya
#
################################################################################
#
# Check if country is Kenya
#
if(unique(surveyData$country) == &quot;Kenya&quot;)
  {
  #
  # ppi1: Number of household members 12-years old or younger 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;None&quot;, 32,
		  ifelse(surveyData$ppi1 == &quot;One&quot;, 16,
		    ifelse(surveyData$ppi1 == &quot;Two&quot;, 10, 0)))
  #
  # ppi2: Do household members 6-12 years old attend school?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;Yes&quot;, 6, 0)
  #
  # ppi3: In past year, any household member do paid work?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;No&quot;, 8, 0)
  #
  # ppi4: Number of rooms used by household
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Three or more&quot;, 5,
	  	  ifelse(surveyData$ppi4 == &quot;Two&quot;, 3, 0))
  #
  # ppi5: Main construction material of the walls of the main room
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;Brick/cement&quot;, 9,
		  ifelse(surveyData$ppi5 == &quot;Mud brick, or C.I. sheet/wood&quot;, 2, 0))
  #
  # ppi6: Does the household own television?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Yes&quot;, 7, 0)
  #
  # ppi7: Number of fans the household owns
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;Two or more&quot;, 7,
		  ifelse(surveyData$ppi7 == &quot;One&quot;, 4, 0))
  #
  # ppi8: Number of mobile phones the household owns
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;Two or more&quot;, 15,
		  ifelse(surveyData$ppi8 == &quot;One&quot;, 8, 0))
  #
  # ppi9: Does household own bicycles, motorcycles/scooters, cars?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;Yes&quot;, 4, 0)
  #
  # ppi10: Does the household own/rent/sharecrop/mortgage in or out 51 or more
  #        decimals of cultivable agricultural land
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;Yes&quot;, 7, 0)
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: lookup table
  #
  ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableBGD.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrix[ppiMatrix[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }




################################################################################
#
# Progress out of Poverty Index (PPI) - Madagascar
#
################################################################################
#
# Check if country is Madagascar
#
if(unique(surveyData$country) == &quot;Madagascar&quot;)
  {
  #
  # ppi1: Number of household members 12-years old or younger 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;None&quot;, 32,
		  ifelse(surveyData$ppi1 == &quot;One&quot;, 16,
		    ifelse(surveyData$ppi1 == &quot;Two&quot;, 10, 0)))
  #
  # ppi2: Do household members 6-12 years old attend school?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;Yes&quot;, 6, 0)
  #
  # ppi3: In past year, any household member do paid work?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;No&quot;, 8, 0)
  #
  # ppi4: Number of rooms used by household
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Three or more&quot;, 5,
	  	  ifelse(surveyData$ppi4 == &quot;Two&quot;, 3, 0))
  #
  # ppi5: Main construction material of the walls of the main room
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;Brick/cement&quot;, 9,
		  ifelse(surveyData$ppi5 == &quot;Mud brick, or C.I. sheet/wood&quot;, 2, 0))
  #
  # ppi6: Does the household own television?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Yes&quot;, 7, 0)
  #
  # ppi7: Number of fans the household owns
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;Two or more&quot;, 7,
		  ifelse(surveyData$ppi7 == &quot;One&quot;, 4, 0))
  #
  # ppi8: Number of mobile phones the household owns
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;Two or more&quot;, 15,
		  ifelse(surveyData$ppi8 == &quot;One&quot;, 8, 0))
  #
  # ppi9: Does household own bicycles, motorcycles/scooters, cars?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;Yes&quot;, 4, 0)
  #
  # ppi10: Does the household own/rent/sharecrop/mortgage in or out 51 or more
  #        decimals of cultivable agricultural land
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;Yes&quot;, 7, 0)
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: lookup table
  #
  ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableBGD.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrix[ppiMatrix[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }




################################################################################
#
# Progress out of Poverty Index (PPI) - Zambia
#
################################################################################
#
# Check if country is Zambia
#
if(unique(surveyData$country) == &quot;Zambia&quot;)
  {
  #
  # ppi1: Number of household members 12-years old or younger 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;None&quot;, 32,
		  ifelse(surveyData$ppi1 == &quot;One&quot;, 16,
		    ifelse(surveyData$ppi1 == &quot;Two&quot;, 10, 0)))
  #
  # ppi2: Do household members 6-12 years old attend school?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;Yes&quot;, 6, 0)
  #
  # ppi3: In past year, any household member do paid work?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;No&quot;, 8, 0)
  #
  # ppi4: Number of rooms used by household
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Three or more&quot;, 5,
	  	  ifelse(surveyData$ppi4 == &quot;Two&quot;, 3, 0))
  #
  # ppi5: Main construction material of the walls of the main room
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;Brick/cement&quot;, 9,
		  ifelse(surveyData$ppi5 == &quot;Mud brick, or C.I. sheet/wood&quot;, 2, 0))
  #
  # ppi6: Does the household own television?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Yes&quot;, 7, 0)
  #
  # ppi7: Number of fans the household owns
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;Two or more&quot;, 7,
		  ifelse(surveyData$ppi7 == &quot;One&quot;, 4, 0))
  #
  # ppi8: Number of mobile phones the household owns
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;Two or more&quot;, 15,
		  ifelse(surveyData$ppi8 == &quot;One&quot;, 8, 0))
  #
  # ppi9: Does household own bicycles, motorcycles/scooters, cars?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;Yes&quot;, 4, 0)
  #
  # ppi10: Does the household own/rent/sharecrop/mortgage in or out 51 or more
  #        decimals of cultivable agricultural land
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;Yes&quot;, 7, 0)
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: lookup table
  #
  ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableBGD.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrix[ppiMatrix[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }



################################################################################
#                                                                              #
# Group population by wealth quintiles                                         #
#                                                                              #
################################################################################
#
# Find the quintile cutoffs for PPI
#
qCutOff &lt;- quantile(ppi, probs = c(0.2, 0.4, 0.6, 0.8, 1))
#
# Classify households by wealth quintile
#
pQuintile &lt;- ifelse(ppi &lt;= qCutOff[1], 1,
	ifelse(ppi &gt; qCutOff[1] &amp; ppi &lt;= qCutOff[2], 2,
		ifelse(ppi &gt; qCutOff[2] &amp; ppi &lt;= qCutOff[3], 3,
			ifelse(ppi &gt; qCutOff[3] &amp; ppi &lt;= qCutOff[4], 4, 5))))
#
# Concatenate PPI indicators into single data.frame
#
pPoverty &lt;- data.frame(&quot;uniqueID&quot; = surveyData[ , &quot;uniqueID&quot;], ppi, pQuintile, pPoverty)

</command>
											<property title="Poverty" shape="TRANSFORM"/>
											<option type="com.ef_prime.rflow.node.base.SubflowNodeModel">
												<subflow>
													<graph version="0.8" width="1493" height="785" locationtype="a" offsetx="100" offsety="110">
														<node id="59" date="1510899093942" uid="9a50195eb90bcd9d" x="40" y="-70">
															<command></command>
															<property/>
															<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
																<entry key="io">in</entry>
															</option>
														</node>
														<node id="60" date="1510899095242" uid="f19b0951c93a55f8" x="40" y="240">
															<command></command>
															<property/>
															<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
																<entry key="io">out</entry>
															</option>
														</node>
														<node id="61" date="1510899093942" uid="bd857a5054922cac" x="120" y="10">
															<command>

################################################################################
#
# Progress out of Poverty Index (PPI) - Ghana
#
################################################################################
#
# Check if country is Ghana
#
if(unique(surveyData$country) == &quot;Ghana&quot;)
  {
  #
  # ppi1: Number of household members 12-years old or younger 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;None&quot;, 32,
		  ifelse(surveyData$ppi1 == &quot;One&quot;, 16,
		    ifelse(surveyData$ppi1 == &quot;Two&quot;, 10, 0)))
  #
  # ppi2: Do household members 6-12 years old attend school?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;Yes&quot;, 6, 0)
  #
  # ppi3: In past year, any household member do paid work?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;No&quot;, 8, 0)
  #
  # ppi4: Number of rooms used by household
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Three or more&quot;, 5,
	  	  ifelse(surveyData$ppi4 == &quot;Two&quot;, 3, 0))
  #
  # ppi5: Main construction material of the walls of the main room
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;Brick/cement&quot;, 9,
		  ifelse(surveyData$ppi5 == &quot;Mud brick, or C.I. sheet/wood&quot;, 2, 0))
  #
  # ppi6: Does the household own television?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Yes&quot;, 7, 0)
  #
  # ppi7: Number of fans the household owns
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;Two or more&quot;, 7,
		  ifelse(surveyData$ppi7 == &quot;One&quot;, 4, 0))
  #
  # ppi8: Number of mobile phones the household owns
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;Two or more&quot;, 15,
		  ifelse(surveyData$ppi8 == &quot;One&quot;, 8, 0))
  #
  # ppi9: Does household own bicycles, motorcycles/scooters, cars?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;Yes&quot;, 4, 0)
  #
  # ppi10: Does the household own/rent/sharecrop/mortgage in or out 51 or more
  #        decimals of cultivable agricultural land
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;Yes&quot;, 7, 0)
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: lookup table
  #
  ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableBGD.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrix[ppiMatrix[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }

</command>
															<property title="Ghana" shape="TRANSFORM"/>
															<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
														</node>
														<node id="62" date="1510899095242" uid="cbeef24c105c992f" x="40" y="170">
															<command>
################################################################################
#                                                                              #
# Group population by wealth quintiles                                         #
#                                                                              #
################################################################################
#
# Find the quintile cutoffs for PPI
#
qCutOff &lt;- quantile(ppi, probs = c(0.2, 0.4, 0.6, 0.8, 1))
#
# Classify households by wealth quintile
#
pQuintile &lt;- ifelse(ppi &lt;= qCutOff[1], 1,
	ifelse(ppi &gt; qCutOff[1] &amp; ppi &lt;= qCutOff[2], 2,
		ifelse(ppi &gt; qCutOff[2] &amp; ppi &lt;= qCutOff[3], 3,
			ifelse(ppi &gt; qCutOff[3] &amp; ppi &lt;= qCutOff[4], 4, 5))))
#
# Concatenate PPI indicators into single data.frame
#
pPoverty &lt;- data.frame(&quot;uniqueID&quot; = surveyData[ , &quot;uniqueID&quot;], ppi, pQuintile, pPoverty)

</command>
															<property title="Calculate PPI" shape="SUMMARY"/>
															<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
														</node>
														<node id="63" date="1510899095242" uid="63af47d924d3516d" x="200" y="90">
															<command>

################################################################################
#
# Progress out of Poverty Index (PPI) - Kenya
#
################################################################################
#
# Check if country is Kenya
#
if(unique(surveyData$country) == &quot;Kenya&quot;)
  {
  #
  # ppi1: Number of household members 12-years old or younger 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;None&quot;, 32,
		  ifelse(surveyData$ppi1 == &quot;One&quot;, 16,
		    ifelse(surveyData$ppi1 == &quot;Two&quot;, 10, 0)))
  #
  # ppi2: Do household members 6-12 years old attend school?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;Yes&quot;, 6, 0)
  #
  # ppi3: In past year, any household member do paid work?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;No&quot;, 8, 0)
  #
  # ppi4: Number of rooms used by household
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Three or more&quot;, 5,
	  	  ifelse(surveyData$ppi4 == &quot;Two&quot;, 3, 0))
  #
  # ppi5: Main construction material of the walls of the main room
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;Brick/cement&quot;, 9,
		  ifelse(surveyData$ppi5 == &quot;Mud brick, or C.I. sheet/wood&quot;, 2, 0))
  #
  # ppi6: Does the household own television?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Yes&quot;, 7, 0)
  #
  # ppi7: Number of fans the household owns
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;Two or more&quot;, 7,
		  ifelse(surveyData$ppi7 == &quot;One&quot;, 4, 0))
  #
  # ppi8: Number of mobile phones the household owns
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;Two or more&quot;, 15,
		  ifelse(surveyData$ppi8 == &quot;One&quot;, 8, 0))
  #
  # ppi9: Does household own bicycles, motorcycles/scooters, cars?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;Yes&quot;, 4, 0)
  #
  # ppi10: Does the household own/rent/sharecrop/mortgage in or out 51 or more
  #        decimals of cultivable agricultural land
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;Yes&quot;, 7, 0)
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: lookup table
  #
  ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableBGD.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrix[ppiMatrix[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }

</command>
															<property title="Kenya" shape="TRANSFORM"/>
															<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
														</node>
														<node id="64" date="1510899095242" uid="f8dfd88a22ab70d0" x="40" y="10">
															<command>
################################################################################
#
# Progress out of Poverty Index (PPI) - Bangladesh
#
################################################################################
#
# Check if country is Bangladesh
#
if(unique(surveyData$country) == &quot;Bangladesh&quot;)
  {
  #
  # ppi1: Number of household members 12-years old or younger 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;None&quot;, 32,
  	       ifelse(surveyData$ppi1 == &quot;One&quot;, 16,
		    ifelse(surveyData$ppi1 == &quot;Two&quot;, 10, 0)))
  #
  # ppi2: Do household members 6-12 years old attend school?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;Yes&quot;, 6, 0)
  #
  # ppi3: In past year, any household member do paid work?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;No&quot;, 8, 0)
  #
  # ppi4: Number of rooms used by household
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Three or more&quot;, 5,
	       ifelse(surveyData$ppi4 == &quot;Two&quot;, 3, 0))
  #
  # ppi5: Main construction material of the walls of the main room
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;Brick/cement&quot;, 9,
	       ifelse(surveyData$ppi5 == &quot;Mud brick, or C.I. sheet/wood&quot;, 2, 0))
  #
  # ppi6: Does the household own television?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Yes&quot;, 7, 0)
  #
  # ppi7: Number of fans the household owns
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;Two or more&quot;, 7,
       	  ifelse(surveyData$ppi7 == &quot;One&quot;, 4, 0))
  #
  # ppi8: Number of mobile phones the household owns
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;Two or more&quot;, 15,
  	       ifelse(surveyData$ppi8 == &quot;One&quot;, 8, 0))
  #
  # ppi9: Does household own bicycles, motorcycles/scooters, cars?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;Yes&quot;, 4, 0)
  #
  # ppi10: Does the household own/rent/sharecrop/mortgage in or out 51 or more
  #        decimals of cultivable agricultural land
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;Yes&quot;, 7, 0)
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: load lookup table
  #
  ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableBGD.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrix[ppiMatrix[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }

</command>
															<property title="Bangladesh" shape="TRANSFORM"/>
															<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
														</node>
														<node id="65" date="1510899095242" uid="a969a5f98f05a40" x="40" y="90">
															<command>

################################################################################
#
# Progress out of Poverty Index (PPI) - Zambia
#
################################################################################
#
# Check if country is Zambia
#
if(unique(surveyData$country) == &quot;Zambia&quot;)
  {
  #
  # ppi1: Number of household members 12-years old or younger 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;None&quot;, 32,
		  ifelse(surveyData$ppi1 == &quot;One&quot;, 16,
		    ifelse(surveyData$ppi1 == &quot;Two&quot;, 10, 0)))
  #
  # ppi2: Do household members 6-12 years old attend school?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;Yes&quot;, 6, 0)
  #
  # ppi3: In past year, any household member do paid work?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;No&quot;, 8, 0)
  #
  # ppi4: Number of rooms used by household
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Three or more&quot;, 5,
	  	  ifelse(surveyData$ppi4 == &quot;Two&quot;, 3, 0))
  #
  # ppi5: Main construction material of the walls of the main room
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;Brick/cement&quot;, 9,
		  ifelse(surveyData$ppi5 == &quot;Mud brick, or C.I. sheet/wood&quot;, 2, 0))
  #
  # ppi6: Does the household own television?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Yes&quot;, 7, 0)
  #
  # ppi7: Number of fans the household owns
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;Two or more&quot;, 7,
		  ifelse(surveyData$ppi7 == &quot;One&quot;, 4, 0))
  #
  # ppi8: Number of mobile phones the household owns
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;Two or more&quot;, 15,
		  ifelse(surveyData$ppi8 == &quot;One&quot;, 8, 0))
  #
  # ppi9: Does household own bicycles, motorcycles/scooters, cars?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;Yes&quot;, 4, 0)
  #
  # ppi10: Does the household own/rent/sharecrop/mortgage in or out 51 or more
  #        decimals of cultivable agricultural land
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;Yes&quot;, 7, 0)
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: lookup table
  #
  ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableBGD.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrix[ppiMatrix[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }

</command>
															<property title="Zambia" shape="TRANSFORM"/>
															<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
														</node>
														<node id="66" date="1510899095242" uid="9370583358c7cd6f" x="120" y="90">
															<command>

################################################################################
#
# Progress out of Poverty Index (PPI) - Madagascar
#
################################################################################
#
# Check if country is Madagascar
#
if(unique(surveyData$country) == &quot;Madagascar&quot;)
  {
  #
  # ppi1: Number of household members 12-years old or younger 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;None&quot;, 32,
		  ifelse(surveyData$ppi1 == &quot;One&quot;, 16,
		    ifelse(surveyData$ppi1 == &quot;Two&quot;, 10, 0)))
  #
  # ppi2: Do household members 6-12 years old attend school?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;Yes&quot;, 6, 0)
  #
  # ppi3: In past year, any household member do paid work?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;No&quot;, 8, 0)
  #
  # ppi4: Number of rooms used by household
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Three or more&quot;, 5,
	  	  ifelse(surveyData$ppi4 == &quot;Two&quot;, 3, 0))
  #
  # ppi5: Main construction material of the walls of the main room
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;Brick/cement&quot;, 9,
		  ifelse(surveyData$ppi5 == &quot;Mud brick, or C.I. sheet/wood&quot;, 2, 0))
  #
  # ppi6: Does the household own television?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Yes&quot;, 7, 0)
  #
  # ppi7: Number of fans the household owns
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;Two or more&quot;, 7,
		  ifelse(surveyData$ppi7 == &quot;One&quot;, 4, 0))
  #
  # ppi8: Number of mobile phones the household owns
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;Two or more&quot;, 15,
		  ifelse(surveyData$ppi8 == &quot;One&quot;, 8, 0))
  #
  # ppi9: Does household own bicycles, motorcycles/scooters, cars?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;Yes&quot;, 4, 0)
  #
  # ppi10: Does the household own/rent/sharecrop/mortgage in or out 51 or more
  #        decimals of cultivable agricultural land
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;Yes&quot;, 7, 0)
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: lookup table
  #
  ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableBGD.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrix[ppiMatrix[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }

</command>
															<property title="Madagascar" shape="TRANSFORM"/>
															<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
														</node>
														<node id="67" date="1510899095242" uid="54d99770410b6f13" x="200" y="10">
															<command>

################################################################################
#
# Progress out of Poverty Index (PPI) - India
#
################################################################################
#
# Check if country is India
#
if(unique(surveyData$country) == &quot;India&quot;)
  {
  #
  # ppi1: Number of household members 12-years old or younger 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;None&quot;, 32,
		  ifelse(surveyData$ppi1 == &quot;One&quot;, 16,
		    ifelse(surveyData$ppi1 == &quot;Two&quot;, 10, 0)))
  #
  # ppi2: Do household members 6-12 years old attend school?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;Yes&quot;, 6, 0)
  #
  # ppi3: In past year, any household member do paid work?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;No&quot;, 8, 0)
  #
  # ppi4: Number of rooms used by household
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Three or more&quot;, 5,
	  	  ifelse(surveyData$ppi4 == &quot;Two&quot;, 3, 0))
  #
  # ppi5: Main construction material of the walls of the main room
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;Brick/cement&quot;, 9,
		  ifelse(surveyData$ppi5 == &quot;Mud brick, or C.I. sheet/wood&quot;, 2, 0))
  #
  # ppi6: Does the household own television?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Yes&quot;, 7, 0)
  #
  # ppi7: Number of fans the household owns
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;Two or more&quot;, 7,
		  ifelse(surveyData$ppi7 == &quot;One&quot;, 4, 0))
  #
  # ppi8: Number of mobile phones the household owns
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;Two or more&quot;, 15,
		  ifelse(surveyData$ppi8 == &quot;One&quot;, 8, 0))
  #
  # ppi9: Does household own bicycles, motorcycles/scooters, cars?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;Yes&quot;, 4, 0)
  #
  # ppi10: Does the household own/rent/sharecrop/mortgage in or out 51 or more
  #        decimals of cultivable agricultural land
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;Yes&quot;, 7, 0)
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: lookup table
  #
  ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableBGD.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrix[ppiMatrix[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }

</command>
															<property title="India" shape="TRANSFORM"/>
															<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
														</node>
														<edge from="63" to="66"/>
														<edge from="62" to="60"/>
														<edge from="66" to="65"/>
														<edge from="65" to="62"/>
														<edge from="67" to="63"/>
														<edge from="59" to="64"/>
														<edge from="64" to="61"/>
														<edge from="61" to="67"/>
													</graph>
												</subflow>
											</option>
										</node>
										<node id="68" date="1510899095243" uid="67f304b6a071676c" x="60" y="110">
											<command>#
# Extract country choice
#
country &lt;- as.character(tclvalue(choice.value))
#
# Determine country code
#
ccode &lt;- ifelse(country == &quot;Bangladesh&quot;, &quot;BGD&quot;,
	      ifelse(country == &quot;Ghana&quot;, &quot;GHA&quot;,
		   ifelse(country == &quot;India&quot;, &quot;IND&quot;,
			ifelse(country == &quot;Kenya&quot;, &quot;KEN&quot;,
			  ifelse(country == &quot;Madagascar&quot;, &quot;MDG&quot;, &quot;ZMB&quot;)))))
</command>
											<property title="Get country name" shape="INOUT"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<node id="69" date="1510899095242" uid="64650753294ba300" x="390" y="120">
											<command></command>
											<property/>
											<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
												<entry key="io">out</entry>
											</option>
										</node>
										<node id="70" date="1510899095243" uid="a1b78c30a98b5070" x="140" y="120">
											<command>
################################################################################
#
# Demographics data
#
################################################################################
#
# Extract demographic data
#
demoDF &lt;- surveyData[ , c(&quot;uniqueID&quot;, &quot;gender&quot;, &quot;landOwnStatus&quot;,
	&quot;nWomen&quot;, &quot;nMen&quot;, &quot;nOldWomen&quot;, &quot;nOldMen&quot;,
	&quot;nGirls&quot;, &quot;nBoys&quot;, &quot;nInfants&quot;, &quot;nMobility&quot;)]
#
# Count total number of household members
#
nMembers &lt;- surveyData$nWomen + surveyData$nMen + 
surveyData$nOldMen + surveyData$nOldWomen + 
surveyData$nGirls + surveyData$nBoys + 
surveyData$nInfants
#
# Create demographic data.frame
#
demoDF &lt;- data.frame(demoDF, nMembers)
#
# Clean-up
#
rm(nMembers)

</command>
											<property title="Demographic" shape="TRANSFORM"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<node id="71" date="1510899095243" uid="4499ea6cf8b0a264" x="60" y="40">
											<command>
################################################################################
#
# Read processed data
#
################################################################################

surveyData &lt;- read.csv(file = paste(&quot;data/workingSurveyData&quot;, unique(ccode), &quot;.csv&quot;, sep = &quot;&quot;),
	header = TRUE, sep = &quot;,&quot;)

	</command>
											<property title="Read processed data" shape="INOUT"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<node id="72" date="1510899095243" uid="7fdd47bf14680fb3" x="-20" y="110">
											<command></command>
											<property/>
											<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
												<entry key="io">in</entry>
											</option>
										</node>
										<edge from="70" to="58"/>
										<edge from="54" to="69"/>
										<edge from="55" to="70"/>
										<edge from="72" to="68"/>
										<edge from="57" to="56"/>
										<edge from="58" to="57"/>
										<edge from="71" to="55"/>
										<edge from="56" to="54"/>
										<edge from="68" to="71"/>
									</graph>
								</subflow>
							</option>
						</node>
						<node id="73" date="1510899093936" uid="3b973b6a4e49abb3" x="750" y="270">
							<command>
################################################################################
#
# Perform bootstrap
#
################################################################################
#
# Subset steerIndicators to those that can be bootstrapped
#
steerBoot &lt;- subset(steerIndicators, varStatistic == &quot;oneMean&quot;)
steerBoot &lt;- subset(steerIndicators, varList == &quot;san14&quot;)
#
# Extract number of replicates specified by user
#
REPLICATES &lt;- as.numeric(tclvalue(replicates))


################################################################################
#
# All results in a single output - Bootstrap
#
################################################################################
#
# Create empty container object for bootstrap results
#
summaryTable &lt;- NULL
#
# Cycle through each wealth quintile
#
for(i in unique(indicatorsDF$pQuintile))
  {
  #
  # Subset survey data to slum areas
  #
  slum.data &lt;- indicatorsDF[indicatorsDF$pQuintile == i &amp; indicatorsDF$type == 1, ]
  #
  # Subset survey data to other areas
  #
  other.data &lt;- indicatorsDF[indicatorsDF$pQuintile == i &amp; indicatorsDF$type == 2, ]  
  #
  # Get survey data for all areas in current zone
  #
  all.data &lt;- indicatorsDF[indicatorsDF$pQuintile == i, ]
  #
  # Subset population data to slum areas
  #
  slum.pop &lt;- popDF[popDF$psu %in% unique(slum.data$psu) &amp; popDF$type == 1, ]
  #
  # Subset population data to other areas
  #
  other.pop &lt;- popDF[popDF$psu %in% unique(other.data$psu) &amp; popDF$type == 2, ]
  #
  # Get population data for all areas in current zone
  #
  all.pop &lt;- popDF[popDF$psu %in% unique(all.data$psu), ]
  #
  # Cycle through indicator codes
  #
  for(j in steerBoot$varList)
    {
    #
    # Select indicator and statistic pair
    #
    INDICATOR &lt;- j
    STATISTIC &lt;- steerBoot$varStatistic[steerBoot$varList == j]
    #
    # Report progress
    #
    cat(&quot;\n\n&quot;, INDICATOR, &quot; : Wealth Quintile &quot;, i, &quot;\n\n&quot;, sep = &quot;&quot;)
    #
    # Boostrap (BBW) for current indicator and statistic pair - slum
    #
    boot.slum &lt;- bootBW(x = slum.data, 
                        w = slum.pop, 
                        statistic = eval(parse(text = STATISTIC)), 
			         params = INDICATOR, 
			         outputColumns = INDICATOR, 
			         replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - other
    #
    boot.other &lt;- bootBW(x = other.data, 
			          w = other.pop, 
			          statistic = eval(parse(text = STATISTIC)), 
			          params = INDICATOR, 
			          outputColumns = INDICATOR, 
			          replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - total
    #
    boot.total &lt;- bootBW(x = all.data, 
			          w = all.pop, 
			          statistic = eval(parse(text = STATISTIC)), 
			          params = INDICATOR, 
			          outputColumns = INDICATOR, 
			          replicates = REPLICATES)     
    #
    # Concatenate various boot vectors into data.frame
    #
    boot.all &lt;- data.frame(boot.slum, boot.other, boot.total)
    names(boot.all) &lt;- c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Total&quot;)
    #
    # Create a row of results and insert quantiles of boot results
    #
    rowResult &lt;- c(unique(country), unique(ccode), steerBoot$varNames[steerBoot$varList == j], j, paste(&quot;Wealth Quintile &quot;, i, sep = &quot;&quot;))
    for(k in names(boot.all))
      {
	 rowResult &lt;- c(rowResult, quantile(boot.all[[k]], probs = c(0.5, 0.025, 0.975), na.rm = TRUE))
      }
    #
    # Record results
    #
    summaryTable &lt;- rbind(summaryTable, rowResult)
    }
  #
  # Tidy results (row names, column types, column names, and order of rows)
  #
  summaryTable &lt;- data.frame(summaryTable, row.names = 1:nrow(summaryTable))
  #
  # Convert estimate results into numeric
  #
  for(col in 6:ncol(summaryTable))
    {
    summaryTable[, col] &lt;- as.numeric(summaryTable[, col])
    }
  }
#
# Rename summaryTable
#
names(summaryTable) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;,
	                    &quot;Indicator&quot;, &quot;Indicator Code&quot;, &quot;Wealth Quintile&quot;, 
           	          &quot;Slum Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Other Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Total Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;)
#
# Round-off estimates to the nearest 4 decimal places
#
summaryTable[ , 6:ncol(summaryTable)] &lt;- round(summaryTable[  , 6:ncol(summaryTable)], 4)
#
# Keep the rounding off of results for table output
#
options(scipen = 10)
#
# Save summaryTable as CSV file
#
write.csv(x = summaryTable, 
  	     file = paste(&quot;outputTables/surveyResultsBootWealth&quot;, unique(ccode), &quot;.csv&quot;, sep = &quot;&quot;),
	     row.names = FALSE)
#
# Reset scipen back to 0
#
options(scipen = 0)

</command>
							<property title="Estimate by wealth" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="74" date="1510899093935" uid="87695969bb0f2fc4" x="260" y="340" disabled="true">
							<command>
################################################################################
#                                                                              #
# Step 7: Report                                                               #
#                                                                              #
#      This step produces an HTML-based report that organises and presents     #
#      all results outputs (i.e, charts, maps, tables).                        #
#                                                                              #
################################################################################</command>
							<property title="Run STEP 7" shape="STAR">
								<comment state="opened" x="60" y="-20">STEP 7: Output through   
        reporting app</comment>
							</property>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="75" date="1510899093941" uid="b0a6b64dc362174a" x="410" y="270">
							<command>################################################################################
#
# Create graphics for poverty indicators
#
################################################################################
#
# Subset to water indicators
#
steerIndicators &lt;- steerIndicatorsX[64:74, ]


################################################################################
#
# Create histograms - by survey area
#
################################################################################
#
# Subset steering file into indicators needing histograms
#
steerHist &lt;- subset(steerIndicators, varFunction == &quot;histogram&quot;)
#
# Cycle through indicators needing histograms
#
for(i in steerHist$varList)
  {
  #
  # Cycle through survey areas
  #
  for(j in unique(indicatorsDF$zone))
    {
    #
    # Subset data to current zone
    #
    temp &lt;- subset(indicatorsDF, zone == j)
    #
    # Open PNG graphics device
    #
    png(filename = paste(&quot;outputFigures/charts/&quot;, i, &quot;SurveyArea&quot;, j, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
        width = 9, height = 3, units = &quot;in&quot;, res = 100)
    #
    #
    #    
    par(mfrow = c(1,3))
    #
    # Cycle through area type
    #
    for(k in unique(indicatorsDF$type))
      {
      #
      #
      #
      if(sum(temp[temp$type == k, i], na.rm = TRUE) != 0)
        {
        #
        # Create histogram for current area type
        #
        hist(x = temp[temp$type == k, i],
             main = ifelse(k == 1, &quot;Slum&quot;, &quot;Other&quot;),
             xlab = ifelse(i == &quot;ppi&quot;, &quot;Poverty score&quot;, &quot;Probability of being below poverty line&quot;))
        }
      }
    #
    #
    #
    if(sum(temp[[i]], na.rm = TRUE) != 0)
      {
      #
      # Create histgram for entire survey area
      #
      hist(x = temp[[i]],
           main = &quot;Overall&quot;,
           xlab = ifelse(i == &quot;ppi&quot;, &quot;Poverty score&quot;, &quot;Probability of being below poverty line&quot;))
      }
    #
    # Close graphics device
    #
    dev.off()
    }
  }</command>
							<property title="Poverty charts" shape="CHART"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="76" date="1510899095244" uid="f1b97484ab8824fb" x="160" y="340" disabled="true">
							<command></command>
							<property title="Report" shape="OUTPUT"/>
							<option type="com.ef_prime.rflow.node.base.SubflowNodeModel">
								<subflow>
									<graph version="0.8" width="1209" height="392" locationtype="a" offsetx="100" offsety="91">
										<node id="77" date="1510899095244" uid="924929f83c8b9c7f" x="-10" y="10">
											<command></command>
											<property/>
											<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
												<entry key="io">in</entry>
											</option>
										</node>
										<node id="78" date="1510899095244" uid="b00af56c58c705b4" x="280" y="110">
											<command></command>
											<property/>
											<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
												<entry key="io">out</entry>
											</option>
										</node>
										<edge from="77" to="78"/>
									</graph>
								</subflow>
							</option>
						</node>
						<node id="79" date="1510899093940" uid="b9ab01779f085f19" x="300" y="270">
							<command>################################################################################
#
# Create graphics for sanitation indicators
#
################################################################################
#
# Subset to water indicators
#
steerIndicators &lt;- steerIndicatorsX[31:63, ]


################################################################################
#
# Create histograms - by survey area
#
################################################################################
#
# Subset steering file into indicators needing histograms
#
steerHist &lt;- subset(steerIndicators, varFunction == &quot;histogram&quot;)
#
# Cycle through indicators needing histograms
#
for(i in steerHist$varList)
  {
  #
  # Cycle through survey areas
  #
  for(j in unique(indicatorsDF$zone))
    {
    #
    # Subset data to current zone
    #
    temp &lt;- subset(indicatorsDF, zone == j)
    #
    # Open PNG graphics device
    #
    png(filename = paste(&quot;outputFigures/charts/&quot;, i, &quot;SurveyArea&quot;, j, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
        width = 9, height = 3, units = &quot;in&quot;, res = 100)
    #
    #
    #    
    par(mfrow = c(1,3))
    #
    # Cycle through area type
    #
    for(k in unique(indicatorsDF$type))
      {
      #
      #
      #
      if(sum(temp[temp$type == k, i], na.rm = TRUE) != 0)
        {
        #
        # Create histogram for current area type
        #
        hist(x = temp[temp$type == k, i],
             main = ifelse(k == 1, &quot;Slum&quot;, &quot;Other&quot;),
             xlab = ifelse(i == &quot;san2&quot;, &quot;No. of people&quot;,
                     ifelse(i == &quot;san13&quot;, &quot;Minutes&quot;, &quot;Cost (BGD Taka)&quot;)))
        }
      }
    #
    #
    #
    if(sum(temp[[i]], na.rm = TRUE) != 0)
      {
      #
      # Create histgram for entire survey area
      #
      hist(x = temp[[i]],
           main = &quot;Overall&quot;,
           xlab = ifelse(i == &quot;san2&quot;, &quot;No. of people&quot;,
                     ifelse(i == &quot;san13&quot;, &quot;Minutes&quot;, &quot;Cost (BGD Taka)&quot;)))
      }
    #
    # Close graphics device
    #
    dev.off()
    }
  }


################################################################################
#
# Create pareto charts - by survey area
#
################################################################################
#
# Subset steering file into indicators needing histograms
#
steerBar &lt;- subset(steerIndicators, varFunction == &quot;pareto&quot;)
#
# Cycle through indicators needing histograms
#
for(i in steerBar$varList)
  {
  #
  # Cycle through survey areas
  #
  for(j in unique(indicatorsDF$zone))
    {
    #
    # Subset data to current zone
    #
    temp &lt;- subset(indicatorsDF, zone == j)
    #
    # Open PNG graphics device
    #
    png(filename = paste(&quot;outputFigures/charts/&quot;, i, &quot;SurveyArea&quot;, j, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
        width = 12, height = 3, units = &quot;in&quot;, res = 100)
    #
    #
    #    
    par(mar = c(3,14,1,1), mfrow = c(1,3))
    #
    # Cycle through area type
    #
    for(k in unique(indicatorsDF$type))
      {
      #
      # Create histogram for current area type
      #
      barplot(height = sort(table(temp[[i]]), decreasing = TRUE),
              horiz = TRUE,
              las = 1,
              xlab = &quot;&quot;,
              main = &quot;&quot;)
      }
    #
    # Create histgram for entire survey area
    #
    barplot(height = sort(table(temp[[i]]), decreasing = TRUE),
            horiz = TRUE,
            las = 1,
            xlab = &quot;&quot;,
            main = &quot;&quot;)
    #
    # Close graphics device
    #
    dev.off()
    }
  }
</command>
							<property title="Sanitation charts" shape="CHART"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="80" date="1510899093934" uid="6ed994f5d34f9b1d" x="900" y="650">
							<command>


xx &lt;- readOGR(dsn = &quot;dhakaCorporations&quot;,
              layer = &quot;dhakaCorporations&quot;,
              verbose = FALSE)
        
long.lat.crs &lt;- &quot;+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0&quot;

xx &lt;- spTransform(x = xx, CRSobj = CRS(long.lat.crs))                          
                                                    
                                                                                                        
yy &lt;- SpatialPoints(coords = indicatorsDF[ , c(&quot;longitude&quot;, &quot;latitude&quot;)],
                    proj4string = CRS(long.lat.crs))
                    
                    
north &lt;- subset(xx, corprtn == &quot;north&quot;)
south &lt;- subset(xx, corprtn == &quot;south&quot;)


indicatorsDF[indicatorsDF$longitude %in% yy[north]@coords$longitude &amp; indicatorsDF$latitude %in% yy[north]@coords$latitude, ]$corporation &lt;- &quot;north&quot;
indicatorsDF[indicatorsDF$longitude %in% yy[south]@coords$longitude &amp; indicatorsDF$latitude %in% yy[south]@coords$latitude, ]$corporation &lt;- &quot;south&quot;



corporation &lt;- ifelse(indicatorsDF$longitude %in% yy[north]@coords[,1] &amp; indicatorsDF$latitude %in% yy[north]@coords[,2], &quot;north&quot;,
                 ifelse(indicatorsDF$longitude %in% yy[south]@coords[,1] &amp; indicatorsDF$latitude %in% yy[south]@coords[,2], &quot;south&quot;, NA))
                 

</command>
							<property/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="81" date="1510899095244" uid="186afbe38ab12e5b" x="250" y="100">
							<command></command>
							<property/>
							<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
								<entry key="io">out</entry>
							</option>
						</node>
						<node id="82" date="1510899095244" uid="3bd875dac0bd5eaf" x="150" y="540">
							<command></command>
							<property/>
							<option type="com.ef_prime.rflow.node.base.CommentNodeModel">
								<entry key="state">opened</entry>
								<entry key="comment">####################
#                  #
# D. CHARTS &amp; MAPS #
#                  #
####################</entry>
							</option>
						</node>
						<node id="83" date="1510899093941" uid="60fb19489a991953" x="160" y="100">
							<command></command>
							<property/>
							<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
								<entry key="io">in</entry>
							</option>
						</node>
						<node id="84" date="1510899093935" uid="41214ffa7b18a056" x="824" y="254">
							<command>
################################################################################
#
# Perform bootstrap
#
################################################################################
#
# Subset steerIndicators to those that can be bootstrapped
#
steerBoot &lt;- subset(steerIndicators, varStatistic == &quot;oneMean&quot;)
steerBoot &lt;- subset(steerIndicators, varList == &quot;san13a&quot;)
#
# Extract number of replicates specified by user
#
REPLICATES &lt;- as.numeric(tclvalue(replicates))


################################################################################
#
# All results in a single output - Bootstrap
#
################################################################################
#
# Create empty container object for bootstrap results
#
summaryTable &lt;- NULL
#
# Cycle through each wealth quintile
#
for(i in unique(indicatorsDF$pQuintile))
  {
  #
  # Subset survey data to slum areas
  #
  slum.data &lt;- indicatorsDF[indicatorsDF$pQuintile == i &amp; indicatorsDF$type == 1, ]
  #
  # Subset survey data to other areas
  #
  other.data &lt;- indicatorsDF[indicatorsDF$pQuintile == i &amp; indicatorsDF$type == 2, ]  
  #
  # Get survey data for all areas in current zone
  #
  all.data &lt;- indicatorsDF[indicatorsDF$pQuintile == i, ]
  #
  # Subset population data to slum areas
  #
  slum.pop &lt;- popDF[popDF$psu %in% unique(slum.data$psu) &amp; popDF$type == 1, ]
  #
  # Subset population data to other areas
  #
  other.pop &lt;- popDF[popDF$psu %in% unique(other.data$psu) &amp; popDF$type == 2, ]
  #
  # Get population data for all areas in current zone
  #
  all.pop &lt;- popDF[popDF$psu %in% unique(all.data$psu), ]
  #
  # Cycle through indicator codes
  #
  for(j in steerBoot$varList)
    {
    #
    # Select indicator and statistic pair
    #
    INDICATOR &lt;- j
    STATISTIC &lt;- steerBoot$varStatistic[steerBoot$varList == j]
    #
    # Report progress
    #
    cat(&quot;\n\n&quot;, INDICATOR, &quot; : Wealth Quintile &quot;, i, &quot;\n\n&quot;, sep = &quot;&quot;)
    #
    # Boostrap (BBW) for current indicator and statistic pair - slum
    #
    boot.slum &lt;- bootBW(x = slum.data, 
                        w = slum.pop, 
                        statistic = eval(parse(text = STATISTIC)), 
			         params = INDICATOR, 
			         outputColumns = INDICATOR, 
			         replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - other
    #
    boot.other &lt;- bootBW(x = other.data, 
			          w = other.pop, 
			          statistic = eval(parse(text = STATISTIC)), 
			          params = INDICATOR, 
			          outputColumns = INDICATOR, 
			          replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - total
    #
    boot.total &lt;- bootBW(x = all.data, 
			          w = all.pop, 
			          statistic = eval(parse(text = STATISTIC)), 
			          params = INDICATOR, 
			          outputColumns = INDICATOR, 
			          replicates = REPLICATES)     
    #
    # Concatenate various boot vectors into data.frame
    #
    boot.all &lt;- data.frame(boot.slum, boot.other, boot.total)
    names(boot.all) &lt;- c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Total&quot;)
    #
    # Create a row of results and insert quantiles of boot results
    #
    rowResult &lt;- c(unique(country), unique(ccode), steerBoot$varNames[steerBoot$varList == j], j, paste(&quot;Wealth Quintile &quot;, i, sep = &quot;&quot;))
    for(k in names(boot.all))
      {
	 rowResult &lt;- c(rowResult, quantile(boot.all[[k]], probs = c(0.5, 0.025, 0.975), na.rm = TRUE))
      }
    #
    # Record results
    #
    summaryTable &lt;- rbind(summaryTable, rowResult)
    }
  #
  # Tidy results (row names, column types, column names, and order of rows)
  #
  summaryTable &lt;- data.frame(summaryTable, row.names = 1:nrow(summaryTable))
  #
  # Convert estimate results into numeric
  #
  for(col in 6:ncol(summaryTable))
    {
    summaryTable[, col] &lt;- as.numeric(summaryTable[, col])
    }
  }
#
# Rename summaryTable
#
names(summaryTable) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;,
	                    &quot;Indicator&quot;, &quot;Indicator Code&quot;, &quot;Wealth Quintile&quot;, 
           	          &quot;Slum Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Other Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Total Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;)
#
# Round-off estimates to the nearest 4 decimal places
#
summaryTable[ , 6:ncol(summaryTable)] &lt;- round(summaryTable[  , 6:ncol(summaryTable)], 4)
#
# Keep the rounding off of results for table output
#
options(scipen = 10)
#
# Save summaryTable as CSV file
#
write.csv(x = summaryTable, 
  	     file = paste(&quot;outputTables/surveyResultsBootWealthNew&quot;, unique(ccode), &quot;.csv&quot;, sep = &quot;&quot;),
	     row.names = FALSE)
#
# Reset scipen back to 0
#
options(scipen = 0)


################################################################################
</command>
							<property title="Estimate by wealth" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="85" date="1510899093935" uid="e49d218775056d1b" x="870" y="470">
							<command>
################################################################################
#
# Function to produce response based on selection
#
################################################################################
#
# 
#
onOK &lt;- function()
  {
  #
  # Extract name of country selected
  #
  cValue &lt;- as.numeric(tkcurselection(select.data$env$list)) + 1
  #
  # Close dialog box for country choices
  #
  tkdestroy(select.data)
  #
  # Remind user of country chosen
  #
  tkmessageBox(title = &quot;Selected country&quot;,
               message = paste(&quot;You have selected &quot;, length(cValue), &quot; country datasets.&quot;, sep = &quot;&quot;),
               icon = &quot;question&quot;,
               type = &quot;ok&quot;)
  #
  # Return result for cValue
  #
  return(cValue)
  }
  

################################################################################
#
# Select which country the data being analysed is from
#
################################################################################
#
# Vector of country choices
#
countries &lt;- c(&quot;Bangladesh&quot;, &quot;Ghana&quot;, &quot;Kenya&quot;, &quot;Madagascar&quot;, &quot;Mozambique&quot;, &quot;Zambia&quot;)
#
# Open dialog box
#
select.data &lt;- tktoplevel()
#
# Label teh dialog box
#
tkwm.title(select.data, &quot;Select country dataset&quot;)

select.data$env$list &lt;- tk2listbox(select.data, height = 4, selectmode = &quot;extended&quot;)

tkgrid(tk2label(select.data, 
                text = &quot;Which country datasets would you like to aggregate?&quot;,  
                justify = &quot;left&quot;),
       padx = 10, 
       pady =c(15, 5), 
       sticky = &quot;w&quot;)

tkgrid(select.data$env$list, padx = 10, pady = c(5, 10))

#
# Cycle through countries
#
#for(i in countries)
#  {
#  tkinsert(select.data$env$list, &quot;end&quot;, i)
#  }
 
#tkselection.set(select.data$env$list, 0) 
  
#
# Select which radio button is selected by default
#
select.value &lt;- tclVar(countries[1])

#
# Cycle through countries
#
for(i in 1:length(countries))
  {
#
# Configure radio buttons
#
  tkconfigure(widget = get(paste(&quot;select.data$env$list&quot;, i, sep = &quot;&quot;)),
		    variable = select.value,
		    value = countries[i])
  }

  
    
        
#
# Cycle through countries
#
#for(i in 1:length(countries))
#  {
  #
  # Configure radio buttons
  #
#  tkconfigure(widget = get(paste(&quot;choice$env$choice&quot;, i, sep = &quot;&quot;)),
#		    variable = choice.value,
#		    value = countries[i])
#  }
#
# Add a question prompt for country selection
#
#tkgrid(tk2label(parent = choice, text = &quot;Which country data are you analysing?&quot;),
#	           columnspan = 2, padx = 10, pady = c(15, 5))
#
# Cycle through countries
#
#for(i in 1:length(countries))
#  {
  #
  # Position choices on dialog box
  #    
#  tkgrid(tk2label(parent = choice, text = countries[i]),
#	             get(paste(&quot;choice$env$choice&quot;, i, sep = &quot;&quot;)),
#	             padx = 10, pady = c(0, i + 5))
#  }
#
# Create &apos;OK&apos; button
#  
select.data$env$butOK &lt;- tk2button(select.data, text = &quot;OK&quot;, width = -6, command = onOK)
#
# Define size parameters for dialog box
#
tkgrid(select.data$env$butOK, columnspan = 2, padx = 10, pady = c(5, 15))
#
# Focus to the choice dialog box
#
tkfocus(select.data)

</command>
							<property title="Select country datasets" shape="INOUT"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="86" date="1513145303280" uid="5842638814a31ed2" x="1090" y="350">
							<command>
################################################################################
#
# Specify bootstrapping parameters
#
################################################################################
#
# Set default number of replicates
#
replicates &lt;- tclVar(&quot;399&quot;)
#
# Create dialog box
#
choice &lt;- tktoplevel()
#
# Add title to dialog box
#
tkwm.title(choice, &quot;Bootstrap replicates&quot;)
#
# Create input box
#
replicates.entry &lt;- tkentry(choice, textvariable = replicates)
#
# RESET function for RESET button
#
reset &lt;- function()
  {
  #
  # Reset user input back to default
  #
  tclvalue(replicates) &lt;- &quot;399&quot;
  }
#
# Create reset button
#
reset.button &lt;- tkbutton(choice, text = &quot;Reset&quot;, command = reset)
#
# SUBMIT function for SUBMIT button
#
submit &lt;- function() 
  {
  #
  # Extract user input
  #
  x &lt;- as.numeric(tclvalue(replicates))
  #
  # Prompt user with input specified and ask whether to proceed
  #
  proceed &lt;- tkmessageBox(title = &quot;Bootstrap replicates&quot;,
                          message = paste(&quot;You specified &quot;, x, &quot; replicates for bootstrapping. Do you wish to continue?&quot;, sep = &quot;&quot;),
                          icon = &quot;question&quot;,
                          type = &quot;yesno&quot;)
  #
  # Determine if user does not want to continue with specified values
  #
  if(tclvalue(proceed) == &quot;no&quot;)
    {
    #
    # Prompt user that no replicates specified
    #
    tkmessageBox(title = &quot;Bootstrap replicates&quot;,
                 message = &quot;No number of replicates specified. Specify number of replicates&quot;,
                 icon = &quot;warning&quot;,
                 type = &quot;ok&quot;)
    }
  #
  # Determine if user wishes to proceed with specified replicates
  #
  if(tclvalue(proceed) == &quot;yes&quot;)
    {
    #
    # Close dialog box
    #
    tkdestroy(choice)
    }
  }
#
# Create submit button
#
submit.button &lt;- tkbutton(choice, text = &quot;Submit&quot;, command = submit)
#
# Create layout of input boxes and control buttons
# 
tkgrid(tklabel(choice, text = &quot;Specify number of bootstrap replicates&quot;), columnspan = 2, pady = 5)
tkgrid(tklabel(choice, text = &quot;Number of replicates:&quot;), replicates.entry, pady = 5, padx = 5)
tkgrid(submit.button, reset.button, pady = 5, padx = 5)

tkwait.window(choice)


 


################################################################################
#
# Perform bootstrap
#
################################################################################
#
# Subset steerIndicators to those that can be bootstrapped
#
steerBoot &lt;- subset(steerIndicators, varStatistic == &quot;oneMean&quot;)
steerBoot &lt;- subset(steerBoot, varList %in% c(&quot;jmpSan1&quot;, &quot;jmpSan2&quot;, &quot;jmpSan3&quot;, &quot;jmpSan4&quot;, &quot;jmpSan5&quot;))
#
# Extract number of replicates specified by user
#
REPLICATES &lt;- as.numeric(tclvalue(replicates))


################################################################################
#
# All results in a single output - Bootstrap
#
################################################################################
#
# Create empty container object for bootstrap results
#
summaryTable &lt;- NULL
#
# Cycle through each enumeration zones
#
for(i in unique(indicatorsDF$zone))
  {
  #
  # Subset population data to slum areas
  #
  slum.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 1, ]
  #
  # Subset population data to other areas
  #
  other.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 2, ]
  #
  # Subset survey data to slum areas
  #
  slum.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 1, ]
  #
  # Subset survey data to other areas
  #
  other.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 2, ]  
  #
  # Get population data for all areas in current zone
  #
  all.pop &lt;- popDF[popDF$zone == i, ]
  #
  # Get survey data for all areas in current zone
  #
  all.data &lt;- indicatorsDF[indicatorsDF$zone == i, ]
  #
  # Cycle through indicator codes
  #
  for(j in steerBoot$varList)
    {
    #
    # Select indicator and statistic pair
    #
    INDICATOR &lt;- j
    STATISTIC &lt;- steerBoot$varStatistic[steerBoot$varList == j]
    #
    # Report progress
    #
    cat(&quot;\n\n&quot;, INDICATOR, &quot; : Survey Area &quot;, i, &quot;\n\n&quot;, sep = &quot;&quot;)
    #
    # Boostrap (BBW) for current indicator and statistic pair - slum
    #
    boot.slum &lt;- bootBW(x = slum.data, 
                        w = slum.pop, 
                        statistic = eval(parse(text = STATISTIC)), 
			         params = INDICATOR, 
			         outputColumns = INDICATOR, 
			         replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - other
    #
    boot.other &lt;- bootBW(x = other.data, 
			          w = other.pop, 
			          statistic = eval(parse(text = STATISTIC)), 
			          params = INDICATOR, 
			          outputColumns = INDICATOR, 
			          replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - total
    #
    boot.total &lt;- bootBW(x = all.data, 
			          w = all.pop, 
			          statistic = eval(parse(text = STATISTIC)), 
			          params = INDICATOR, 
			          outputColumns = INDICATOR, 
			          replicates = REPLICATES)     
    #
    # Concatenate various boot vectors into data.frame
    #
    boot.all &lt;- data.frame(boot.slum, boot.other, boot.total)
    names(boot.all) &lt;- c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Total&quot;)
    #
    # Create a row of results and insert quantiles of boot results
    #
    rowResult &lt;- c(unique(country), unique(ccode), unique(month), unique(year), 
                   steerBoot$varNames[steerBoot$varList == j], j, paste(&quot;Survey Area &quot;, i, sep = &quot;&quot;))
    for(k in names(boot.all))
      {
	 rowResult &lt;- c(rowResult, quantile(boot.all[[k]], probs = c(0.5, 0.025, 0.975), na.rm = TRUE))
      }
    #
    # Record results
    #
    summaryTable &lt;- rbind(summaryTable, rowResult)
    }
  #
  # Tidy results (row names, column types, column names, and order of rows)
  #
  summaryTable &lt;- data.frame(summaryTable, row.names = 1:nrow(summaryTable))
  #
  # Convert estimate results into numeric
  #
  for(col in 8:ncol(summaryTable))
    {
    summaryTable[, col] &lt;- as.numeric(summaryTable[, col])
    }
  }
#
# Rename summaryTable
#
names(summaryTable) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;, &quot;Month&quot;, &quot;Year&quot;,
	                    &quot;Indicator&quot;, &quot;Indicator Code&quot;, &quot;Survey Area&quot;, 
           	          &quot;Low Income Area Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Other Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Total Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;)
#
# Round-off estimates to the nearest 4 decimal places
#
summaryTable[ , 8:ncol(summaryTable)] &lt;- round(summaryTable[  , 8:ncol(summaryTable)], 4)
#
# Keep the rounding off of results for table output
#
options(scipen = 10)
#
# Save summaryTable as CSV file
#
write.csv(x = summaryTable, 
  	     file = paste(&quot;outputTables/updates/surveyResultsBoot&quot;, 
  	                  unique(ccode), unique(month), unique(year),
  	                  &quot;.csv&quot;, sep = &quot;&quot;),
	     row.names = FALSE)
#
# Reset scipen back to 0
#
options(scipen = 0)


################################################################################
#
# Perform bootstrap
#
################################################################################
#
# Subset steerIndicators to those that can be bootstrapped
#
steerBoot &lt;- subset(steerIndicators, varStatistic != &quot;oneMean&quot;)
steerBoot &lt;- subset(steerBoot, varList %in% c(&quot;jmpSan1&quot;, &quot;jmpSan2&quot;, &quot;jmpSan3&quot;, &quot;jmpSan4&quot;, &quot;jmpSan5&quot;))

################################################################################
#
# All results in a single output - Bootstrap
#
################################################################################
#
# Determine if steerBoot is empty and decide whether to continue with next step
#
if(nrow(steerBoot) &gt; 0)
  {
  #
  # Create empty container object for bootstrap results  
  #
  summaryTableX &lt;- NULL
  #  
# Cycle through each enumeration zones
#
for(i in unique(indicatorsDF$zone))
  {
  #
  # Subset population data to slum areas
  #
  slum.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 1, ]
  #
  # Subset population data to other areas
  #
  other.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 2, ]
  #
  # Subset survey data to slum areas
  #
  slum.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 1, ]
  #
  # Subset survey data to other areas
  #
  other.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 2, ]  
  #
  # Get population data for all areas in current zone
  #
  all.pop &lt;- popDF[popDF$zone == i, ]
  #
  # Get survey data for all areas in current zone
  #
  all.data &lt;- indicatorsDF[indicatorsDF$zone == i, ]
  #
  # Cycle through indicator codes
  #
  for(j in steerBoot$varList)
    {
    #
    # Concatenate various boot vectors into data.frame
    #
    boot.all &lt;- data.frame(matrix(nrow = 1, ncol = 3))
    names(boot.all) &lt;- c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Total&quot;)
    #
    # Create a row of results and insert quantiles of boot results
    #
    rowResult &lt;- c(unique(country), unique(ccode), unique(month), unique(year),
                   steerBoot$varNames[steerBoot$varList == j], j, paste(&quot;Survey Area &quot;, i, sep = &quot;&quot;))
    for(k in names(boot.all))
      {
	 rowResult &lt;- c(rowResult, rep(NA, 3))
	 }
    #
    # Record results
    #
    summaryTableX &lt;- rbind(summaryTableX, rowResult)
    }
  #
  # Tidy results (row names, column types, column names, and order of rows)
  #
  if(!is.null(summaryTableX))
    {
    summaryTableX &lt;- data.frame(summaryTableX, row.names = 1:nrow(summaryTableX))
    #
    # Convert estimate results into numeric
    #
    for(col in 8:ncol(summaryTableX))
      {
      summaryTableX[, col] &lt;- as.numeric(summaryTableX[, col])
      }
    }
  }
 
  if(!is.null(summaryTableX))
    {
    #
    # Rename summaryTable
    #
    names(summaryTableX) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;, &quot;Month&quot;, &quot;Year&quot;,
	                         &quot;Indicator&quot;, &quot;Indicator Code&quot;, &quot;Survey Area&quot;, 
	                         &quot;Low Income Area Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                         &quot;Other Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                         &quot;Total Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;)
    #
    # Round-off estimates to the nearest 4 decimal places
    #
    summaryTableX[ , 8:ncol(summaryTableX)] &lt;- round(summaryTableX[  , 8:ncol(summaryTableX)], 4)
    }

#
# Combine results data.frame
#
summaryTable &lt;- data.frame(rbind(summaryTable, summaryTableX))
#
# Keep the rounding off of results for table output
#
options(scipen = 10)
#
# Save summaryTable as CSV file
#
write.csv(x = summaryTable, 
	     file = paste(&quot;outputTables/updates/surveyResultsBoot&quot;, 
	                  unique(ccode), unique(month), unique(year),
	                  &quot;.csv&quot;, sep = &quot;&quot;),
	     row.names = FALSE)
#
# Reset scipen back to 0
#
options(scipen = 0)
}



################################################################################
#
# Perform bootstrap
#
################################################################################
#
# Subset steerIndicators to those that can be bootstrapped
#
steerBoot &lt;- subset(steerIndicators, varStatistic == &quot;oneMean&quot;)
steerBoot &lt;- subset(steerBoot, varList %in% c(&quot;jmpSan1&quot;, &quot;jmpSan2&quot;, &quot;jmpSan3&quot;, &quot;jmpSan4&quot;, &quot;jmpSan5&quot;))
#
# Extract number of replicates specified by user
#
REPLICATES &lt;- as.numeric(tclvalue(replicates))


################################################################################
#
# All results in a single output - Bootstrap
#
################################################################################
#
# Create empty container object for bootstrap results
#
summaryTable &lt;- NULL
#
# Cycle through each wealth quintile
#
for(i in unique(indicatorsDF$pQuintile))
  {
  #
  # Subset survey data to slum areas
  #
  slum.data &lt;- indicatorsDF[indicatorsDF$pQuintile == i &amp; indicatorsDF$type == 1, ]
  #
  # Subset survey data to other areas
  #
  other.data &lt;- indicatorsDF[indicatorsDF$pQuintile == i &amp; indicatorsDF$type == 2, ]  
  #
  # Get survey data for all areas in current zone
  #
  all.data &lt;- indicatorsDF[indicatorsDF$pQuintile == i, ]
  #
  # Subset population data to slum areas
  #
  slum.pop &lt;- popDF[popDF$psu %in% unique(slum.data$psu) &amp; popDF$type == 1, ]
  #
  # Subset population data to other areas
  #
  other.pop &lt;- popDF[popDF$psu %in% unique(other.data$psu) &amp; popDF$type == 2, ]
  #
  # Get population data for all areas in current zone
  #
  all.pop &lt;- popDF[popDF$psu %in% unique(all.data$psu), ]
  #
  # Cycle through indicator codes
  #
  for(j in steerBoot$varList)
    {
    #
    # Select indicator and statistic pair
    #
    INDICATOR &lt;- j
    STATISTIC &lt;- steerBoot$varStatistic[steerBoot$varList == j]
    #
    # Report progress
    #
    cat(&quot;\n\n&quot;, INDICATOR, &quot; : Wealth Quintile &quot;, i, &quot;\n\n&quot;, sep = &quot;&quot;)
    #
    # Boostrap (BBW) for current indicator and statistic pair - slum
    #
    boot.slum &lt;- bootBW(x = slum.data, 
                        w = slum.pop, 
                        statistic = eval(parse(text = STATISTIC)), 
			         params = INDICATOR, 
			         outputColumns = INDICATOR, 
			         replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - other
    #
    boot.other &lt;- bootBW(x = other.data, 
			          w = other.pop, 
			          statistic = eval(parse(text = STATISTIC)), 
			          params = INDICATOR, 
			          outputColumns = INDICATOR, 
			          replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - total
    #
    boot.total &lt;- bootBW(x = all.data, 
			          w = all.pop, 
			          statistic = eval(parse(text = STATISTIC)), 
			          params = INDICATOR, 
			          outputColumns = INDICATOR, 
			          replicates = REPLICATES)     
    #
    # Concatenate various boot vectors into data.frame
    #
    boot.all &lt;- data.frame(boot.slum, boot.other, boot.total)
    names(boot.all) &lt;- c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Total&quot;)
    #
    # Create a row of results and insert quantiles of boot results
    #
    rowResult &lt;- c(unique(country), unique(ccode), unique(month), unique(year),
                   steerBoot$varNames[steerBoot$varList == j], j, paste(&quot;Wealth Quintile &quot;, i, sep = &quot;&quot;))
    for(k in names(boot.all))
      {
	 rowResult &lt;- c(rowResult, quantile(boot.all[[k]], probs = c(0.5, 0.025, 0.975), na.rm = TRUE))
      }
    #
    # Record results
    #
    summaryTable &lt;- rbind(summaryTable, rowResult)
    }
  #
  # Tidy results (row names, column types, column names, and order of rows)
  #
  summaryTable &lt;- data.frame(summaryTable, row.names = 1:nrow(summaryTable))
  #
  # Convert estimate results into numeric
  #
  for(col in 8:ncol(summaryTable))
    {
    summaryTable[, col] &lt;- as.numeric(summaryTable[, col])
    }
  }
#
# Rename summaryTable
#
names(summaryTable) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;, &quot;Month&quot;, &quot;Year&quot;,
	                    &quot;Indicator&quot;, &quot;Indicator Code&quot;, &quot;Wealth Quintile&quot;, 
           	          &quot;Low Income Area Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Other Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Total Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;)
#
# Round-off estimates to the nearest 4 decimal places
#
summaryTable[ , 8:ncol(summaryTable)] &lt;- round(summaryTable[  , 8:ncol(summaryTable)], 4)
#
# Keep the rounding off of results for table output
#
options(scipen = 10)
#
# Save summaryTable as CSV file
#
write.csv(x = summaryTable, 
  	     file = paste(&quot;outputTables/updates/surveyResultsBootWealth&quot;, 
  	                  unique(ccode), unique(month), unique(year),
  	                  &quot;.csv&quot;, sep = &quot;&quot;),
	     row.names = FALSE)
#
# Reset scipen back to 0
#
options(scipen = 0)


################################################################################
#
# Perform bootstrap
#
################################################################################
#
# Subset steerIndicators to those that can be bootstrapped
#
steerBoot &lt;- subset(steerIndicators, varStatistic != &quot;oneMean&quot;)
steerBoot &lt;- subset(steerBoot, varList %in% c(&quot;jmpSan1&quot;, &quot;jmpSan2&quot;, &quot;jmpSan3&quot;, &quot;jmpSan4&quot;, &quot;jmpSan5&quot;))

################################################################################
#
# All results in a single output - Bootstrap
#
################################################################################


#
# Determine if steerBoot is empty and decide whether to continue with next step
#
if(nrow(steerBoot) &gt; 0)
  {	
  #
  # Create empty container object for bootstrap results
  #
  summaryTableX &lt;- NULL
  #
  # Cycle through each enumeration zones
  #
  for(i in unique(indicatorsDF$zone))
    {
    #
    # Subset population data to slum areas
    #
    slum.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 1, ]
    #
    # Subset population data to other areas
    #
    other.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 2, ]
    #
    # Subset survey data to slum areas
    #
    slum.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 1, ]
    #
    # Subset survey data to other areas
    #
    other.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 2, ]  
    #
    # Get population data for all areas in current zone
    #
    all.pop &lt;- popDF[popDF$zone == i, ]
    #
    # Get survey data for all areas in current zone
    #
    all.data &lt;- indicatorsDF[indicatorsDF$zone == i, ]
    #
    # Cycle through indicator codes
    #
    for(j in steerBoot$varList)
      {
      #
      # Concatenate various boot vectors into data.frame
      #
      boot.all &lt;- data.frame(matrix(nrow = 1, ncol = 3))
      names(boot.all) &lt;- c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Total&quot;)
      #
      # Create a row of results and insert quantiles of boot results
      #
      rowResult &lt;- c(unique(country), unique(ccode), unique(month), unique(year),
                     steerBoot$varNames[steerBoot$varList == j], j, paste(&quot;Survey Area &quot;, i, sep = &quot;&quot;))
      for(k in names(boot.all))
        {
	   rowResult &lt;- c(rowResult, rep(NA, 3))
	   }
      #
      # Record results
      #
      summaryTableX &lt;- rbind(summaryTableX, rowResult)
      }
    #
    # Tidy results (row names, column types, column names, and order of rows)
    #
    summaryTableX &lt;- data.frame(summaryTableX, row.names = 1:nrow(summaryTableX))
    #
    # Convert estimate results into numeric
    #
    for(col in 8:ncol(summaryTableX))
      {
      summaryTableX[, col] &lt;- as.numeric(summaryTableX[, col])
      }
    }
  #
  # Rename summaryTable 
  #
  names(summaryTableX) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;, &quot;Month&quot;, &quot;Year&quot;,
	                       &quot;Indicator&quot;, &quot;Indicator Code&quot;, &quot;Wealth Quintile&quot;, 
	                       &quot;Low Income Area Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                       &quot;Other Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                       &quot;Total Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;)
  #
  # Round-off estimates to the nearest 4 decimal places  
  #
  summaryTableX[ , 8:ncol(summaryTableX)] &lt;- round(summaryTableX[  , 8:ncol(summaryTableX)], 4)
  #
  # Combine results data.frame
  #
  summaryTable &lt;- data.frame(rbind(summaryTable, summaryTableX))
  #
  # Keep the rounding off of results for table output
  #
  options(scipen = 10)
  #
  # Save summaryTable as CSV file
  #
  write.csv(x = summaryTable, 
	       file = paste(&quot;outputTables/updates/surveyResultsBootWealth&quot;, 
	                    unique(ccode), unique(month), unique(year),
	                    &quot;.csv&quot;, sep = &quot;&quot;),
	       row.names = FALSE)
  #
  # Reset scipen back to 0
  #
  options(scipen = 0)
  }


################################################################################
#
# Perform bootstrap
#
################################################################################
#
# Subset steerIndicators to those that can be bootstrapped
#
steerBoot &lt;- subset(steerIndicators, varStatistic == &quot;oneMean&quot;)
steerBoot &lt;- subset(steerBoot, varList %in% c(&quot;jmpSan1&quot;, &quot;jmpSan2&quot;, &quot;jmpSan3&quot;, &quot;jmpSan4&quot;, &quot;jmpSan5&quot;))
#
# Extract number of replicates specified by user
#
REPLICATES &lt;- as.numeric(tclvalue(replicates))


################################################################################
#
# All results in a single output - Bootstrap
#
################################################################################
#
# Create empty container object for bootstrap results
#
summaryTable &lt;- NULL
#
# Subset population data to slum areas
#
slum.pop &lt;- popDF[popDF$type == 1, ]
#
# Subset population data to other areas
#
other.pop &lt;- popDF[popDF$type == 2, ]
#
# Subset survey data to slum areas
#
slum.data &lt;- indicatorsDF[indicatorsDF$type == 1, ]
#
# Subset survey data to other areas
#
other.data &lt;- indicatorsDF[indicatorsDF$type == 2, ]  
#
# Get population data for all areas in current zone
#
all.pop &lt;- popDF
#
# Get survey data for all areas in current zone
#
all.data &lt;- indicatorsDF
#
# Cycle through indicator codes
#
for(i in steerBoot$varList)
  {
  #
  # Select indicator and statistic pair
  #
  INDICATOR &lt;- i
  STATISTIC &lt;- steerBoot$varStatistic[steerBoot$varList == i]
  #
  # Report progress
  #
  cat(&quot;\n\n&quot;, INDICATOR, &quot;\n\n&quot;, sep = &quot;&quot;)
  #
  # Boostrap (BBW) for current indicator and statistic pair - slum
  #
  boot.slum &lt;- bootBW(x = slum.data, 
                      w = slum.pop, 
                      statistic = eval(parse(text = STATISTIC)), 
			       params = INDICATOR, 
			       outputColumns = INDICATOR, 
			       replicates = REPLICATES)
  #
  # Boostrap (BBW) for current indicator and statistic pair - other
  #
  boot.other &lt;- bootBW(x = other.data, 
			        w = other.pop, 
			        statistic = eval(parse(text = STATISTIC)), 
			        params = INDICATOR, 
			        outputColumns = INDICATOR, 
			        replicates = REPLICATES)
  #
  # Boostrap (BBW) for current indicator and statistic pair - total
  #
  boot.total &lt;- bootBW(x = all.data, 
			        w = all.pop, 
			        statistic = eval(parse(text = STATISTIC)), 
			        params = INDICATOR, 
			        outputColumns = INDICATOR, 
			        replicates = REPLICATES)     
  #
  # Concatenate various boot vectors into data.frame
  #
  boot.all &lt;- data.frame(boot.slum, boot.other, boot.total)
  names(boot.all) &lt;- c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Total&quot;)
  #
  # Create a row of results and insert quantiles of boot results
  #
  rowResult &lt;- c(unique(country), unique(ccode), unique(month), unique(year),
                 steerBoot$varNames[steerBoot$varList == i], i, &quot;Overall&quot;)
  for(j in names(boot.all))
    {
    rowResult &lt;- c(rowResult, quantile(boot.all[[j]], probs = c(0.5, 0.025, 0.975), na.rm = TRUE))
    }
  #
  # Record results
  #
  summaryTable &lt;- rbind(summaryTable, rowResult)
  }
#
# Tidy results (row names, column types, column names, and order of rows)
#
summaryTable &lt;- data.frame(summaryTable, row.names = 1:nrow(summaryTable))
#
# Convert estimate results into numeric
#
for(col in 8:ncol(summaryTable))
  {
  summaryTable[, col] &lt;- as.numeric(summaryTable[, col])
  }
#
# Rename summaryTable
#
names(summaryTable) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;, &quot;Month&quot;, &quot;Year&quot;,
	                    &quot;Indicator&quot;, &quot;Indicator Code&quot;, &quot;Survey Area&quot;,
           	          &quot;Low Income Area Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Other Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Total Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;)
#
# Round-off estimates to the nearest 4 decimal places
#
summaryTable[ , 8:ncol(summaryTable)] &lt;- round(summaryTable[  , 8:ncol(summaryTable)], 4)
#
# Keep the rounding off of results for table output
#
options(scipen = 10)
#
# Save summaryTable as CSV file
#
write.csv(x = summaryTable, 
  	     file = paste(&quot;outputTables/updates/surveyResultsBootOverall&quot;, 
  	                  unique(ccode), unique(month), unique(year),
  	                  &quot;.csv&quot;, sep = &quot;&quot;),
	     row.names = FALSE)
#
# Reset scipen back to 0
#
options(scipen = 0)

</command>
							<property title="Estimate" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.SubflowNodeModel">
								<subflow>
									<graph version="0.8" width="1443" height="513" locationtype="a" offsetx="420" offsety="3">
										<node id="87" date="1513145303278" uid="a7002439ff97dc0e" x="30" y="0">
											<command>
################################################################################
#
# Specify bootstrapping parameters
#
################################################################################
#
# Set default number of replicates
#
replicates &lt;- tclVar(&quot;399&quot;)
#
# Create dialog box
#
choice &lt;- tktoplevel()
#
# Add title to dialog box
#
tkwm.title(choice, &quot;Bootstrap replicates&quot;)
#
# Create input box
#
replicates.entry &lt;- tkentry(choice, textvariable = replicates)
#
# RESET function for RESET button
#
reset &lt;- function()
  {
  #
  # Reset user input back to default
  #
  tclvalue(replicates) &lt;- &quot;399&quot;
  }
#
# Create reset button
#
reset.button &lt;- tkbutton(choice, text = &quot;Reset&quot;, command = reset)
#
# SUBMIT function for SUBMIT button
#
submit &lt;- function() 
  {
  #
  # Extract user input
  #
  x &lt;- as.numeric(tclvalue(replicates))
  #
  # Prompt user with input specified and ask whether to proceed
  #
  proceed &lt;- tkmessageBox(title = &quot;Bootstrap replicates&quot;,
                          message = paste(&quot;You specified &quot;, x, &quot; replicates for bootstrapping. Do you wish to continue?&quot;, sep = &quot;&quot;),
                          icon = &quot;question&quot;,
                          type = &quot;yesno&quot;)
  #
  # Determine if user does not want to continue with specified values
  #
  if(tclvalue(proceed) == &quot;no&quot;)
    {
    #
    # Prompt user that no replicates specified
    #
    tkmessageBox(title = &quot;Bootstrap replicates&quot;,
                 message = &quot;No number of replicates specified. Specify number of replicates&quot;,
                 icon = &quot;warning&quot;,
                 type = &quot;ok&quot;)
    }
  #
  # Determine if user wishes to proceed with specified replicates
  #
  if(tclvalue(proceed) == &quot;yes&quot;)
    {
    #
    # Close dialog box
    #
    tkdestroy(choice)
    }
  }
#
# Create submit button
#
submit.button &lt;- tkbutton(choice, text = &quot;Submit&quot;, command = submit)
#
# Create layout of input boxes and control buttons
# 
tkgrid(tklabel(choice, text = &quot;Specify number of bootstrap replicates&quot;), columnspan = 2, pady = 5)
tkgrid(tklabel(choice, text = &quot;Number of replicates:&quot;), replicates.entry, pady = 5, padx = 5)
tkgrid(submit.button, reset.button, pady = 5, padx = 5)

tkwait.window(choice)


 </command>
											<property title="Specify boot parameters" shape="INPUT"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<node id="88" date="1513145303279" uid="648e549e3e602b41" x="140" y="0">
											<command>
################################################################################
#
# If Country is Bangladesh...
#
################################################################################

################################################################################
#
# Identify sampling points within North and South Corporations
#
################################################################################

if(unique(country) == &quot;Bangladesh&quot;)
  {
  #
  #
  #
  temp &lt;- indicatorsDF[ , c(&quot;psu&quot;, &quot;corporation&quot;)]
  #
  #
  #	
  popDF &lt;- merge(popDF, temp, by = &quot;psu&quot;)


################################################################################
#
# Perform bootstrap
#
################################################################################
#
# Subset steerIndicators to those that can be bootstrapped
#
steerBoot &lt;- subset(steerIndicators, varStatistic == &quot;oneMean&quot;)
steerBoot &lt;- subset(steerBoot, varList %in% c(&quot;jmpSan1&quot;, &quot;jmpSan2&quot;, &quot;jmpSan3&quot;, &quot;jmpSan4&quot;, &quot;jmpSan5&quot;))
#
# Extract number of replicates specified by user
#
REPLICATES &lt;- as.numeric(tclvalue(replicates))


################################################################################
#
# All results in a single output - Bootstrap
#
################################################################################
#
# Create empty container object for bootstrap results
#
summaryTable &lt;- NULL
#
# Cycle through each enumeration zones
#
for(i in unique(indicatorsDF$corporation))
  {
  #
  # Subset population data to slum areas
  #
  slum.pop &lt;- popDF[popDF$corporation == i &amp; popDF$type == 1, ]
  #
  # Subset population data to other areas
  #
  other.pop &lt;- popDF[popDF$corporation == i &amp; popDF$type == 2, ]
  #
  # Subset survey data to slum areas
  #
  slum.data &lt;- indicatorsDF[indicatorsDF$corporation == i &amp; indicatorsDF$type == 1, ]
  #
  # Subset survey data to other areas
  #
  other.data &lt;- indicatorsDF[indicatorsDF$corporation == i &amp; indicatorsDF$type == 2, ]  
  #
  # Get population data for all areas in current zone
  #
  all.pop &lt;- popDF[popDF$corporation == i, ]
  #
  # Get survey data for all areas in current zone
  #
  all.data &lt;- indicatorsDF[indicatorsDF$corporation == i, ]
  #
  # Cycle through indicator codes
  #
  for(j in steerBoot$varList)
    {
    #
    # Select indicator and statistic pair
    #
    INDICATOR &lt;- j
    STATISTIC &lt;- steerBoot$varStatistic[steerBoot$varList == j]
    #
    # Report progress
    #
    cat(&quot;\n\n&quot;, INDICATOR, &quot; : Survey Area &quot;, i, &quot;\n\n&quot;, sep = &quot;&quot;)
    #
    # Boostrap (BBW) for current indicator and statistic pair - slum
    #
    boot.slum &lt;- bootBW(x = slum.data, 
                        w = slum.pop, 
                        statistic = eval(parse(text = STATISTIC)), 
			         params = INDICATOR, 
			         outputColumns = INDICATOR, 
			         replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - other
    #
    boot.other &lt;- bootBW(x = other.data, 
			          w = other.pop, 
			          statistic = eval(parse(text = STATISTIC)), 
			          params = INDICATOR, 
			          outputColumns = INDICATOR, 
			          replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - total
    #
    boot.total &lt;- bootBW(x = all.data, 
			          w = all.pop, 
			          statistic = eval(parse(text = STATISTIC)), 
			          params = INDICATOR, 
			          outputColumns = INDICATOR, 
			          replicates = REPLICATES)     
    #
    # Concatenate various boot vectors into data.frame
    #
    boot.all &lt;- data.frame(boot.slum, boot.other, boot.total)
    names(boot.all) &lt;- c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Total&quot;)
    #
    # Create a row of results and insert quantiles of boot results
    #
    rowResult &lt;- c(unique(country), unique(ccode), unique(month), unique(year), 
                   steerBoot$varNames[steerBoot$varList == j], j, i)
    for(k in names(boot.all))
      {
	 rowResult &lt;- c(rowResult, quantile(boot.all[[k]], probs = c(0.5, 0.025, 0.975), na.rm = TRUE))
      }
    #
    # Record results
    #
    summaryTable &lt;- rbind(summaryTable, rowResult)
    }
  #
  # Tidy results (row names, column types, column names, and order of rows)
  #
  summaryTable &lt;- data.frame(summaryTable, row.names = 1:nrow(summaryTable))
  #
  # Convert estimate results into numeric
  #
  for(col in 8:ncol(summaryTable))
    {
    summaryTable[, col] &lt;- as.numeric(summaryTable[, col])
    }
  }
#
# Rename summaryTable
#
names(summaryTable) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;, &quot;Month&quot;, &quot;Year&quot;,
	                    &quot;Indicator&quot;, &quot;Indicator Code&quot;, &quot;Survey Area&quot;, 
           	          &quot;Low Income Area Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Other Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Total Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;)
#
# Round-off estimates to the nearest 4 decimal places
#
summaryTable[ , 8:ncol(summaryTable)] &lt;- round(summaryTable[  , 8:ncol(summaryTable)], 4)
#
# Keep the rounding off of results for table output
#
options(scipen = 10)
#
# Save summaryTable as CSV file
#
write.csv(x = summaryTable, 
  	     file = paste(&quot;outputTables/updates/surveyResultsBootCorporation&quot;, 
  	                  unique(ccode), unique(month), unique(year),
  	                  &quot;.csv&quot;, sep = &quot;&quot;),
	     row.names = FALSE)
#
# Reset scipen back to 0
#
options(scipen = 0)


################################################################################
#
# Perform bootstrap
#
################################################################################
#
# Subset steerIndicators to those that can be bootstrapped
#
steerBoot &lt;- subset(steerIndicators, varStatistic != &quot;oneMean&quot;)
steerBoot &lt;- subset(steerBoot, varList %in% c(&quot;jmpSan1&quot;, &quot;jmpSan2&quot;, &quot;jmpSan3&quot;, &quot;jmpSan4&quot;, &quot;jmpSan5&quot;))

################################################################################
#
# All results in a single output - Bootstrap
#
################################################################################
#
# Determine if steerBoot is empty and decide whether to continue with next step
#
if(nrow(steerBoot) &gt; 0)
  {
  #
  # Create empty container object for bootstrap results  
  #
  summaryTableX &lt;- NULL
  #  
# Cycle through each enumeration zones
#
for(i in unique(indicatorsDF$corporation))
  {
  #
  # Subset population data to slum areas
  #
  slum.pop &lt;- popDF[popDF$corporation == i &amp; popDF$type == 1, ]
  #
  # Subset population data to other areas
  #
  other.pop &lt;- popDF[popDF$corporation == i &amp; popDF$type == 2, ]
  #
  # Subset survey data to slum areas
  #
  slum.data &lt;- indicatorsDF[indicatorsDF$corporation == i &amp; indicatorsDF$type == 1, ]
  #
  # Subset survey data to other areas
  #
  other.data &lt;- indicatorsDF[indicatorsDF$corporation == i &amp; indicatorsDF$type == 2, ]  
  #
  # Get population data for all areas in current zone
  #
  all.pop &lt;- popDF[popDF$corporation == i, ]
  #
  # Get survey data for all areas in current zone
  #
  all.data &lt;- indicatorsDF[indicatorsDF$corporation == i, ]
  #
  # Cycle through indicator codes
  #
  for(j in steerBoot$varList)
    {
    #
    # Concatenate various boot vectors into data.frame
    #
    boot.all &lt;- data.frame(matrix(nrow = 1, ncol = 3))
    names(boot.all) &lt;- c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Total&quot;)
    #
    # Create a row of results and insert quantiles of boot results
    #
    rowResult &lt;- c(unique(country), unique(ccode), unique(month), unique(year),
                   steerBoot$varNames[steerBoot$varList == j], j, i)
    for(k in names(boot.all))
      {
	 rowResult &lt;- c(rowResult, rep(NA, 3))
	 }
    #
    # Record results
    #
    summaryTableX &lt;- rbind(summaryTableX, rowResult)
    }
  #
  # Tidy results (row names, column types, column names, and order of rows)
  #
  if(!is.null(summaryTableX))
    {
    summaryTableX &lt;- data.frame(summaryTableX, row.names = 1:nrow(summaryTableX))
    #
    # Convert estimate results into numeric
    #
    for(col in 8:ncol(summaryTableX))
      {
      summaryTableX[, col] &lt;- as.numeric(summaryTableX[, col])
      }
    }
  }
 
  if(!is.null(summaryTableX))
    {
    #
    # Rename summaryTable
    #
    names(summaryTableX) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;, &quot;Month&quot;, &quot;Year&quot;,
	                         &quot;Indicator&quot;, &quot;Indicator Code&quot;, &quot;Survey Area&quot;, 
	                         &quot;Low Income Area Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                         &quot;Other Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                         &quot;Total Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;)
    #
    # Round-off estimates to the nearest 4 decimal places
    #
    summaryTableX[ , 8:ncol(summaryTableX)] &lt;- round(summaryTableX[  , 8:ncol(summaryTableX)], 4)
    }

#
# Combine results data.frame
#
summaryTable &lt;- data.frame(rbind(summaryTable, summaryTableX))
#
# Keep the rounding off of results for table output
#
options(scipen = 10)
#
# Save summaryTable as CSV file
#
write.csv(x = summaryTable, 
	     file = paste(&quot;outputTables/updates/surveyResultsBootCorporation&quot;, 
	                  unique(ccode), unique(month), unique(year),
	                  &quot;.csv&quot;, sep = &quot;&quot;),
	     row.names = FALSE)
#
# Reset scipen back to 0
#
options(scipen = 0)
}
}

</command>
											<property title="Estimate by corporation" shape="MODEL"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<node id="89" date="1513145303279" uid="7845a92932b50c49" x="-50" y="0">
											<command></command>
											<property/>
											<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
												<entry key="io">in</entry>
											</option>
										</node>
										<node id="90" date="1513145303278" uid="59aca02557525517" x="110" y="230">
											<command></command>
											<property/>
											<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
												<entry key="io">out</entry>
											</option>
										</node>
										<node id="91" date="1513145303278" uid="3b60536d6f68f14d" x="30" y="230">
											<command>
################################################################################
#
# Perform bootstrap
#
################################################################################
#
# Subset steerIndicators to those that can be bootstrapped
#
steerBoot &lt;- subset(steerIndicators, varStatistic == &quot;oneMean&quot;)
steerBoot &lt;- subset(steerBoot, varList %in% c(&quot;jmpSan1&quot;, &quot;jmpSan2&quot;, &quot;jmpSan3&quot;, &quot;jmpSan4&quot;, &quot;jmpSan5&quot;))
#
# Extract number of replicates specified by user
#
REPLICATES &lt;- as.numeric(tclvalue(replicates))


################################################################################
#
# All results in a single output - Bootstrap
#
################################################################################
#
# Create empty container object for bootstrap results
#
summaryTable &lt;- NULL
#
# Subset population data to slum areas
#
slum.pop &lt;- popDF[popDF$type == 1, ]
#
# Subset population data to other areas
#
other.pop &lt;- popDF[popDF$type == 2, ]
#
# Subset survey data to slum areas
#
slum.data &lt;- indicatorsDF[indicatorsDF$type == 1, ]
#
# Subset survey data to other areas
#
other.data &lt;- indicatorsDF[indicatorsDF$type == 2, ]  
#
# Get population data for all areas in current zone
#
all.pop &lt;- popDF
#
# Get survey data for all areas in current zone
#
all.data &lt;- indicatorsDF
#
# Cycle through indicator codes
#
for(i in steerBoot$varList)
  {
  #
  # Select indicator and statistic pair
  #
  INDICATOR &lt;- i
  STATISTIC &lt;- steerBoot$varStatistic[steerBoot$varList == i]
  #
  # Report progress
  #
  cat(&quot;\n\n&quot;, INDICATOR, &quot;\n\n&quot;, sep = &quot;&quot;)
  #
  # Boostrap (BBW) for current indicator and statistic pair - slum
  #
  boot.slum &lt;- bootBW(x = slum.data, 
                      w = slum.pop, 
                      statistic = eval(parse(text = STATISTIC)), 
			       params = INDICATOR, 
			       outputColumns = INDICATOR, 
			       replicates = REPLICATES)
  #
  # Boostrap (BBW) for current indicator and statistic pair - other
  #
  boot.other &lt;- bootBW(x = other.data, 
			        w = other.pop, 
			        statistic = eval(parse(text = STATISTIC)), 
			        params = INDICATOR, 
			        outputColumns = INDICATOR, 
			        replicates = REPLICATES)
  #
  # Boostrap (BBW) for current indicator and statistic pair - total
  #
  boot.total &lt;- bootBW(x = all.data, 
			        w = all.pop, 
			        statistic = eval(parse(text = STATISTIC)), 
			        params = INDICATOR, 
			        outputColumns = INDICATOR, 
			        replicates = REPLICATES)     
  #
  # Concatenate various boot vectors into data.frame
  #
  boot.all &lt;- data.frame(boot.slum, boot.other, boot.total)
  names(boot.all) &lt;- c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Total&quot;)
  #
  # Create a row of results and insert quantiles of boot results
  #
  rowResult &lt;- c(unique(country), unique(ccode), unique(month), unique(year),
                 steerBoot$varNames[steerBoot$varList == i], i, &quot;Overall&quot;)
  for(j in names(boot.all))
    {
    rowResult &lt;- c(rowResult, quantile(boot.all[[j]], probs = c(0.5, 0.025, 0.975), na.rm = TRUE))
    }
  #
  # Record results
  #
  summaryTable &lt;- rbind(summaryTable, rowResult)
  }
#
# Tidy results (row names, column types, column names, and order of rows)
#
summaryTable &lt;- data.frame(summaryTable, row.names = 1:nrow(summaryTable))
#
# Convert estimate results into numeric
#
for(col in 8:ncol(summaryTable))
  {
  summaryTable[, col] &lt;- as.numeric(summaryTable[, col])
  }
#
# Rename summaryTable
#
names(summaryTable) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;, &quot;Month&quot;, &quot;Year&quot;,
	                    &quot;Indicator&quot;, &quot;Indicator Code&quot;, &quot;Survey Area&quot;,
           	          &quot;Low Income Area Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Other Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Total Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;)
#
# Round-off estimates to the nearest 4 decimal places
#
summaryTable[ , 8:ncol(summaryTable)] &lt;- round(summaryTable[  , 8:ncol(summaryTable)], 4)
#
# Keep the rounding off of results for table output
#
options(scipen = 10)
#
# Save summaryTable as CSV file
#
write.csv(x = summaryTable, 
  	     file = paste(&quot;outputTables/updates/surveyResultsBootOverall&quot;, 
  	                  unique(ccode), unique(month), unique(year),
  	                  &quot;.csv&quot;, sep = &quot;&quot;),
	     row.names = FALSE)
#
# Reset scipen back to 0
#
options(scipen = 0)

</command>
											<property title="Estimate overall" shape="MODEL"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<node id="92" date="1513145303279" uid="e1aa30c1c082abb1" x="30" y="150">
											<command>
################################################################################
#
# Perform bootstrap
#
################################################################################
#
# Subset steerIndicators to those that can be bootstrapped
#
steerBoot &lt;- subset(steerIndicators, varStatistic == &quot;oneMean&quot;)
steerBoot &lt;- subset(steerBoot, varList %in% c(&quot;jmpSan1&quot;, &quot;jmpSan2&quot;, &quot;jmpSan3&quot;, &quot;jmpSan4&quot;, &quot;jmpSan5&quot;))
#
# Extract number of replicates specified by user
#
REPLICATES &lt;- as.numeric(tclvalue(replicates))


################################################################################
#
# All results in a single output - Bootstrap
#
################################################################################
#
# Create empty container object for bootstrap results
#
summaryTable &lt;- NULL
#
# Cycle through each wealth quintile
#
for(i in unique(indicatorsDF$pQuintile))
  {
  #
  # Subset survey data to slum areas
  #
  slum.data &lt;- indicatorsDF[indicatorsDF$pQuintile == i &amp; indicatorsDF$type == 1, ]
  #
  # Subset survey data to other areas
  #
  other.data &lt;- indicatorsDF[indicatorsDF$pQuintile == i &amp; indicatorsDF$type == 2, ]  
  #
  # Get survey data for all areas in current zone
  #
  all.data &lt;- indicatorsDF[indicatorsDF$pQuintile == i, ]
  #
  # Subset population data to slum areas
  #
  slum.pop &lt;- popDF[popDF$psu %in% unique(slum.data$psu) &amp; popDF$type == 1, ]
  #
  # Subset population data to other areas
  #
  other.pop &lt;- popDF[popDF$psu %in% unique(other.data$psu) &amp; popDF$type == 2, ]
  #
  # Get population data for all areas in current zone
  #
  all.pop &lt;- popDF[popDF$psu %in% unique(all.data$psu), ]
  #
  # Cycle through indicator codes
  #
  for(j in steerBoot$varList)
    {
    #
    # Select indicator and statistic pair
    #
    INDICATOR &lt;- j
    STATISTIC &lt;- steerBoot$varStatistic[steerBoot$varList == j]
    #
    # Report progress
    #
    cat(&quot;\n\n&quot;, INDICATOR, &quot; : Wealth Quintile &quot;, i, &quot;\n\n&quot;, sep = &quot;&quot;)
    #
    # Boostrap (BBW) for current indicator and statistic pair - slum
    #
    boot.slum &lt;- bootBW(x = slum.data, 
                        w = slum.pop, 
                        statistic = eval(parse(text = STATISTIC)), 
			         params = INDICATOR, 
			         outputColumns = INDICATOR, 
			         replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - other
    #
    boot.other &lt;- bootBW(x = other.data, 
			          w = other.pop, 
			          statistic = eval(parse(text = STATISTIC)), 
			          params = INDICATOR, 
			          outputColumns = INDICATOR, 
			          replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - total
    #
    boot.total &lt;- bootBW(x = all.data, 
			          w = all.pop, 
			          statistic = eval(parse(text = STATISTIC)), 
			          params = INDICATOR, 
			          outputColumns = INDICATOR, 
			          replicates = REPLICATES)     
    #
    # Concatenate various boot vectors into data.frame
    #
    boot.all &lt;- data.frame(boot.slum, boot.other, boot.total)
    names(boot.all) &lt;- c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Total&quot;)
    #
    # Create a row of results and insert quantiles of boot results
    #
    rowResult &lt;- c(unique(country), unique(ccode), unique(month), unique(year),
                   steerBoot$varNames[steerBoot$varList == j], j, paste(&quot;Wealth Quintile &quot;, i, sep = &quot;&quot;))
    for(k in names(boot.all))
      {
	 rowResult &lt;- c(rowResult, quantile(boot.all[[k]], probs = c(0.5, 0.025, 0.975), na.rm = TRUE))
      }
    #
    # Record results
    #
    summaryTable &lt;- rbind(summaryTable, rowResult)
    }
  #
  # Tidy results (row names, column types, column names, and order of rows)
  #
  summaryTable &lt;- data.frame(summaryTable, row.names = 1:nrow(summaryTable))
  #
  # Convert estimate results into numeric
  #
  for(col in 8:ncol(summaryTable))
    {
    summaryTable[, col] &lt;- as.numeric(summaryTable[, col])
    }
  }
#
# Rename summaryTable
#
names(summaryTable) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;, &quot;Month&quot;, &quot;Year&quot;,
	                    &quot;Indicator&quot;, &quot;Indicator Code&quot;, &quot;Wealth Quintile&quot;, 
           	          &quot;Low Income Area Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Other Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Total Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;)
#
# Round-off estimates to the nearest 4 decimal places
#
summaryTable[ , 8:ncol(summaryTable)] &lt;- round(summaryTable[  , 8:ncol(summaryTable)], 4)
#
# Keep the rounding off of results for table output
#
options(scipen = 10)
#
# Save summaryTable as CSV file
#
write.csv(x = summaryTable, 
  	     file = paste(&quot;outputTables/updates/surveyResultsBootWealth&quot;, 
  	                  unique(ccode), unique(month), unique(year),
  	                  &quot;.csv&quot;, sep = &quot;&quot;),
	     row.names = FALSE)
#
# Reset scipen back to 0
#
options(scipen = 0)


################################################################################
#
# Perform bootstrap
#
################################################################################
#
# Subset steerIndicators to those that can be bootstrapped
#
steerBoot &lt;- subset(steerIndicators, varStatistic != &quot;oneMean&quot;)
steerBoot &lt;- subset(steerBoot, varList %in% c(&quot;jmpSan1&quot;, &quot;jmpSan2&quot;, &quot;jmpSan3&quot;, &quot;jmpSan4&quot;, &quot;jmpSan5&quot;))

################################################################################
#
# All results in a single output - Bootstrap
#
################################################################################


#
# Determine if steerBoot is empty and decide whether to continue with next step
#
if(nrow(steerBoot) &gt; 0)
  {	
  #
  # Create empty container object for bootstrap results
  #
  summaryTableX &lt;- NULL
  #
  # Cycle through each enumeration zones
  #
  for(i in unique(indicatorsDF$zone))
    {
    #
    # Subset population data to slum areas
    #
    slum.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 1, ]
    #
    # Subset population data to other areas
    #
    other.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 2, ]
    #
    # Subset survey data to slum areas
    #
    slum.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 1, ]
    #
    # Subset survey data to other areas
    #
    other.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 2, ]  
    #
    # Get population data for all areas in current zone
    #
    all.pop &lt;- popDF[popDF$zone == i, ]
    #
    # Get survey data for all areas in current zone
    #
    all.data &lt;- indicatorsDF[indicatorsDF$zone == i, ]
    #
    # Cycle through indicator codes
    #
    for(j in steerBoot$varList)
      {
      #
      # Concatenate various boot vectors into data.frame
      #
      boot.all &lt;- data.frame(matrix(nrow = 1, ncol = 3))
      names(boot.all) &lt;- c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Total&quot;)
      #
      # Create a row of results and insert quantiles of boot results
      #
      rowResult &lt;- c(unique(country), unique(ccode), unique(month), unique(year),
                     steerBoot$varNames[steerBoot$varList == j], j, paste(&quot;Survey Area &quot;, i, sep = &quot;&quot;))
      for(k in names(boot.all))
        {
	   rowResult &lt;- c(rowResult, rep(NA, 3))
	   }
      #
      # Record results
      #
      summaryTableX &lt;- rbind(summaryTableX, rowResult)
      }
    #
    # Tidy results (row names, column types, column names, and order of rows)
    #
    summaryTableX &lt;- data.frame(summaryTableX, row.names = 1:nrow(summaryTableX))
    #
    # Convert estimate results into numeric
    #
    for(col in 8:ncol(summaryTableX))
      {
      summaryTableX[, col] &lt;- as.numeric(summaryTableX[, col])
      }
    }
  #
  # Rename summaryTable 
  #
  names(summaryTableX) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;, &quot;Month&quot;, &quot;Year&quot;,
	                       &quot;Indicator&quot;, &quot;Indicator Code&quot;, &quot;Wealth Quintile&quot;, 
	                       &quot;Low Income Area Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                       &quot;Other Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                       &quot;Total Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;)
  #
  # Round-off estimates to the nearest 4 decimal places  
  #
  summaryTableX[ , 8:ncol(summaryTableX)] &lt;- round(summaryTableX[  , 8:ncol(summaryTableX)], 4)
  #
  # Combine results data.frame
  #
  summaryTable &lt;- data.frame(rbind(summaryTable, summaryTableX))
  #
  # Keep the rounding off of results for table output
  #
  options(scipen = 10)
  #
  # Save summaryTable as CSV file
  #
  write.csv(x = summaryTable, 
	       file = paste(&quot;outputTables/updates/surveyResultsBootWealth&quot;, 
	                    unique(ccode), unique(month), unique(year),
	                    &quot;.csv&quot;, sep = &quot;&quot;),
	       row.names = FALSE)
  #
  # Reset scipen back to 0
  #
  options(scipen = 0)
  }
</command>
											<property title="Estimate by wealth" shape="MODEL"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<node id="93" date="1513145303280" uid="6d7ac278a178bbbc" x="30" y="70">
											<command>
################################################################################
#
# Perform bootstrap
#
################################################################################
#
# Subset steerIndicators to those that can be bootstrapped
#
steerBoot &lt;- subset(steerIndicators, varStatistic == &quot;oneMean&quot;)
steerBoot &lt;- subset(steerBoot, varList %in% c(&quot;jmpSan1&quot;, &quot;jmpSan2&quot;, &quot;jmpSan3&quot;, &quot;jmpSan4&quot;, &quot;jmpSan5&quot;))
#
# Extract number of replicates specified by user
#
REPLICATES &lt;- as.numeric(tclvalue(replicates))


################################################################################
#
# All results in a single output - Bootstrap
#
################################################################################
#
# Create empty container object for bootstrap results
#
summaryTable &lt;- NULL
#
# Cycle through each enumeration zones
#
for(i in unique(indicatorsDF$zone))
  {
  #
  # Subset population data to slum areas
  #
  slum.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 1, ]
  #
  # Subset population data to other areas
  #
  other.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 2, ]
  #
  # Subset survey data to slum areas
  #
  slum.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 1, ]
  #
  # Subset survey data to other areas
  #
  other.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 2, ]  
  #
  # Get population data for all areas in current zone
  #
  all.pop &lt;- popDF[popDF$zone == i, ]
  #
  # Get survey data for all areas in current zone
  #
  all.data &lt;- indicatorsDF[indicatorsDF$zone == i, ]
  #
  # Cycle through indicator codes
  #
  for(j in steerBoot$varList)
    {
    #
    # Select indicator and statistic pair
    #
    INDICATOR &lt;- j
    STATISTIC &lt;- steerBoot$varStatistic[steerBoot$varList == j]
    #
    # Report progress
    #
    cat(&quot;\n\n&quot;, INDICATOR, &quot; : Survey Area &quot;, i, &quot;\n\n&quot;, sep = &quot;&quot;)
    #
    # Boostrap (BBW) for current indicator and statistic pair - slum
    #
    boot.slum &lt;- bootBW(x = slum.data, 
                        w = slum.pop, 
                        statistic = eval(parse(text = STATISTIC)), 
			         params = INDICATOR, 
			         outputColumns = INDICATOR, 
			         replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - other
    #
    boot.other &lt;- bootBW(x = other.data, 
			          w = other.pop, 
			          statistic = eval(parse(text = STATISTIC)), 
			          params = INDICATOR, 
			          outputColumns = INDICATOR, 
			          replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - total
    #
    boot.total &lt;- bootBW(x = all.data, 
			          w = all.pop, 
			          statistic = eval(parse(text = STATISTIC)), 
			          params = INDICATOR, 
			          outputColumns = INDICATOR, 
			          replicates = REPLICATES)     
    #
    # Concatenate various boot vectors into data.frame
    #
    boot.all &lt;- data.frame(boot.slum, boot.other, boot.total)
    names(boot.all) &lt;- c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Total&quot;)
    #
    # Create a row of results and insert quantiles of boot results
    #
    rowResult &lt;- c(unique(country), unique(ccode), unique(month), unique(year), 
                   steerBoot$varNames[steerBoot$varList == j], j, paste(&quot;Survey Area &quot;, i, sep = &quot;&quot;))
    for(k in names(boot.all))
      {
	 rowResult &lt;- c(rowResult, quantile(boot.all[[k]], probs = c(0.5, 0.025, 0.975), na.rm = TRUE))
      }
    #
    # Record results
    #
    summaryTable &lt;- rbind(summaryTable, rowResult)
    }
  #
  # Tidy results (row names, column types, column names, and order of rows)
  #
  summaryTable &lt;- data.frame(summaryTable, row.names = 1:nrow(summaryTable))
  #
  # Convert estimate results into numeric
  #
  for(col in 8:ncol(summaryTable))
    {
    summaryTable[, col] &lt;- as.numeric(summaryTable[, col])
    }
  }
#
# Rename summaryTable
#
names(summaryTable) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;, &quot;Month&quot;, &quot;Year&quot;,
	                    &quot;Indicator&quot;, &quot;Indicator Code&quot;, &quot;Survey Area&quot;, 
           	          &quot;Low Income Area Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Other Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Total Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;)
#
# Round-off estimates to the nearest 4 decimal places
#
summaryTable[ , 8:ncol(summaryTable)] &lt;- round(summaryTable[  , 8:ncol(summaryTable)], 4)
#
# Keep the rounding off of results for table output
#
options(scipen = 10)
#
# Save summaryTable as CSV file
#
write.csv(x = summaryTable, 
  	     file = paste(&quot;outputTables/updates/surveyResultsBoot&quot;, 
  	                  unique(ccode), unique(month), unique(year),
  	                  &quot;.csv&quot;, sep = &quot;&quot;),
	     row.names = FALSE)
#
# Reset scipen back to 0
#
options(scipen = 0)


################################################################################
#
# Perform bootstrap
#
################################################################################
#
# Subset steerIndicators to those that can be bootstrapped
#
steerBoot &lt;- subset(steerIndicators, varStatistic != &quot;oneMean&quot;)
steerBoot &lt;- subset(steerBoot, varList %in% c(&quot;jmpSan1&quot;, &quot;jmpSan2&quot;, &quot;jmpSan3&quot;, &quot;jmpSan4&quot;, &quot;jmpSan5&quot;))

################################################################################
#
# All results in a single output - Bootstrap
#
################################################################################
#
# Determine if steerBoot is empty and decide whether to continue with next step
#
if(nrow(steerBoot) &gt; 0)
  {
  #
  # Create empty container object for bootstrap results  
  #
  summaryTableX &lt;- NULL
  #  
# Cycle through each enumeration zones
#
for(i in unique(indicatorsDF$zone))
  {
  #
  # Subset population data to slum areas
  #
  slum.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 1, ]
  #
  # Subset population data to other areas
  #
  other.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 2, ]
  #
  # Subset survey data to slum areas
  #
  slum.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 1, ]
  #
  # Subset survey data to other areas
  #
  other.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 2, ]  
  #
  # Get population data for all areas in current zone
  #
  all.pop &lt;- popDF[popDF$zone == i, ]
  #
  # Get survey data for all areas in current zone
  #
  all.data &lt;- indicatorsDF[indicatorsDF$zone == i, ]
  #
  # Cycle through indicator codes
  #
  for(j in steerBoot$varList)
    {
    #
    # Concatenate various boot vectors into data.frame
    #
    boot.all &lt;- data.frame(matrix(nrow = 1, ncol = 3))
    names(boot.all) &lt;- c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Total&quot;)
    #
    # Create a row of results and insert quantiles of boot results
    #
    rowResult &lt;- c(unique(country), unique(ccode), unique(month), unique(year),
                   steerBoot$varNames[steerBoot$varList == j], j, paste(&quot;Survey Area &quot;, i, sep = &quot;&quot;))
    for(k in names(boot.all))
      {
	 rowResult &lt;- c(rowResult, rep(NA, 3))
	 }
    #
    # Record results
    #
    summaryTableX &lt;- rbind(summaryTableX, rowResult)
    }
  #
  # Tidy results (row names, column types, column names, and order of rows)
  #
  if(!is.null(summaryTableX))
    {
    summaryTableX &lt;- data.frame(summaryTableX, row.names = 1:nrow(summaryTableX))
    #
    # Convert estimate results into numeric
    #
    for(col in 8:ncol(summaryTableX))
      {
      summaryTableX[, col] &lt;- as.numeric(summaryTableX[, col])
      }
    }
  }
 
  if(!is.null(summaryTableX))
    {
    #
    # Rename summaryTable
    #
    names(summaryTableX) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;, &quot;Month&quot;, &quot;Year&quot;,
	                         &quot;Indicator&quot;, &quot;Indicator Code&quot;, &quot;Survey Area&quot;, 
	                         &quot;Low Income Area Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                         &quot;Other Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                         &quot;Total Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;)
    #
    # Round-off estimates to the nearest 4 decimal places
    #
    summaryTableX[ , 8:ncol(summaryTableX)] &lt;- round(summaryTableX[  , 8:ncol(summaryTableX)], 4)
    }

#
# Combine results data.frame
#
summaryTable &lt;- data.frame(rbind(summaryTable, summaryTableX))
#
# Keep the rounding off of results for table output
#
options(scipen = 10)
#
# Save summaryTable as CSV file
#
write.csv(x = summaryTable, 
	     file = paste(&quot;outputTables/updates/surveyResultsBoot&quot;, 
	                  unique(ccode), unique(month), unique(year),
	                  &quot;.csv&quot;, sep = &quot;&quot;),
	     row.names = FALSE)
#
# Reset scipen back to 0
#
options(scipen = 0)
}

</command>
											<property title="Estimate by area" shape="MODEL"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<edge from="87" to="93"/>
										<edge from="89" to="87"/>
										<edge from="92" to="91"/>
										<edge from="93" to="92"/>
										<edge from="87" to="88"/>
										<edge from="91" to="90"/>
									</graph>
								</subflow>
							</option>
						</node>
						<node id="94" date="1510899093938" uid="679ea78a1f6cfa01" x="370" y="540">
							<command>

################################################################################
#
#  Select and read indicator data: Accepts CSV data files
#
################################################################################
#
# Prompt user to supply indicator data file
#
tkmessageBox(title = &quot;Load file&quot;,
	        message = &quot;Select indicators data file&quot;, 
	        icon = &quot;info&quot;, 
	        type = &quot;ok&quot;)
#
# Cycle through indicator data file selection prompts
#
repeat
  {
  #
  # Cycle through indicator data file selection prompts when no file is selected
  #
  repeat
    {
    #
    # Select indicator data file
    #
    fileName &lt;- tclvalue(tkgetOpenFile())
    #
    # Determine if a indicator data file has been selected
    #	
    if(!nchar(fileName)) 
      {
      #
      # Prompt user that no file has been selected
      #
      error1 &lt;- tkmessageBox(title = &quot;Error&quot;,
				         message = &quot;No file was selected! Please try again.&quot;,
				         icon = &quot;error&quot;,
				         type = &quot;retrycancel&quot;)
      }
    #
    # Break repeat once any file has been selected
    #	
    if(nchar(fileName) &gt; 0) break
    #
    # Break repeat if user cancels option to select file
    #
    if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  }
  #
  # Break repeat if user cancels option to select file
  #
  if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  #
  # Try to read indicator steering file based on filename provided by user
  #
  indicatorsDF &lt;- try(expr = read.csv(file = fileName, header = TRUE, sep = &quot;,&quot;), 
		            silent = TRUE)
  #
  # Check if indicator steering file provided is in correct format (CSV file)
  #
  if(exists(&quot;indicatorsDF&quot;) &amp;&amp; class(indicatorsDF) == &quot;try-error&quot;)
    {
    #
    # Prompt user that file format is incorrect
    #
    error2 &lt;- tkmessageBox(title = &quot;Error&quot;,
			            message = paste(&quot;Problem reading file &apos;&quot;, basename(fileName), &quot;&apos;. Please try again&quot;, sep = &quot;,&quot;),
			            icon = &quot;error&quot;,
			            type = &quot;retrycancel&quot;)
    }
  #
  # Break repeat once selected indicator data file is in correct format
  #
  if(exists(&quot;indicatorsDF&quot;) &amp;&amp; class(indicatorsDF) != &quot;try-error&quot;) break
  #
  # Break repeat if user cancels option to retry providing a new file
  #
  if(exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;) break
  }
#
# Determine if user cancels option to select file or cancels option to retry providing a new file
#
if((exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) | (exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;))
  {
  #
  # Prompt user that no file has been loaded
  #
  tkmessageBox(title = &quot;Warning&quot;,
 		     message = &quot;You have not loaded any data file&quot;,
		     icon = &quot;warning&quot;,
		     type = &quot;ok&quot;)
  }
#
# Determine user has successfully selected and loaded an appropriate data file
#
if(exists(&quot;indicatorsDF&quot;) &amp;&amp; class(indicatorsDF) != &quot;try-error&quot;)
  {
  #
  # Prompt use of the filename of the indicator steering file file selected
  #
  tkmessageBox(title = &quot;Success!&quot;,
		     message = paste(&quot;You have loaded the data file named &apos;&quot;, basename(fileName), &quot;&apos;.&quot;, sep = &quot;&quot;),
		     icon = &quot;info&quot;,
		     type = &quot;ok&quot;)
  }
#
# Clean-up filename
#
rm(fileName)
#
# Clean-up error1 if present
#
if(exists(&quot;error1&quot;))
  {
  rm(error1)
  }
#
# Clean-up error2 if present
#
if(exists(&quot;error2&quot;))
  {
  rm(error2)
  }



################################################################################
#
#  Select and read indicator steering file: Accepts CSV data files
#
################################################################################
#
# Prompt user to supply indicator steering file
#
tkmessageBox(title = &quot;Load file&quot;,
             message = &quot;Select indicators steering file&quot;, 
	        icon = &quot;info&quot;, 
	        type = &quot;ok&quot;)
#
# Cycle through indicator steering file selection prompts
#
repeat
  {
  #
  # Cycle through indicator steering file selection prompts when no file is selected
  #
  repeat
    {
    #
    # Select indicator steering file
    #
    fileName &lt;- tclvalue(tkgetOpenFile())
    #
    # Determine if a indicator steering file has been selected
    #	
    if(!nchar(fileName)) 
      {
      #
      # Prompt user that no file has been selected
      #
      error1 &lt;- tkmessageBox(title = &quot;Error&quot;,
				         message = &quot;No file was selected! Please try again.&quot;,
				         icon = &quot;error&quot;,
				         type = &quot;retrycancel&quot;)
      }
    #
    # Break repeat once any file has been selected
    #	
    if(nchar(fileName) &gt; 0) break
    #
    # Break repeat if user cancels option to select file
    #
    if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
    } 
  #
  # Break repeat if user cancels option to select file
  #
  if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  #
  # Try to read indicator steering file based on filename provided by user
  #	
  steerIndicators &lt;- try(expr = read.csv(file = fileName, header = TRUE, sep = &quot;,&quot;), 
		               silent = TRUE)
  #
  # Check if indicator steering file provided is in correct format (CSV file)
  #
  if(exists(&quot;steerIndicators&quot;) &amp;&amp; class(steerIndicators) == &quot;try-error&quot;)
    {
    #
    # Prompt user that file format is incorrect
    #
    error2 &lt;- tkmessageBox(title = &quot;Error&quot;,
			            message = paste(&quot;Problem reading file &apos;&quot;, basename(fileName), &quot;&apos;. Please try again&quot;, sep = &quot;,&quot;),
			            icon = &quot;error&quot;,
			            type = &quot;retrycancel&quot;)
    }
  #
  # Break repeat once selected indicator steering file is in correct format
  #
  if(exists(&quot;steerIndicators&quot;) &amp;&amp; class(steerIndicators) != &quot;try-error&quot;) break
  #
  # Break repeat if user cancels option to retry providing a new file
  #
  if(exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;) break
  }
#
# Determine if user cancels option to select file or cancels option to retry providing a new file
#
if((exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) | (exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;))
  {
  #
  # Prompt user that no file has been loaded
  #
  tkmessageBox(title = &quot;Warning&quot;,
		     message = &quot;You have not loaded any data file&quot;,
		     icon = &quot;warning&quot;,
		     type = &quot;ok&quot;)
  }
#
# Determine user has successfully selected and loaded an appropriate data file
#
if(exists(&quot;steerIndicators&quot;) &amp;&amp; class(steerIndicators) != &quot;try-error&quot;)
  {
  #
  # Prompt use of the filename of the indicator steering file file selected
  #
  tkmessageBox(title = &quot;Success!&quot;,
     		message = paste(&quot;You have loaded the data file named &apos;&quot;, basename(fileName), &quot;&apos;.&quot;, sep = &quot;&quot;),
		     icon = &quot;info&quot;,
		     type = &quot;ok&quot;)
  }
#
# Clean-up filename
#
rm(fileName)
#
# Clean-up error1 if present
#
if(exists(&quot;error1&quot;))
  {
  rm(error1)
  }
#
# Clean-up error2 if present
#
if(exists(&quot;error2&quot;))
  {
  rm(error2)
  }




################################################################################
#
#  Select and read results data: Accepts CSV data files
#
################################################################################
#
# Prompt user to supply indicator data file
#
tkmessageBox(title = &quot;Load file&quot;,
	        message = &quot;Select results data file&quot;, 
	        icon = &quot;info&quot;, 
	        type = &quot;ok&quot;)
#
# Cycle through results data file selection prompts
#
repeat
  {
  #
  # Cycle through results data file selection prompts when no file is selected
  #
  repeat
    {
    #
    # Select results data file
    #
    fileName &lt;- tclvalue(tkgetOpenFile())
    #
    # Determine if a results data file has been selected
    #	
    if(!nchar(fileName)) 
      {
      #
      # Prompt user that no file has been selected
      #
      error1 &lt;- tkmessageBox(title = &quot;Error&quot;,
				         message = &quot;No file was selected! Please try again.&quot;,
				         icon = &quot;error&quot;,
				         type = &quot;retrycancel&quot;)
      }
    #
    # Break repeat once any file has been selected
    #	
    if(nchar(fileName) &gt; 0) break
    #
    # Break repeat if user cancels option to select file
    #
    if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  }
  #
  # Break repeat if user cancels option to select file
  #
  if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  #
  # Try to read results data file based on filename provided by user
  #
  surveyResults &lt;- try(expr = read.csv(file = fileName, header = TRUE, sep = &quot;,&quot;), 
		             silent = TRUE)
  #
  # Check if results data file provided is in correct format (CSV file)
  #
  if(exists(&quot;surveyResults&quot;) &amp;&amp; class(surveyResults) == &quot;try-error&quot;)
    {
    #
    # Prompt user that file format is incorrect
    #
    error2 &lt;- tkmessageBox(title = &quot;Error&quot;,
			            message = paste(&quot;Problem reading file &apos;&quot;, basename(fileName), &quot;&apos;. Please try again&quot;, sep = &quot;,&quot;),
			            icon = &quot;error&quot;,
			            type = &quot;retrycancel&quot;)
    }
  #
  # Break repeat once selected results data file is in correct format
  #
  if(exists(&quot;surveyResults&quot;) &amp;&amp; class(surveyResults) != &quot;try-error&quot;) break
  #
  # Break repeat if user cancels option to retry providing a new file
  #
  if(exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;) break
  }
#
# Determine if user cancels option to select file or cancels option to retry providing a new file
#
if((exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) | (exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;))
  {
  #
  # Prompt user that no file has been loaded
  #
  tkmessageBox(title = &quot;Warning&quot;,
 		     message = &quot;You have not loaded any data file&quot;,
		     icon = &quot;warning&quot;,
		     type = &quot;ok&quot;)
  }
#
# Determine user has successfully selected and loaded an appropriate data file
#
if(exists(&quot;surveyResults&quot;) &amp;&amp; class(surveyResults) != &quot;try-error&quot;)
  {
  #
  # Prompt use of the filename of the results data file file selected
  #
  tkmessageBox(title = &quot;Success!&quot;,
		     message = paste(&quot;You have loaded the data file named &apos;&quot;, basename(fileName), &quot;&apos;.&quot;, sep = &quot;&quot;),
		     icon = &quot;info&quot;,
		     type = &quot;ok&quot;)
  }
#
# Clean-up filename
#
rm(fileName)
#
# Clean-up error1 if present
#
if(exists(&quot;error1&quot;))
  {
  rm(error1)
  }
#
# Clean-up error2 if present
#
if(exists(&quot;error2&quot;))
  {
  rm(error2)
  }



################################################################################
#
# Create population pyramids
#
################################################################################
#
# Open PNG graphics device
#
png(filename = &quot;outputFigures/charts/agePyramidSurveyArea.png&quot;,
    height = 9, width = 9, units = &quot;in&quot;, res = 100)
#
# Create 3 x 3 grid for figures
#
par(mfrow = c(3,3))
#
# Cycle through survey areas
#
for(i in unique(indicatorsDF$zone))
  {
  #
  # Subset to current zone
  #
  temp &lt;- subset(indicatorsDF, zone == i)
  #
  # Create expanded data.frames for boys
  #
  nBoys  &lt;- temp$nBoys[temp$nBoys &gt; 0]
  ageGrp &lt;- rep(&quot;4 to 15 years&quot;, length(nBoys))
  sex    &lt;- rep(&quot;Male&quot;, length(nBoys))
  nBoys  &lt;- data.frame(ageGrp, sex, nBoys)
  boys   &lt;- nBoys[rep(row.names(nBoys), nBoys$nBoys), 1:2]
  #
  # Create expanded data.frame for girls
  #
  nGirls &lt;- temp$nGirls[temp$nGirls &gt; 0]
  ageGrp &lt;- rep(&quot;4 to 15 years&quot;, length(nGirls))
  sex    &lt;- rep(&quot;Female&quot;, length(nGirls))
  nGirls &lt;- data.frame(ageGrp, sex, nGirls)
  girls  &lt;- nGirls[rep(row.names(nGirls), nGirls$nGirls), 1:2]
  #
  # Create expanded data.frame for men
  #
  nMen   &lt;- temp$nMen[temp$nMen &gt; 0]
  ageGrp &lt;- rep(&quot;16 - 60 years&quot;, length(nMen))
  sex    &lt;- rep(&quot;Male&quot;, length(nMen))
  nMen   &lt;- data.frame(ageGrp, sex, nMen)
  men    &lt;- nMen[rep(row.names(nMen), nMen$nMen), 1:2]
  #
  # Create expanded data.frame for women
  #
  nWomen &lt;- temp$nWomen[temp$nWomen &gt; 0]
  ageGrp &lt;- rep(&quot;16 - 60 years&quot;, length(nWomen))
  sex    &lt;- rep(&quot;Female&quot;, length(nWomen))
  nWomen &lt;- data.frame(ageGrp, sex, nWomen)
  women  &lt;- nWomen[rep(row.names(nWomen), nWomen$nWomen), 1:2]
  #
  # Create expanded data.frame for old men
  #
  nOldMen &lt;- temp$nOldMen[temp$nOldMen &gt; 0]
  ageGrp  &lt;- rep(&quot;60 years and above&quot;, length(nOldMen))
  sex     &lt;- rep(&quot;Male&quot;, length(nOldMen))
  nOldMen &lt;- data.frame(ageGrp, sex, nOldMen)
  oldMen  &lt;- nOldMen[rep(row.names(nOldMen), nOldMen$nOldMen), 1:2]
  #
  # Create expanded data.frame for old women
  #
  nOldWomen &lt;- temp$nOldWomen[temp$nOldWomen &gt; 0]
  ageGrp    &lt;- rep(&quot;60 years and above&quot;, length(nOldWomen))
  sex       &lt;- rep(&quot;Female&quot;, length(nOldWomen))
  nOldWomen &lt;- data.frame(ageGrp, sex, nOldWomen)
  oldWomen  &lt;- nOldWomen[rep(row.names(nOldWomen), nOldWomen$nOldWomen), 1:2]
  #
  # Concatenate ageGrp data.frames
  #
  assign(paste(&quot;ageDF&quot;, i, sep = &quot;&quot;), data.frame(rbind(boys, girls, men, women, oldMen, oldWomen)))
  #
  # Create pyramid plot for current zone
  #
  pyramid.plot(x = get(paste(&quot;ageDF&quot;, i, sep = &quot;&quot;))$ageGrp,
               g = get(paste(&quot;ageDF&quot;, i, sep = &quot;&quot;))$sex,
               main = paste(&quot;Survey Area&quot;, i, sep = &quot; &quot;),
               xlab = &quot;Male     /     Female&quot;,
               ylab = &quot;Age Groups&quot;)
  }
#
# Close graphics device
#
dev.off()
#
# Concatenate survey area age data.frames
#
ageDF &lt;- data.frame(rbind(ageDF1, ageDF2, ageDF3, ageDF4, ageDF5, ageDF6, ageDF7, ageDF8, ageDF9))
#
# Open PNG graphics device
#
png(filename = &quot;outputFigures/charts/agePyramidOverall.png&quot;,
    height = 10, width = 10, units = &quot;in&quot;, res = 100)
#
# Create pyramid plot for entire survey area
#
pyramid.plot(x = ageDF$ageGrp, g = ageDF$sex,
             main = &quot;&quot;, xlab = &quot;Male     /     Female&quot;,
             ylab = &quot;Age Groups&quot;)
#
# Close graphics device
#
dev.off()


################################################################################
#
# Read processed data
#
################################################################################

indicatorsDF &lt;- read.table(&quot;data/indicatorsDataBGD.csv&quot;, header = TRUE, sep = &quot;,&quot;)


################################################################################
#
# Create graphics for all indicators
#
################################################################################
#
# Read steering file for water indicators
#
steerIndicators &lt;- read.csv(file = &quot;outputLists/steerIndicatorsV7.csv&quot;, 
                            header = TRUE, sep = &quot;,&quot;)


steerHist &lt;- subset(steerIndicators, varFunction == &quot;histogram&quot;)


################################################################################
#
# Create histograms by survey area
#
################################################################################
#
# Re-code zone variable for ggplot
#
indicatorsDF$zone &lt;- with(indicatorsDF, paste(&quot;Survey Area&quot;, zone, sep = &quot; &quot;))
#
# Re-code type variable for ggplot
#
indicatorsDF$type &lt;- with(indicatorsDF, ifelse(type == 1, &quot;Slum&quot;, &quot;Other&quot;))
indicatorsDF$type &lt;- factor(indicatorsDF$type, levels = c(&quot;Slum&quot;, &quot;Other&quot;))


################################################################################
#
# Create WSUP theme
#
################################################################################

theme_wsup &lt;- theme_bw() + 
              theme(strip.text = element_text(size = 14), 
                    strip.background = element_rect(colour = &quot;black&quot;, size = 0.5),
                    axis.title = element_text(size = 14),
                    axis.text = element_text(size = 12),
                    panel.border = element_rect(colour = &quot;gray90&quot;, fill = NA),
                    legend.key = element_rect(colour = NA, fill = NA),
                    legend.key.size = unit(25, &quot;pt&quot;),
                    legend.title = element_text(size = 14),
                    legend.text = element_text(size = 12))

  
################################################################################
#
# Create plotting layers
#
################################################################################
#
# Create ggplot mapping base
#
basePlot &lt;- ggplot(data = indicatorsDF, mapping = aes(x = nMembers))
#
# Layers
#
histPlot &lt;- geom_histogram(binwidth = 1, color = wsupColour, fill = wsupColour, alpha = 0.6)
#
#
#
allPlot &lt;- basePlot + histPlot


################################################################################
#
# nMembers: number of household members by survey area and area type
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/nMembersByArea&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 18, height = 8, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap(zone ~ type, nrow = 3) + labs(x = &quot;No. of Household Members&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()
 

################################################################################
#
# nMembers: number of household members for all of Dhaka by survey area
#
################################################################################ 
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/nMembersByAreaTotal&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 12, height = 9, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap( ~ zone, ncol = 3) + labs(x = &quot;No. of Household Members&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# nMembers: number of household members for all of Dhaka by area type
#
################################################################################ 
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/nMembersByTypeTotal&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 8, height = 3, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap( ~ type) + labs(x = &quot;No. of Household Members&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# nMembers: number of household members total
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/nMembersOverall&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 9, height = 6, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + labs(x = &quot;No. of Household Members&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphis device
#
dev.off()



################################################################################
#
# Create plotting layers
#
################################################################################
#
# Create ggplot mapping base
#
basePlot &lt;- ggplot(data = indicatorsDF, mapping = aes(x = ppi))
#
# Layers
#
histPlot &lt;- geom_histogram(binwidth = 10, color = wsupColour, fill = wsupColour, alpha = 0.6)
#
#
#
allPlot &lt;- basePlot + histPlot


################################################################################
#
# ppi: ppi by survey area and area type
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/ppiByArea&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 18, height = 8, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap(zone ~ type, nrow = 3) + labs(x = &quot;PPI Score&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()
 

################################################################################
#
# ppi: ppi for all of Dhaka by survey area
#
################################################################################ 
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/ppiByAreaTotal&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 12, height = 9, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap( ~ zone, ncol = 3) + labs(x = &quot;PPI Score&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# ppi: ppi for all of Dhaka by area type
#
################################################################################ 
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/ppiByTypeTotal&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 8, height = 3, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap( ~ type) + labs(x = &quot;PPI Score&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# ppi: ppi total
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/ppiOverall&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 9, height = 6, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + labs(x = &quot;PPI Score&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphis device
#
dev.off()



################################################################################
#
# Create plotting layers - pQuintile
#
################################################################################
#
# Create ggplot mapping base
#
basePlot &lt;- ggplot(data = indicatorsDF, mapping = aes(x = pQuintile))
#
# Layers
#
histPlot &lt;- geom_histogram(binwidth = 1, color = wsupColour, fill = wsupColour, alpha = 0.6)
#
#
#
allPlot &lt;- basePlot + histPlot


################################################################################
#
# pQuintile: pQuintile by survey area and area type
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/pQuintileByArea&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 18, height = 8, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap(zone ~ type, nrow = 3) + labs(x = &quot;Wealth Quintiles based on PPI Score&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()
 

################################################################################
#
# pQuintile: wealth quintiles for all of Dhaka by survey area
#
################################################################################ 
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/pQuintileByAreaTotal&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 12, height = 9, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap( ~ zone, ncol = 3) + labs(x = &quot;Wealth Quintiles based on PPI Score&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# pQuintile: wealth quintiles for all of Dhaka by area type
#
################################################################################ 
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/pQuintileByTypeTotal&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 8, height = 3, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap( ~ type) + labs(x = &quot;Wealth Quintiles based on PPI Score&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# pQuintile: wealth quintiles total
#
################################################################################
#
# Open PNG graphics device
#
#png(filename = paste(&quot;outputFigures/charts/pQuintileOverall&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
#    width = 9, height = 6, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
#allPlot + labs(x = &quot;Wealth Quintiles based on PPI Score&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphis device
#
#dev.off()


################################################################################
#
# Create plotting layers - acceptScore
#
################################################################################
#
# Create ggplot mapping base
#
basePlot &lt;- ggplot(data = indicatorsDF, mapping = aes(x = acceptScore))
#
# Layers
#
histPlot &lt;- geom_histogram(binwidth = 1, color = wsupColour, fill = wsupColour, alpha = 0.6)
#
#
#
allPlot &lt;- basePlot + histPlot


################################################################################
#
# acceptScore: acceptScore by survey area and area type
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/acceptScoreByArea&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 18, height = 8, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap(zone ~ type, nrow = 3) + labs(x = &quot;Household acceptable sanitation score&quot;, y = &quot;&quot;) + xlim(c(0,5)) + theme_wsup
#
# Close graphics device
#
dev.off()
 

################################################################################
#
# acceptScore: acceptable sanitation score for all of Dhaka by survey area
#
################################################################################ 
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/acceptScoreByAreaTotal&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 12, height = 9, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap( ~ zone, ncol = 3) + labs(x = &quot;Household acceptable sanitation score&quot;, y = &quot;&quot;) + xlim(c(0,5)) + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# acceptScore: acceptable sanitation score for all of Dhaka by area type
#
################################################################################ 
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/acceptScoreByTypeTotal&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 8, height = 3, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap( ~ type) + labs(x = &quot;Household acceptable sanitation score&quot;, y = &quot;&quot;) + xlim(c(0,5)) + theme_wsup
#
# Close graphics device
#
dev.off()

################################################################################
#
# Transform results data to long format for ggplot
#
################################################################################
#
# Read survey results
#
surveyResults &lt;- read.csv(&quot;outputTables/surveyResultsBGD.csv&quot;)
#
# Subset survey results to columns needed for plotting
#
temp1 &lt;- subset(surveyResults, select = c(indicatorName, indicatorCode, surveyArea, slumTotal, slumEst))
temp2 &lt;- subset(surveyResults, select = c(indicatorName, indicatorCode, surveyArea, otherTotal, otherEst))
temp3 &lt;- subset(surveyResults, select = c(indicatorName, indicatorCode, surveyArea, total, totalEst))
#
# Add area type variable
#
temp1$type &lt;- rep(&quot;Slum&quot;, nrow(temp1))
temp2$type &lt;- rep(&quot;Other&quot;, nrow(temp2))
temp3$type &lt;- rep(&quot;Overall&quot;, nrow(temp3))
#
# Rename variables
#
names(temp1) &lt;- c(&quot;indicatorName&quot;, &quot;indicatorCode&quot;, &quot;surveyArea&quot;, &quot;n&quot;, &quot;estimate&quot;, &quot;type&quot;)
names(temp2) &lt;- c(&quot;indicatorName&quot;, &quot;indicatorCode&quot;, &quot;surveyArea&quot;, &quot;n&quot;, &quot;estimate&quot;, &quot;type&quot;)
names(temp3) &lt;- c(&quot;indicatorName&quot;, &quot;indicatorCode&quot;, &quot;surveyArea&quot;, &quot;n&quot;, &quot;estimate&quot;, &quot;type&quot;)
#
# Create single long data.frame
#
surveyResultsLong &lt;- data.frame(rbind(temp1, temp2, temp3))


################################################################################
#
# jmpWaterResults: subset surveyResultsLong to indicators for water ladder
#
################################################################################
#
# List of jmp water indicators
#
jmpWaterList &lt;- c(&quot;jmpWater1&quot;, &quot;jmpWater2&quot;, &quot;jmpWater3&quot;, &quot;jmpWater4&quot;, &quot;jmpWater5&quot;)
#
# Subest to jmp water indicators
#
jmpWaterResults &lt;- subset(surveyResultsLong, indicatorCode %in% jmpWaterList)
#
# Sort jmpWaterResults by indicatorCode
#
jmpWaterResults &lt;- jmpWaterResults[order(jmpWaterResults$indicatorCode), ]
#
# Convert indicatorCode to factor and sort accordingly to match ladder
#
jmpWaterResults$indicatorCode &lt;- with(jmpWaterResults, factor(x = indicatorCode,
                                                              levels = rev(jmpWaterList))) 
#
# Convert type to factor and sort accordingly
#
jmpWaterResults$type &lt;- with(jmpWaterResults, factor(x = type,
                                                     levels = c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Overall&quot;)))
#
# Convert surveyArea to factor and sort accordingly
#
jmpWaterResults$surveyArea &lt;- with(jmpWaterResults, factor(x = surveyArea,
                                                           levels = c(&quot;Survey Area 1&quot;,
                                                                      &quot;Survey Area 2&quot;,
                                                                      &quot;Survey Area 3&quot;,
                                                                      &quot;Survey Area 4&quot;,
                                                                      &quot;Survey Area 5&quot;,
                                                                      &quot;Survey Area 6&quot;,
                                                                      &quot;Survey Area 7&quot;,
                                                                      &quot;Survey Area 8&quot;,
                                                                      &quot;Survey Area 9&quot;)))

################################################################################
#
# Define plotting layers for ggplot - stacked bar by survey area grouped by type
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(data = jmpWaterResults, mapping = aes(x = type, 
                                                         y = estimate, 
                                                         fill = indicatorCode))
#
# Bar plot
#
barPlot &lt;- geom_bar(stat = &quot;identity&quot;, position = &quot;fill&quot;, alpha = 0.8)
#
# Bar fill
#
barFill &lt;- scale_fill_manual(name = &quot;Drinking Water Ladder&quot;,
                             labels = c(&quot;Basic Plus&quot;,
                                        &quot;Basic&quot;,
                                        &quot;Limited&quot;,
                                        &quot;Unimproved&quot;,
                                        &quot;Surface Water&quot;),
                             values = waterLadder)
#
# Facets
#
barFacet &lt;- facet_wrap( ~ surveyArea, nrow = 3)
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Area Type&quot;, y = &quot;Proportion&quot;)
#
# x-axis tick mark labels
#
xLabels &lt;- scale_x_discrete(labels = c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Overall&quot;))


################################################################################
#
# Plot
#
################################################################################
#
# Open graphics device
#
png(filename = paste(&quot;outputFigures/charts/waterLadderByArea&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 12, height = 4 * ceiling(length(levels(jmpWaterResults$surveyArea)) / 3), units = &quot;in&quot;,
    res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFill + barFacet + barLabels + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# Define plotting layers for ggplot - stacked bar by type grouped by surveyArea
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(data = jmpWaterResults, 
                   mapping = aes(x = surveyArea,
                                 y = estimate,
                                 fill = indicatorCode))
#
# Bar plot
#        
barPlot &lt;- geom_bar(stat = &quot;identity&quot;, position = &quot;fill&quot;, alpha = 0.8)
#
# Bar fill
#
barFill &lt;- scale_fill_manual(name = &quot;Drinking Water Ladder&quot;,
                             labels = c(&quot;Basic Plus&quot;,
                                        &quot;Basic&quot;,
                                        &quot;Limited&quot;,
                                        &quot;Unimproved&quot;,
                                        &quot;Surface Water&quot;),
                             values = waterLadder)
#
#
#
barFacet &lt;- facet_wrap( ~ type, ncol = 3)
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Survey Area&quot;, y = &quot;Proportion&quot;)
#
# x-axis tick mark labels
#
xLabels &lt;- scale_x_discrete(labels = 1:length(unique(jmpWaterResults$surveyArea)))

################################################################################
#
# Plot
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/waterLadderByType&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 10, height = 4, units = &quot;in&quot;, res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFill + barFacet + barLabels + xLabels + theme_wsup
#
# Close graphics device
#
dev.off()



################################################################################
#
# jmpSanResults: subset surveyResultsLong to indicators for sanitation ladder
#
################################################################################
#
# List of jmp sanitation indicators
#
jmpSanList &lt;- c(&quot;jmpSan1&quot;, &quot;jmpSan2&quot;, &quot;jmpSan3&quot;, &quot;jmpSan4&quot;, &quot;jmpSan5&quot;)
#
# Subest to jmp sanitation indicators
#
jmpSanResults &lt;- subset(surveyResultsLong, indicatorCode %in% jmpSanList)
#
# Sort jmpSanResults by indicatorCode
#
jmpSanResults &lt;- jmpSanResults[order(jmpSanResults$indicatorCode), ]
#
# Convert indicatorCode to factor and sort accordingly to match ladder
#
jmpSanResults$indicatorCode &lt;- with(jmpSanResults, factor(x = indicatorCode,
                                                          levels = rev(jmpSanList))) 
#
# Convert type to factor and sort accordingly
#
jmpSanResults$type &lt;- with(jmpSanResults, factor(x = type,
                                                 levels = c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Overall&quot;)))
#
# Convert surveyArea to factor and sort accordingly
#
jmpSanResults$surveyArea &lt;- with(jmpSanResults, factor(x = surveyArea,
                                                           levels = c(&quot;Survey Area 1&quot;,
                                                                      &quot;Survey Area 2&quot;,
                                                                      &quot;Survey Area 3&quot;,
                                                                      &quot;Survey Area 4&quot;,
                                                                      &quot;Survey Area 5&quot;,
                                                                      &quot;Survey Area 6&quot;,
                                                                      &quot;Survey Area 7&quot;,
                                                                      &quot;Survey Area 8&quot;,
                                                                      &quot;Survey Area 9&quot;)))


################################################################################
#
# Define plotting layers for ggplot - stacked bar by survey area grouped by type
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(data = jmpSanResults, mapping = aes(x = type, 
                                                       y = estimate, 
                                                       fill = indicatorCode))
#
# Bar plot
#
barPlot &lt;- geom_bar(stat = &quot;identity&quot;, position = &quot;fill&quot;, alpha = 0.8)
#
# Bar fill
#
barFill &lt;- scale_fill_manual(name = &quot;Sanitation Ladder&quot;,
                             labels = c(&quot;Self-managed&quot;,
                                        &quot;Basic&quot;,
                                        &quot;Limited&quot;,
                                        &quot;Unimproved&quot;,
                                        &quot;Open defecation&quot;),
                             values = sanitationLadder)
#
# Facets
#
barFacet &lt;- facet_wrap( ~ surveyArea, nrow = 3)
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Area Type&quot;, y = &quot;Proportion&quot;)
#
# x-axis tick mark labels
#
xLabels &lt;- scale_x_discrete(labels = c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Overall&quot;))


################################################################################
#
# Plot
#
################################################################################
#
# Open graphics device
#
png(filename = paste(&quot;outputFigures/charts/sanitationLadderByArea&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 12, height = 4 * ceiling(length(levels(jmpSanResults$surveyArea)) / 3), units = &quot;in&quot;,
    res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFill + barFacet + barLabels + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# Define plotting layers for ggplot - stacked bar by type grouped by surveyArea
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(data = jmpSanResults, 
                   mapping = aes(x = surveyArea,
                                 y = estimate,
                                 fill = indicatorCode))
#
# Bar plot
#        
barPlot &lt;- geom_bar(stat = &quot;identity&quot;, position = &quot;fill&quot;, alpha = 0.8)
#
# Bar fill
#
barFill &lt;- scale_fill_manual(name = &quot;Sanitation Ladder&quot;,
                             labels = c(&quot;Self-managed&quot;,
                                        &quot;Basic&quot;,
                                        &quot;Limited&quot;,
                                        &quot;Unimproved&quot;,
                                        &quot;Open Defecation&quot;),
                             values = sanitationLadder)
#
#
#
barFacet &lt;- facet_wrap( ~ type, ncol = 3)
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Survey Area&quot;, y = &quot;Proportion&quot;)
#
# x-axis tick mark labels
#
xLabels &lt;- scale_x_discrete(labels = 1:length(levels(jmpSanResults$surveyArea)))

################################################################################
#
# Plot
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/sanitationLadderByType&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 10, height = 4, units = &quot;in&quot;, res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFill + barFacet + barLabels + xLabels + theme_wsup
#
# Close graphics device
#
dev.off()



################################################################################
#
# jmpHandResults: subset surveyResultsLong to indicators for handwashing ladder
#
################################################################################
#
# List of jmp handwashing indicators
#
jmpHandList &lt;- c(&quot;jmpHand1&quot;, &quot;jmpHand2&quot;, &quot;jmpHand3&quot;)
#
# Subest to jmp handwashing indicators
#
jmpHandResults &lt;- subset(surveyResultsLong, indicatorCode %in% jmpHandList)
#
# Sort jmpHandResults by indicatorCode
#
jmpHandResults &lt;- jmpHandResults[order(jmpHandResults$indicatorCode), ]
#
# Convert indicatorCode to factor and sort accordingly to match ladder
#
jmpHandResults$indicatorCode &lt;- with(jmpHandResults, factor(x = indicatorCode,
                                                            levels = rev(jmpHandList))) 
#
# Convert type to factor and sort accordingly
#
jmpHandResults$type &lt;- with(jmpHandResults, factor(x = type,
                                                   levels = c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Overall&quot;)))
#
# Convert surveyArea to factor and sort accordingly
#
jmpHandResults$surveyArea &lt;- with(jmpHandResults, factor(x = surveyArea,
                                                         levels = c(&quot;Survey Area 1&quot;,
                                                                    &quot;Survey Area 2&quot;,
                                                                    &quot;Survey Area 3&quot;,
                                                                    &quot;Survey Area 4&quot;,
                                                                    &quot;Survey Area 5&quot;,
                                                                    &quot;Survey Area 6&quot;,
                                                                    &quot;Survey Area 7&quot;,
                                                                    &quot;Survey Area 8&quot;,
                                                                    &quot;Survey Area 9&quot;)))


################################################################################
#
# Define plotting layers for ggplot - stacked bar by survey area grouped by type
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(data = jmpHandResults, mapping = aes(x = type, 
                                                        y = estimate, 
                                                        fill = indicatorCode))
#
# Bar plot
#
barPlot &lt;- geom_bar(stat = &quot;identity&quot;, position = &quot;fill&quot;, alpha = 0.8)
#
# Bar fill
#
barFill &lt;- scale_fill_manual(name = &quot;Handwashing Ladder&quot;,
                             labels = c(&quot;Basic&quot;,
                                        &quot;Unimproved&quot;,
                                        &quot;No facility&quot;),
                             values = handwashLadder)
#
# Facets
#
barFacet &lt;- facet_wrap( ~ surveyArea, nrow = 3)
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Area Type&quot;, y = &quot;Proportion&quot;)
#
# x-axis tick mark labels
#
xLabels &lt;- scale_x_discrete(labels = c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Overall&quot;))


################################################################################
#
# Plot
#
################################################################################
#
# Open graphics device
#
png(filename = paste(&quot;outputFigures/charts/handwashLadderByArea&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 12, height = 4 * ceiling(length(levels(jmpHandResults$surveyArea)) / 3), units = &quot;in&quot;,
    res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFill + barFacet + barLabels + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# Define plotting layers for ggplot - stacked bar by type grouped by surveyArea
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(data = jmpHandResults, 
                   mapping = aes(x = surveyArea,
                                 y = estimate,
                                 fill = indicatorCode))
#
# Bar plot
#        
barPlot &lt;- geom_bar(stat = &quot;identity&quot;, position = &quot;fill&quot;, alpha = 0.8)
#
# Bar fill
#
barFill &lt;- scale_fill_manual(name = &quot;Handwashing Ladder&quot;,
                             labels = c(&quot;Basic&quot;,
                                        &quot;Unimproved&quot;,
                                        &quot;No facility&quot;),
                             values = handwashLadder)
#
#
#
barFacet &lt;- facet_wrap( ~ type, ncol = 3)
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Survey Area&quot;, y = &quot;Proportion&quot;)
#
# x-axis tick mark labels
#
xLabels &lt;- scale_x_discrete(labels = 1:length(levels(jmpHandResults$surveyArea)))

################################################################################
#
# Plot
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/handwashLadderByType&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 10, height = 4, units = &quot;in&quot;, res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFill + barFacet + barLabels + xLabels + theme_wsup
#
# Close graphics device
#
dev.off()

          
################################################################################
#
# Transform results data by wealth quintile to long format for ggplot
#
################################################################################
#
# Read survey results
#
surveyResults &lt;- read.csv(&quot;outputTables/surveyResultsWealthBGD.csv&quot;)
#
# Subset survey results to columns needed for plotting
#
temp1 &lt;- subset(surveyResults, select = c(indicatorName, indicatorCode, wealthQuintile, slumTotal, slumEst))
temp2 &lt;- subset(surveyResults, select = c(indicatorName, indicatorCode, wealthQuintile, otherTotal, otherEst))
temp3 &lt;- subset(surveyResults, select = c(indicatorName, indicatorCode, wealthQuintile, total, totalEst))
#
# Add area type variable
#
temp1$type &lt;- rep(&quot;Slum&quot;, nrow(temp1))
temp2$type &lt;- rep(&quot;Other&quot;, nrow(temp2))
temp3$type &lt;- rep(&quot;Overall&quot;, nrow(temp3))
#
# Rename variables
#
names(temp1) &lt;- c(&quot;indicatorName&quot;, &quot;indicatorCode&quot;, &quot;wealthQuintile&quot;, &quot;n&quot;, &quot;estimate&quot;, &quot;type&quot;)
names(temp2) &lt;- c(&quot;indicatorName&quot;, &quot;indicatorCode&quot;, &quot;wealthQuintile&quot;, &quot;n&quot;, &quot;estimate&quot;, &quot;type&quot;)
names(temp3) &lt;- c(&quot;indicatorName&quot;, &quot;indicatorCode&quot;, &quot;wealthQuintile&quot;, &quot;n&quot;, &quot;estimate&quot;, &quot;type&quot;)
#
# Create single long data.frame
#
surveyResultsLong &lt;- data.frame(rbind(temp1, temp2, temp3))


################################################################################
#
# expenseWater: subset surveyResultsLong to indicators for drinking water expense
#
################################################################################
#
# Subest to jmp water indicators
#
expenseWater &lt;- subset(surveyResultsLong, indicatorCode == &quot;water12&quot;)
#
# Convert type to factor and sort accordingly
#
expenseWater$type &lt;- with(expenseWater, factor(x = type,
                                               levels = c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Overall&quot;)))
#
# Convert wealth quintile to factor and sort accordingly
#
expenseWater$wealthQuintile &lt;- with(expenseWater, factor(x = wealthQuintile,
                                                         levels = c(&quot;Wealth Quintile 1&quot;,
                                                                    &quot;Wealth Quintile 2&quot;,
                                                                    &quot;Wealth Quintile 3&quot;,
                                                                    &quot;Wealth Quintile 4&quot;,
                                                                    &quot;Wealth Quintile 5&quot;)))

################################################################################
#
# Define plotting layers for ggplot - barplot by wealth quintile grouped by type
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(data = expenseWater, mapping = aes(x = wealthQuintile, 
                                                      y = estimate))
#
# Bar plot
#
barPlot &lt;- geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;, 
                    colour = wsupColour, fill = wsupColour, alpha = 0.6)
#
# Facets
#
barFacet &lt;- facet_wrap( ~ type, nrow = 3)
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Wealth Quintiles&quot;, y = &quot;Mean Expenditure&quot;)
#
# x-axis tick mark labels
#
xLabels &lt;- scale_x_discrete(labels = 1:5)


################################################################################
#
# Plot
#
################################################################################
#
# Open graphics device
#
png(filename = paste(&quot;outputFigures/charts/expenseWater&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 8, height = 10, units = &quot;in&quot;,
    res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFacet + barLabels + xLabels + theme_wsup
#
# Close graphics device
#
dev.off()



################################################################################
#
# expenseSan: subset surveyResultsLong to indicators for sanitation expense
#
################################################################################
#
# Subest to sanitation expense indicator
#
expenseSan &lt;- subset(surveyResultsLong, indicatorCode == &quot;san14&quot;)
#
# Convert type to factor and sort accordingly
#
expenseSan$type &lt;- with(expenseSan, factor(x = type,
                                           levels = c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Overall&quot;)))
#
# Convert wealth quintile to factor and sort accordingly
#
expenseSan$wealthQuintile &lt;- with(expenseSan, factor(x = wealthQuintile,
                                                     levels = c(&quot;Wealth Quintile 1&quot;,
                                                                &quot;Wealth Quintile 2&quot;,
                                                                &quot;Wealth Quintile 3&quot;,
                                                                &quot;Wealth Quintile 4&quot;,
                                                                &quot;Wealth Quintile 5&quot;)))

################################################################################
#
# Define plotting layers for ggplot - barplot by wealth quintile grouped by type
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(data = expenseSan, mapping = aes(x = wealthQuintile, 
                                                      y = estimate))
#
# Bar plot
#
barPlot &lt;- geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;, 
                    colour = wsupColour, fill = wsupColour, alpha = 0.6)
#
# Facets
#
barFacet &lt;- facet_wrap( ~ type, nrow = 3)
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Wealth Quintiles&quot;, y = &quot;Mean Expenditure&quot;)
#
# x-axis tick mark labels
#
xLabels &lt;- scale_x_discrete(labels = 1:5)


################################################################################
#
# Plot
#
################################################################################
#
# Open graphics device
#
png(filename = paste(&quot;outputFigures/charts/expenseSan&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 8, height = 10, units = &quot;in&quot;,
    res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFacet + barLabels + xLabels + theme_wsup
#
# Close graphics device
#
dev.off()





################################################################################
#
# Create barplots of water collectors 
#
################################################################################
#
# Convert waterCollectDF to long format
#
temp1 &lt;- subset(waterCollectDF, select = -water9b:-water9h)
names(temp1) &lt;- c(&quot;uniqueID&quot;, &quot;psu&quot;, &quot;country&quot;, &quot;ccode&quot;, &quot;zone&quot;, &quot;type&quot;, &quot;quadrat&quot;, &quot;hhid&quot;, &quot;longitude&quot;, &quot;latitude&quot;, &quot;pQuintile&quot;, &quot;collect&quot;)

temp2 &lt;- subset(waterCollectDF, select = c(-water9a, -water9c:-water9h))
names(temp2) &lt;- c(&quot;uniqueID&quot;, &quot;psu&quot;, &quot;country&quot;, &quot;ccode&quot;, &quot;zone&quot;, &quot;type&quot;, &quot;quadrat&quot;, &quot;hhid&quot;, &quot;longitude&quot;, &quot;latitude&quot;, &quot;pQuintile&quot;, &quot;collect&quot;)

temp3 &lt;- subset(waterCollectDF, select = c(-water9a:-water9b, -water9d:-water9h))
names(temp3) &lt;- c(&quot;uniqueID&quot;, &quot;psu&quot;, &quot;country&quot;, &quot;ccode&quot;, &quot;zone&quot;, &quot;type&quot;, &quot;quadrat&quot;, &quot;hhid&quot;, &quot;longitude&quot;, &quot;latitude&quot;, &quot;pQuintile&quot;, &quot;collect&quot;)

temp4 &lt;- subset(waterCollectDF, select = c(-water9a:-water9c, -water9e:-water9h))
names(temp4) &lt;- c(&quot;uniqueID&quot;, &quot;psu&quot;, &quot;country&quot;, &quot;ccode&quot;, &quot;zone&quot;, &quot;type&quot;, &quot;quadrat&quot;, &quot;hhid&quot;, &quot;longitude&quot;, &quot;latitude&quot;, &quot;pQuintile&quot;, &quot;collect&quot;)

temp5 &lt;- subset(waterCollectDF, select = c(-water9a:-water9c, -water9e:-water9h))
names(temp5) &lt;- c(&quot;uniqueID&quot;, &quot;psu&quot;, &quot;country&quot;, &quot;ccode&quot;, &quot;zone&quot;, &quot;type&quot;, &quot;quadrat&quot;, &quot;hhid&quot;, &quot;longitude&quot;, &quot;latitude&quot;, &quot;pQuintile&quot;, &quot;collect&quot;)

temp6 &lt;- subset(waterCollectDF, select = c(-water9a:-water9d, -water9f:-water9h))
names(temp6) &lt;- c(&quot;uniqueID&quot;, &quot;psu&quot;, &quot;country&quot;, &quot;ccode&quot;, &quot;zone&quot;, &quot;type&quot;, &quot;quadrat&quot;, &quot;hhid&quot;, &quot;longitude&quot;, &quot;latitude&quot;, &quot;pQuintile&quot;, &quot;collect&quot;)

temp7 &lt;- subset(waterCollectDF, select = c(-water9a:-water9e, -water9g:-water9h))
names(temp7) &lt;- c(&quot;uniqueID&quot;, &quot;psu&quot;, &quot;country&quot;, &quot;ccode&quot;, &quot;zone&quot;, &quot;type&quot;, &quot;quadrat&quot;, &quot;hhid&quot;, &quot;longitude&quot;, &quot;latitude&quot;, &quot;pQuintile&quot;, &quot;collect&quot;)

temp8 &lt;- subset(waterCollectDF, select = c(-water9a:-water9f, -water9h))
names(temp8) &lt;- c(&quot;uniqueID&quot;, &quot;psu&quot;, &quot;country&quot;, &quot;ccode&quot;, &quot;zone&quot;, &quot;type&quot;, &quot;quadrat&quot;, &quot;hhid&quot;, &quot;longitude&quot;, &quot;latitude&quot;, &quot;pQuintile&quot;, &quot;collect&quot;)

temp9 &lt;- subset(waterCollectDF, select = -water9a:-water9g)
names(temp9) &lt;- c(&quot;uniqueID&quot;, &quot;psu&quot;, &quot;country&quot;, &quot;ccode&quot;, &quot;zone&quot;, &quot;type&quot;, &quot;quadrat&quot;, &quot;hhid&quot;, &quot;longitude&quot;, &quot;latitude&quot;, &quot;pQuintile&quot;, &quot;collect&quot;)

temp &lt;- data.frame(rbind(temp1, temp2, temp3, temp4, temp5, temp6, temp7, temp8, temp9))
#
# Remove NAs
#
temp &lt;- temp[!is.na(temp$collect), ]
temp &lt;- subset(temp, collect != &quot;Don&apos;t know/no answer/not applicable&quot;)
temp &lt;- subset(temp, collect != &quot;Source inside house&quot;)
#
# Re-assign survey area values
#
temp$zone &lt;- with(temp, paste(&quot;Survey Area&quot;, zone, sep = &quot; &quot;))
#
# Re-assign area type values
#
temp$type &lt;- with(temp, ifelse(type == 1, &quot;Slum&quot;, &quot;Other&quot;))
#
# Re-order collect variable
#
temp &lt;- temp[order(temp$collect), ]
#
# Re-assign factors for collect variable
#
temp$collect &lt;- with(temp, factor(x = collect, levels = c(&quot;Adult men&quot;, 
                                                          &quot;Adult women&quot;, 
                                                          &quot;Boys _15&quot;, 
                                                          &quot;Girls _15&quot;, 
                                                          &quot;Whole family&quot;)))
#
# Re-assign factors for area type
#
temp$type &lt;- with(temp, factor(x = type, levels = c(&quot;Slum&quot;, &quot;Other&quot;)))                                                          
#
# Assign temp to waterCollectLong data.frame
#
waterCollectLong &lt;- temp


################################################################################
#
# Create plotting layers for ggplot
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(waterCollectLong, mapping = aes(x = type, fill = collect))
#
# Bar plot
#
barPlot &lt;- geom_bar(position = &quot;stack&quot;, alpha = 0.8)
#
# Create layout
#
barFacet &lt;- facet_wrap( ~ zone, ncol = 3)
#
# Colours
#
barFill &lt;- scale_fill_manual(name = &quot;Household Water Collector/s&quot;,
                             labels = c(&quot;Adult Men&quot;, &quot;Adult Women&quot;, &quot;Boys&quot;, &quot;Girls&quot;, &quot;Whole family&quot;),
                             values = collectColour) 
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Area Type&quot;, y = &quot;&quot;)

################################################################################
#
# Plot water collectors by survey area grouped by type
#
################################################################################
#
# Open graphics device
#
png(filename = paste(&quot;outputFigures/charts/waterCollectorByArea&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 8, height = 4 * ceiling(length(unique(waterCollectLong$zone)) / 3), units = &quot;in&quot;,
    res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFacet + barFill + barLabels + theme_wsup + theme(legend.position = &quot;top&quot;)
#
# Close graphics device
#
dev.off()


################################################################################
#
# Create plotting layers for ggplot
#
################################################################################
#
# Create base plot
#
basePlot &lt;- ggplot(waterCollectLong, mapping = aes(x = zone, fill = collect))
#
# Create bar plot
#
barPlot &lt;- geom_bar(position = &quot;stack&quot;, alpha = 0.8)
#
# Create plot facets
#
barFacet &lt;- facet_wrap( ~ type, ncol = 3)
#
# Creat fill colours
#
barFill &lt;- scale_fill_manual(name = &quot;Household Water Collector/s&quot;,
                             labels = c(&quot;Adult Men&quot;, &quot;Adult Women&quot;, &quot;Boys&quot;, &quot;Girls&quot;, &quot;Whole family&quot;),
                             values = collectColour) 

#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Survey Area&quot;, y = &quot;&quot;)
#
# x-axis labels
#
xLabels &lt;- scale_x_discrete(labels = 1:length(unique(waterCollectLong$zone)))


################################################################################
#
# Plot water collectors by survey area grouped by area
#
################################################################################
#
# Open graphics device
#
png(filename = paste(&quot;outputFigures/charts/waterCollectorByType&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 10, height = 4, units = &quot;in&quot;,
    res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFacet + barFill + barLabels + xLabels + theme_wsup + theme(legend.position = &quot;top&quot;)
#
# Close graphics device
#
dev.off()



################################################################################
#
# Create plotting layers for ggplot
#
################################################################################
#
# Create base plot
#
basePlot &lt;- ggplot(waterCollectLong, mapping = aes(x = pQuintile, fill = collect))
#
# Create bar plot
#
barPlot &lt;- geom_bar(position = &quot;stack&quot;, alpha = 0.8)
#
# Create plot facets
#
barFacet &lt;- facet_wrap( ~ zone, ncol = 3)
#
# Create colour fill
#
barFill &lt;- scale_fill_manual(name = &quot;Household Water Collector/s&quot;,
                             labels = c(&quot;Adult Men&quot;, &quot;Adult Women&quot;, &quot;Boys&quot;, &quot;Girls&quot;, &quot;Whole family&quot;),
                             values = collectColour) 

#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Wealth Quintile&quot;, y = &quot;&quot;)


################################################################################
#
# Plot water collectors by survey area grouped by quintiles
#
################################################################################
#
# Open graphics device
#
png(filename = paste(&quot;outputFigures/charts/waterCollectorByQuintile&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 12, height = 4 * (length(unique(waterCollectLong$zone)) / 3), units = &quot;in&quot;,
    res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFacet + barFill + barLabels + xlim(c(1,5)) + theme_wsup  + theme(legend.position = &quot;top&quot;)
#
# Close graphics device
#
dev.off()



################################################################################
#
# Transform results data to long format for ggplot
#
################################################################################
#
# Read survey results
#
surveyResults &lt;- read.csv(&quot;outputTables/surveyResultsBGD.csv&quot;)
#
# Subset survey results to columns needed for plotting
#
temp1 &lt;- subset(surveyResults, select = c(indicatorName, indicatorCode, surveyArea, slumTotal, slumEst))
temp2 &lt;- subset(surveyResults, select = c(indicatorName, indicatorCode, surveyArea, otherTotal, otherEst))
temp3 &lt;- subset(surveyResults, select = c(indicatorName, indicatorCode, surveyArea, total, totalEst))
#
# Add area type variable
#
temp1$type &lt;- rep(&quot;Slum&quot;, nrow(temp1))
temp2$type &lt;- rep(&quot;Other&quot;, nrow(temp2))
temp3$type &lt;- rep(&quot;Overall&quot;, nrow(temp3))
#
# Rename variables
#
names(temp1) &lt;- c(&quot;indicatorName&quot;, &quot;indicatorCode&quot;, &quot;surveyArea&quot;, &quot;n&quot;, &quot;estimate&quot;, &quot;type&quot;)
names(temp2) &lt;- c(&quot;indicatorName&quot;, &quot;indicatorCode&quot;, &quot;surveyArea&quot;, &quot;n&quot;, &quot;estimate&quot;, &quot;type&quot;)
names(temp3) &lt;- c(&quot;indicatorName&quot;, &quot;indicatorCode&quot;, &quot;surveyArea&quot;, &quot;n&quot;, &quot;estimate&quot;, &quot;type&quot;)
#
# Create single long data.frame
#
surveyResultsLong &lt;- data.frame(rbind(temp1, temp2, temp3))


################################################################################
#
# formalWater: subset surveyResultsLong to indicators for formal water services
#
################################################################################
#
# List of formal water services
#
formalWaterList &lt;- c(&quot;water2a&quot;, &quot;water17&quot;)
#
# Subest to formal water services
#
formalWaterResults &lt;- subset(surveyResultsLong, indicatorCode %in% formalWaterList)
#
# Sort formallWaterResults by indicatorCode
#
formalWaterResults &lt;- formalWaterResults[order(formalWaterResults$indicatorCode), ]
#
# Convert indicatorCode to factor and sort accordingly to match ladder
#
formalWaterResults$indicatorCode &lt;- with(formalWaterResults, factor(x = indicatorCode,
                                                                    levels = formalWaterList)) 
#
# Convert type to factor and sort accordingly
#
formalWaterResults$type &lt;- with(formalWaterResults, factor(x = type,
                                                           levels = c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Overall&quot;)))
#
# Convert surveyArea to factor and sort accordingly
#
formalWaterResults$surveyArea &lt;- with(formalWaterResults, factor(x = surveyArea,
                                                                 levels = c(&quot;Survey Area 1&quot;,
                                                                            &quot;Survey Area 2&quot;,
                                                                            &quot;Survey Area 3&quot;,
                                                                            &quot;Survey Area 4&quot;,
                                                                            &quot;Survey Area 5&quot;,
                                                                            &quot;Survey Area 6&quot;,
                                                                            &quot;Survey Area 7&quot;,
                                                                            &quot;Survey Area 8&quot;,
                                                                            &quot;Survey Area 9&quot;)))


################################################################################
#
# Define plotting layers for ggplot - stacked bar by survey area grouped by type
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(data = formalWaterResults, mapping = aes(x = type, 
                                                            y = estimate, 
                                                            fill = indicatorCode))
#
# Bar plot
#
barPlot &lt;- geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;, alpha = 0.6)
#
# Bar fill
#
barFill &lt;- scale_fill_manual(name = &quot;Water Service Provision&quot;,
                             labels = c(&quot;Formal water service provision&quot;,
                                        &quot;Formal water service maintenance&quot;),
                             values = formalColour)
#
# Facets
#
barFacet &lt;- facet_wrap( ~ surveyArea, nrow = 3)
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Area Type&quot;, y = &quot;Proportion&quot;)
#
# x-axis tick mark labels
#
xLabels &lt;- scale_x_discrete(labels = c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Overall&quot;))


################################################################################
#
# Plot
#
################################################################################
#
# Open graphics device
#
png(filename = paste(&quot;outputFigures/charts/formalWaterByArea&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 12, height = 4 * ceiling(length(levels(formalWaterResults$surveyArea)) / 3), units = &quot;in&quot;,
    res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFill + barFacet + barLabels + theme_wsup + theme(legend.position = &quot;top&quot;)
#
# Close graphics device
#
dev.off()


################################################################################
#
# Define plotting layers for ggplot - stacked bar by type grouped by surveyArea
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(data = formalWaterResults, 
                   mapping = aes(x = surveyArea,
                                 y = estimate,
                                 fill = indicatorCode))
#
# Bar plot
#        
barPlot &lt;- geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;, alpha = 0.6)
#
# Bar fill
#
barFill &lt;- scale_fill_manual(name = &quot;Water Service Provision&quot;,
                             labels = c(&quot;Formal water service provision&quot;,
                                        &quot;Formal water service maintenance&quot;),
                             values = formalColour)
#
#
#
barFacet &lt;- facet_wrap( ~ type, nrow = 3)
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Survey Area&quot;, y = &quot;Proportion&quot;)
#
# x-axis tick mark labels
#
xLabels &lt;- scale_x_discrete(labels = 1:length(levels(formalWaterResults$surveyArea)))

################################################################################
#
# Plot
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/formalWaterByType&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 8, height = 10, units = &quot;in&quot;, res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFill + barFacet + barLabels + xLabels + theme_wsup + theme(legend.position = &quot;top&quot;)
#
# Close graphics device
#
dev.off()



################################################################################
#
# formalSan: subset surveyResultsLong to indicators for formal sanitation services
#
################################################################################
#
# List of formal water services
#
formalSanList &lt;- c(&quot;san25&quot;, &quot;san35&quot;)
#
# Subest to formal water services
#
formalSanResults &lt;- subset(surveyResultsLong, indicatorCode %in% formalSanList)
#
# Sort formalSanResults by indicatorCode
#
formalSanResults &lt;- formalSanResults[order(formalSanResults$indicatorCode), ]
#
# Convert indicatorCode to factor and sort accordingly to match ladder
#
formalSanResults$indicatorCode &lt;- with(formalSanResults, factor(x = indicatorCode,
                                                                levels = formalSanList)) 
#
# Convert type to factor and sort accordingly
#
formalSanResults$type &lt;- with(formalSanResults, factor(x = type,
                                                       levels = c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Overall&quot;)))
#
# Convert surveyArea to factor and sort accordingly
#
formalSanResults$surveyArea &lt;- with(formalSanResults, factor(x = surveyArea,
                                                             levels = c(&quot;Survey Area 1&quot;,
                                                                        &quot;Survey Area 2&quot;,
                                                                        &quot;Survey Area 3&quot;,
                                                                        &quot;Survey Area 4&quot;,
                                                                        &quot;Survey Area 5&quot;,
                                                                        &quot;Survey Area 6&quot;,
                                                                        &quot;Survey Area 7&quot;,
                                                                        &quot;Survey Area 8&quot;,
                                                                        &quot;Survey Area 9&quot;)))


################################################################################
#
# Define plotting layers for ggplot - stacked bar by survey area grouped by type
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(data = formalSanResults, mapping = aes(x = type, 
                                                            y = estimate, 
                                                            fill = indicatorCode))
#
# Bar plot
#
barPlot &lt;- geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;, alpha = 0.6)
#
# Bar fill
#
barFill &lt;- scale_fill_manual(name = &quot;Sanitation Service Provision&quot;,
                             labels = c(&quot;Formal service operators&quot;,
                                        &quot;Formal pit emptier&quot;),
                             values = formalColour)
#
# Facets
#
barFacet &lt;- facet_wrap( ~ surveyArea, nrow = 3)
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Area Type&quot;, y = &quot;Proportion&quot;)
#
# x-axis tick mark labels
#
xLabels &lt;- scale_x_discrete(labels = c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Overall&quot;))


################################################################################
#
# Plot
#
################################################################################
#
# Open graphics device
#
png(filename = paste(&quot;outputFigures/charts/formalSanByArea&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 12, height = 4 * ceiling(length(levels(formalSanResults$surveyArea)) / 3), units = &quot;in&quot;,
    res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFill + barFacet + barLabels + theme_wsup + theme(legend.position = &quot;top&quot;)
#
# Close graphics device
#
dev.off()


################################################################################
#
# Define plotting layers for ggplot - stacked bar by type grouped by surveyArea
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(data = formalSanResults, 
                   mapping = aes(x = surveyArea,
                                 y = estimate,
                                 fill = indicatorCode))
#
# Bar plot
#        
barPlot &lt;- geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;, alpha = 0.6)
#
# Bar fill
#
barFill &lt;- scale_fill_manual(name = &quot;Sanitation Service Provision&quot;,
                             labels = c(&quot;Formal service operators&quot;,
                                        &quot;Formal pit emptier&quot;),
                             values = formalColour)
#
#
#
barFacet &lt;- facet_wrap( ~ type, nrow = 3)
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Survey Area&quot;, y = &quot;Proportion&quot;)
#
# x-axis tick mark labels
#
xLabels &lt;- scale_x_discrete(labels = 1:length(levels(formalSanResults$surveyArea)))

################################################################################
#
# Plot
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/formalSanByType&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 8, height = 10, units = &quot;in&quot;, res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFill + barFacet + barLabels + xLabels + theme_wsup + theme(legend.position = &quot;top&quot;)
#
# Close graphics device
#
dev.off()






################################################################################
#
# overallResults: subset surveyResultsLong to indicators for overall results
#
################################################################################
#
# List of overall indicators
#
overallList &lt;- c(&quot;overall1&quot;, &quot;overall2&quot;, &quot;overall3&quot;, &quot;overall4&quot;)
#
# Subest to overall indicators
#
overallResults &lt;- subset(surveyResultsLong, indicatorCode %in% overallList)
#
# Sort overallResults by indicatorCode
#
overallResults &lt;- overallResults[order(overallResults$indicatorCode), ]
#
# Convert indicatorCode to factor and sort accordingly to match ladder
#
overallResults$indicatorCode &lt;- with(overallResults, factor(x = indicatorCode,
                                                            levels = rev(overallList))) 
#
# Convert type to factor and sort accordingly
#
overallResults$type &lt;- with(overallResults, factor(x = type,
                                                   levels = c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Overall&quot;)))
#
# Convert surveyArea to factor and sort accordingly
#
overallResults$surveyArea &lt;- with(overallResults, factor(x = surveyArea,
                                                         levels = c(&quot;Survey Area 1&quot;,
                                                                    &quot;Survey Area 2&quot;,
                                                                    &quot;Survey Area 3&quot;,
                                                                    &quot;Survey Area 4&quot;,
                                                                    &quot;Survey Area 5&quot;,
                                                                    &quot;Survey Area 6&quot;,
                                                                    &quot;Survey Area 7&quot;,
                                                                    &quot;Survey Area 8&quot;,
                                                                    &quot;Survey Area 9&quot;)))


################################################################################
#
# Define plotting layers for ggplot - stacked bar by survey area grouped by type
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(data = overallResults, mapping = aes(x = type, 
                                                        y = estimate, 
                                                        fill = indicatorCode))
#
# Bar plot
#
barPlot &lt;- geom_bar(stat = &quot;identity&quot;, position = &quot;fill&quot;, alpha = 0.8)
#
# Bar fill
#
barFill &lt;- scale_fill_manual(name = &quot;Overall access&quot;,
                             labels = c(&quot;Adequate water and sanitation&quot;,
                                        &quot;Adequate water only&quot;,
                                        &quot;Adequate sanitation only&quot;,
                                        &quot;No access to adequate services&quot;),
                             values = rev(overallColour))
#
# Facets
#
barFacet &lt;- facet_wrap( ~ surveyArea, nrow = 3)
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Area Type&quot;, y = &quot;Proportion&quot;)
#
# x-axis tick mark labels
#
xLabels &lt;- scale_x_discrete(labels = c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Overall&quot;))


################################################################################
#
# Plot
#
################################################################################
#
# Open graphics device
#
png(filename = paste(&quot;outputFigures/charts/overallByArea&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 12, height = 4 * ceiling(length(levels(overallResults$surveyArea)) / 3), units = &quot;in&quot;,
    res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFill + barFacet + barLabels + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# Define plotting layers for ggplot - stacked bar by type grouped by surveyArea
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(data = overallResults, 
                   mapping = aes(x = surveyArea,
                                 y = estimate,
                                 fill = indicatorCode))
#
# Bar plot
#        
barPlot &lt;- geom_bar(stat = &quot;identity&quot;, position = &quot;fill&quot;, alpha = 0.8)
#
# Bar fill
#
barFill &lt;- scale_fill_manual(name = &quot;Overall access&quot;,
                             labels = c(&quot;Adequate water and sanitation&quot;,
                                        &quot;Adequate water only&quot;,
                                        &quot;Adequate sanitation only&quot;,
                                        &quot;No access to adequate services&quot;),
                             values = rev(overallColour))
#
#
#
barFacet &lt;- facet_wrap( ~ type, ncol = 3)
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Survey Area&quot;, y = &quot;Proportion&quot;)
#
# x-axis tick mark labels
#
xLabels &lt;- scale_x_discrete(labels = 1:length(levels(overallResults$surveyArea)))

################################################################################
#
# Plot
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/overallByType&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 10, height = 4, units = &quot;in&quot;, res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFill + barFacet + barLabels + xLabels + theme_wsup
#
# Close graphics device
#
dev.off()
</command>
							<property title="Charts" shape="CHART"/>
							<option type="com.ef_prime.rflow.node.base.SubflowNodeModel">
								<subflow>
									<graph version="0.8" width="1625" height="513" locationtype="a" offsetx="70" offsety="41">
										<node id="95" date="1510899093936" uid="a5b606ae8af60e75" x="390" y="0">
											<command>
################################################################################
#
# Create barplots of water collectors 
#
################################################################################
#
# Convert waterCollectDF to long format
#
temp1 &lt;- subset(waterCollectDF, select = -water9b:-water9h)
names(temp1) &lt;- c(&quot;uniqueID&quot;, &quot;psu&quot;, &quot;country&quot;, &quot;ccode&quot;, &quot;zone&quot;, &quot;type&quot;, &quot;quadrat&quot;, &quot;hhid&quot;, &quot;longitude&quot;, &quot;latitude&quot;, &quot;pQuintile&quot;, &quot;collect&quot;)

temp2 &lt;- subset(waterCollectDF, select = c(-water9a, -water9c:-water9h))
names(temp2) &lt;- c(&quot;uniqueID&quot;, &quot;psu&quot;, &quot;country&quot;, &quot;ccode&quot;, &quot;zone&quot;, &quot;type&quot;, &quot;quadrat&quot;, &quot;hhid&quot;, &quot;longitude&quot;, &quot;latitude&quot;, &quot;pQuintile&quot;, &quot;collect&quot;)

temp3 &lt;- subset(waterCollectDF, select = c(-water9a:-water9b, -water9d:-water9h))
names(temp3) &lt;- c(&quot;uniqueID&quot;, &quot;psu&quot;, &quot;country&quot;, &quot;ccode&quot;, &quot;zone&quot;, &quot;type&quot;, &quot;quadrat&quot;, &quot;hhid&quot;, &quot;longitude&quot;, &quot;latitude&quot;, &quot;pQuintile&quot;, &quot;collect&quot;)

temp4 &lt;- subset(waterCollectDF, select = c(-water9a:-water9c, -water9e:-water9h))
names(temp4) &lt;- c(&quot;uniqueID&quot;, &quot;psu&quot;, &quot;country&quot;, &quot;ccode&quot;, &quot;zone&quot;, &quot;type&quot;, &quot;quadrat&quot;, &quot;hhid&quot;, &quot;longitude&quot;, &quot;latitude&quot;, &quot;pQuintile&quot;, &quot;collect&quot;)

temp5 &lt;- subset(waterCollectDF, select = c(-water9a:-water9c, -water9e:-water9h))
names(temp5) &lt;- c(&quot;uniqueID&quot;, &quot;psu&quot;, &quot;country&quot;, &quot;ccode&quot;, &quot;zone&quot;, &quot;type&quot;, &quot;quadrat&quot;, &quot;hhid&quot;, &quot;longitude&quot;, &quot;latitude&quot;, &quot;pQuintile&quot;, &quot;collect&quot;)

temp6 &lt;- subset(waterCollectDF, select = c(-water9a:-water9d, -water9f:-water9h))
names(temp6) &lt;- c(&quot;uniqueID&quot;, &quot;psu&quot;, &quot;country&quot;, &quot;ccode&quot;, &quot;zone&quot;, &quot;type&quot;, &quot;quadrat&quot;, &quot;hhid&quot;, &quot;longitude&quot;, &quot;latitude&quot;, &quot;pQuintile&quot;, &quot;collect&quot;)

temp7 &lt;- subset(waterCollectDF, select = c(-water9a:-water9e, -water9g:-water9h))
names(temp7) &lt;- c(&quot;uniqueID&quot;, &quot;psu&quot;, &quot;country&quot;, &quot;ccode&quot;, &quot;zone&quot;, &quot;type&quot;, &quot;quadrat&quot;, &quot;hhid&quot;, &quot;longitude&quot;, &quot;latitude&quot;, &quot;pQuintile&quot;, &quot;collect&quot;)

temp8 &lt;- subset(waterCollectDF, select = c(-water9a:-water9f, -water9h))
names(temp8) &lt;- c(&quot;uniqueID&quot;, &quot;psu&quot;, &quot;country&quot;, &quot;ccode&quot;, &quot;zone&quot;, &quot;type&quot;, &quot;quadrat&quot;, &quot;hhid&quot;, &quot;longitude&quot;, &quot;latitude&quot;, &quot;pQuintile&quot;, &quot;collect&quot;)

temp9 &lt;- subset(waterCollectDF, select = -water9a:-water9g)
names(temp9) &lt;- c(&quot;uniqueID&quot;, &quot;psu&quot;, &quot;country&quot;, &quot;ccode&quot;, &quot;zone&quot;, &quot;type&quot;, &quot;quadrat&quot;, &quot;hhid&quot;, &quot;longitude&quot;, &quot;latitude&quot;, &quot;pQuintile&quot;, &quot;collect&quot;)

temp &lt;- data.frame(rbind(temp1, temp2, temp3, temp4, temp5, temp6, temp7, temp8, temp9))
#
# Remove NAs
#
temp &lt;- temp[!is.na(temp$collect), ]
temp &lt;- subset(temp, collect != &quot;Don&apos;t know/no answer/not applicable&quot;)
temp &lt;- subset(temp, collect != &quot;Source inside house&quot;)
#
# Re-assign survey area values
#
temp$zone &lt;- with(temp, paste(&quot;Survey Area&quot;, zone, sep = &quot; &quot;))
#
# Re-assign area type values
#
temp$type &lt;- with(temp, ifelse(type == 1, &quot;Slum&quot;, &quot;Other&quot;))
#
# Re-order collect variable
#
temp &lt;- temp[order(temp$collect), ]
#
# Re-assign factors for collect variable
#
temp$collect &lt;- with(temp, factor(x = collect, levels = c(&quot;Adult men&quot;, 
                                                          &quot;Adult women&quot;, 
                                                          &quot;Boys _15&quot;, 
                                                          &quot;Girls _15&quot;, 
                                                          &quot;Whole family&quot;)))
#
# Re-assign factors for area type
#
temp$type &lt;- with(temp, factor(x = type, levels = c(&quot;Slum&quot;, &quot;Other&quot;)))                                                          
#
# Assign temp to waterCollectLong data.frame
#
waterCollectLong &lt;- temp


################################################################################
#
# Create plotting layers for ggplot
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(waterCollectLong, mapping = aes(x = type, fill = collect))
#
# Bar plot
#
barPlot &lt;- geom_bar(position = &quot;stack&quot;, alpha = 0.8)
#
# Create layout
#
barFacet &lt;- facet_wrap( ~ zone, ncol = 3)
#
# Colours
#
barFill &lt;- scale_fill_manual(name = &quot;Household Water Collector/s&quot;,
                             labels = c(&quot;Adult Men&quot;, &quot;Adult Women&quot;, &quot;Boys&quot;, &quot;Girls&quot;, &quot;Whole family&quot;),
                             values = collectColour) 
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Area Type&quot;, y = &quot;&quot;)

################################################################################
#
# Plot water collectors by survey area grouped by type
#
################################################################################
#
# Open graphics device
#
png(filename = paste(&quot;outputFigures/charts/waterCollectorByArea&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 8, height = 4 * ceiling(length(unique(waterCollectLong$zone)) / 3), units = &quot;in&quot;,
    res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFacet + barFill + barLabels + theme_wsup + theme(legend.position = &quot;top&quot;)
#
# Close graphics device
#
dev.off()


################################################################################
#
# Create plotting layers for ggplot
#
################################################################################
#
# Create base plot
#
basePlot &lt;- ggplot(waterCollectLong, mapping = aes(x = zone, fill = collect))
#
# Create bar plot
#
barPlot &lt;- geom_bar(position = &quot;stack&quot;, alpha = 0.8)
#
# Create plot facets
#
barFacet &lt;- facet_wrap( ~ type, ncol = 3)
#
# Creat fill colours
#
barFill &lt;- scale_fill_manual(name = &quot;Household Water Collector/s&quot;,
                             labels = c(&quot;Adult Men&quot;, &quot;Adult Women&quot;, &quot;Boys&quot;, &quot;Girls&quot;, &quot;Whole family&quot;),
                             values = collectColour) 

#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Survey Area&quot;, y = &quot;&quot;)
#
# x-axis labels
#
xLabels &lt;- scale_x_discrete(labels = 1:length(unique(waterCollectLong$zone)))


################################################################################
#
# Plot water collectors by survey area grouped by area
#
################################################################################
#
# Open graphics device
#
png(filename = paste(&quot;outputFigures/charts/waterCollectorByType&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 10, height = 4, units = &quot;in&quot;,
    res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFacet + barFill + barLabels + xLabels + theme_wsup + theme(legend.position = &quot;top&quot;)
#
# Close graphics device
#
dev.off()



################################################################################
#
# Create plotting layers for ggplot
#
################################################################################
#
# Create base plot
#
basePlot &lt;- ggplot(waterCollectLong, mapping = aes(x = pQuintile, fill = collect))
#
# Create bar plot
#
barPlot &lt;- geom_bar(position = &quot;stack&quot;, alpha = 0.8)
#
# Create plot facets
#
barFacet &lt;- facet_wrap( ~ zone, ncol = 3)
#
# Create colour fill
#
barFill &lt;- scale_fill_manual(name = &quot;Household Water Collector/s&quot;,
                             labels = c(&quot;Adult Men&quot;, &quot;Adult Women&quot;, &quot;Boys&quot;, &quot;Girls&quot;, &quot;Whole family&quot;),
                             values = collectColour) 

#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Wealth Quintile&quot;, y = &quot;&quot;)


################################################################################
#
# Plot water collectors by survey area grouped by quintiles
#
################################################################################
#
# Open graphics device
#
png(filename = paste(&quot;outputFigures/charts/waterCollectorByQuintile&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 12, height = 4 * (length(unique(waterCollectLong$zone)) / 3), units = &quot;in&quot;,
    res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFacet + barFill + barLabels + xlim(c(1,5)) + theme_wsup  + theme(legend.position = &quot;top&quot;)
#
# Close graphics device
#
dev.off()

</command>
											<property title="Water Collector" shape="CHART"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<node id="96" date="1510899093936" uid="8df8b807669a5c39" x="270" y="110">
											<command>################################################################################
#
# Transform results data to long format for ggplot
#
################################################################################
#
# Read survey results
#
surveyResults &lt;- read.csv(&quot;outputTables/surveyResultsBGD.csv&quot;)
#
# Subset survey results to columns needed for plotting
#
temp1 &lt;- subset(surveyResults, select = c(indicatorName, indicatorCode, surveyArea, slumTotal, slumEst))
temp2 &lt;- subset(surveyResults, select = c(indicatorName, indicatorCode, surveyArea, otherTotal, otherEst))
temp3 &lt;- subset(surveyResults, select = c(indicatorName, indicatorCode, surveyArea, total, totalEst))
#
# Add area type variable
#
temp1$type &lt;- rep(&quot;Slum&quot;, nrow(temp1))
temp2$type &lt;- rep(&quot;Other&quot;, nrow(temp2))
temp3$type &lt;- rep(&quot;Overall&quot;, nrow(temp3))
#
# Rename variables
#
names(temp1) &lt;- c(&quot;indicatorName&quot;, &quot;indicatorCode&quot;, &quot;surveyArea&quot;, &quot;n&quot;, &quot;estimate&quot;, &quot;type&quot;)
names(temp2) &lt;- c(&quot;indicatorName&quot;, &quot;indicatorCode&quot;, &quot;surveyArea&quot;, &quot;n&quot;, &quot;estimate&quot;, &quot;type&quot;)
names(temp3) &lt;- c(&quot;indicatorName&quot;, &quot;indicatorCode&quot;, &quot;surveyArea&quot;, &quot;n&quot;, &quot;estimate&quot;, &quot;type&quot;)
#
# Create single long data.frame
#
surveyResultsLong &lt;- data.frame(rbind(temp1, temp2, temp3))


################################################################################
#
# jmpWaterResults: subset surveyResultsLong to indicators for water ladder
#
################################################################################
#
# List of jmp water indicators
#
jmpWaterList &lt;- c(&quot;jmpWater1&quot;, &quot;jmpWater2&quot;, &quot;jmpWater3&quot;, &quot;jmpWater4&quot;, &quot;jmpWater5&quot;)
#
# Subest to jmp water indicators
#
jmpWaterResults &lt;- subset(surveyResultsLong, indicatorCode %in% jmpWaterList)
#
# Sort jmpWaterResults by indicatorCode
#
jmpWaterResults &lt;- jmpWaterResults[order(jmpWaterResults$indicatorCode), ]
#
# Convert indicatorCode to factor and sort accordingly to match ladder
#
jmpWaterResults$indicatorCode &lt;- with(jmpWaterResults, factor(x = indicatorCode,
                                                              levels = rev(jmpWaterList))) 
#
# Convert type to factor and sort accordingly
#
jmpWaterResults$type &lt;- with(jmpWaterResults, factor(x = type,
                                                     levels = c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Overall&quot;)))
#
# Convert surveyArea to factor and sort accordingly
#
jmpWaterResults$surveyArea &lt;- with(jmpWaterResults, factor(x = surveyArea,
                                                           levels = c(&quot;Survey Area 1&quot;,
                                                                      &quot;Survey Area 2&quot;,
                                                                      &quot;Survey Area 3&quot;,
                                                                      &quot;Survey Area 4&quot;,
                                                                      &quot;Survey Area 5&quot;,
                                                                      &quot;Survey Area 6&quot;,
                                                                      &quot;Survey Area 7&quot;,
                                                                      &quot;Survey Area 8&quot;,
                                                                      &quot;Survey Area 9&quot;)))

################################################################################
#
# Define plotting layers for ggplot - stacked bar by survey area grouped by type
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(data = jmpWaterResults, mapping = aes(x = type, 
                                                         y = estimate, 
                                                         fill = indicatorCode))
#
# Bar plot
#
barPlot &lt;- geom_bar(stat = &quot;identity&quot;, position = &quot;fill&quot;, alpha = 0.8)
#
# Bar fill
#
barFill &lt;- scale_fill_manual(name = &quot;Drinking Water Ladder&quot;,
                             labels = c(&quot;Basic Plus&quot;,
                                        &quot;Basic&quot;,
                                        &quot;Limited&quot;,
                                        &quot;Unimproved&quot;,
                                        &quot;Surface Water&quot;),
                             values = waterLadder)
#
# Facets
#
barFacet &lt;- facet_wrap( ~ surveyArea, nrow = 3)
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Area Type&quot;, y = &quot;Proportion&quot;)
#
# x-axis tick mark labels
#
xLabels &lt;- scale_x_discrete(labels = c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Overall&quot;))


################################################################################
#
# Plot
#
################################################################################
#
# Open graphics device
#
png(filename = paste(&quot;outputFigures/charts/waterLadderByArea&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 12, height = 4 * ceiling(length(levels(jmpWaterResults$surveyArea)) / 3), units = &quot;in&quot;,
    res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFill + barFacet + barLabels + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# Define plotting layers for ggplot - stacked bar by type grouped by surveyArea
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(data = jmpWaterResults, 
                   mapping = aes(x = surveyArea,
                                 y = estimate,
                                 fill = indicatorCode))
#
# Bar plot
#        
barPlot &lt;- geom_bar(stat = &quot;identity&quot;, position = &quot;fill&quot;, alpha = 0.8)
#
# Bar fill
#
barFill &lt;- scale_fill_manual(name = &quot;Drinking Water Ladder&quot;,
                             labels = c(&quot;Basic Plus&quot;,
                                        &quot;Basic&quot;,
                                        &quot;Limited&quot;,
                                        &quot;Unimproved&quot;,
                                        &quot;Surface Water&quot;),
                             values = waterLadder)
#
#
#
barFacet &lt;- facet_wrap( ~ type, ncol = 3)
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Survey Area&quot;, y = &quot;Proportion&quot;)
#
# x-axis tick mark labels
#
xLabels &lt;- scale_x_discrete(labels = 1:length(unique(jmpWaterResults$surveyArea)))

################################################################################
#
# Plot
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/waterLadderByType&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 10, height = 4, units = &quot;in&quot;, res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFill + barFacet + barLabels + xLabels + theme_wsup
#
# Close graphics device
#
dev.off()



################################################################################
#
# jmpSanResults: subset surveyResultsLong to indicators for sanitation ladder
#
################################################################################
#
# List of jmp sanitation indicators
#
jmpSanList &lt;- c(&quot;jmpSan1&quot;, &quot;jmpSan2&quot;, &quot;jmpSan3&quot;, &quot;jmpSan4&quot;, &quot;jmpSan5&quot;)
#
# Subest to jmp sanitation indicators
#
jmpSanResults &lt;- subset(surveyResultsLong, indicatorCode %in% jmpSanList)
#
# Sort jmpSanResults by indicatorCode
#
jmpSanResults &lt;- jmpSanResults[order(jmpSanResults$indicatorCode), ]
#
# Convert indicatorCode to factor and sort accordingly to match ladder
#
jmpSanResults$indicatorCode &lt;- with(jmpSanResults, factor(x = indicatorCode,
                                                          levels = rev(jmpSanList))) 
#
# Convert type to factor and sort accordingly
#
jmpSanResults$type &lt;- with(jmpSanResults, factor(x = type,
                                                 levels = c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Overall&quot;)))
#
# Convert surveyArea to factor and sort accordingly
#
jmpSanResults$surveyArea &lt;- with(jmpSanResults, factor(x = surveyArea,
                                                           levels = c(&quot;Survey Area 1&quot;,
                                                                      &quot;Survey Area 2&quot;,
                                                                      &quot;Survey Area 3&quot;,
                                                                      &quot;Survey Area 4&quot;,
                                                                      &quot;Survey Area 5&quot;,
                                                                      &quot;Survey Area 6&quot;,
                                                                      &quot;Survey Area 7&quot;,
                                                                      &quot;Survey Area 8&quot;,
                                                                      &quot;Survey Area 9&quot;)))


################################################################################
#
# Define plotting layers for ggplot - stacked bar by survey area grouped by type
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(data = jmpSanResults, mapping = aes(x = type, 
                                                       y = estimate, 
                                                       fill = indicatorCode))
#
# Bar plot
#
barPlot &lt;- geom_bar(stat = &quot;identity&quot;, position = &quot;fill&quot;, alpha = 0.8)
#
# Bar fill
#
barFill &lt;- scale_fill_manual(name = &quot;Sanitation Ladder&quot;,
                             labels = c(&quot;Self-managed&quot;,
                                        &quot;Basic&quot;,
                                        &quot;Limited&quot;,
                                        &quot;Unimproved&quot;,
                                        &quot;Open defecation&quot;),
                             values = sanitationLadder)
#
# Facets
#
barFacet &lt;- facet_wrap( ~ surveyArea, nrow = 3)
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Area Type&quot;, y = &quot;Proportion&quot;)
#
# x-axis tick mark labels
#
xLabels &lt;- scale_x_discrete(labels = c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Overall&quot;))


################################################################################
#
# Plot
#
################################################################################
#
# Open graphics device
#
png(filename = paste(&quot;outputFigures/charts/sanitationLadderByArea&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 12, height = 4 * ceiling(length(levels(jmpSanResults$surveyArea)) / 3), units = &quot;in&quot;,
    res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFill + barFacet + barLabels + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# Define plotting layers for ggplot - stacked bar by type grouped by surveyArea
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(data = jmpSanResults, 
                   mapping = aes(x = surveyArea,
                                 y = estimate,
                                 fill = indicatorCode))
#
# Bar plot
#        
barPlot &lt;- geom_bar(stat = &quot;identity&quot;, position = &quot;fill&quot;, alpha = 0.8)
#
# Bar fill
#
barFill &lt;- scale_fill_manual(name = &quot;Sanitation Ladder&quot;,
                             labels = c(&quot;Self-managed&quot;,
                                        &quot;Basic&quot;,
                                        &quot;Limited&quot;,
                                        &quot;Unimproved&quot;,
                                        &quot;Open Defecation&quot;),
                             values = sanitationLadder)
#
#
#
barFacet &lt;- facet_wrap( ~ type, ncol = 3)
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Survey Area&quot;, y = &quot;Proportion&quot;)
#
# x-axis tick mark labels
#
xLabels &lt;- scale_x_discrete(labels = 1:length(levels(jmpSanResults$surveyArea)))

################################################################################
#
# Plot
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/sanitationLadderByType&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 10, height = 4, units = &quot;in&quot;, res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFill + barFacet + barLabels + xLabels + theme_wsup
#
# Close graphics device
#
dev.off()



################################################################################
#
# jmpHandResults: subset surveyResultsLong to indicators for handwashing ladder
#
################################################################################
#
# List of jmp handwashing indicators
#
jmpHandList &lt;- c(&quot;jmpHand1&quot;, &quot;jmpHand2&quot;, &quot;jmpHand3&quot;)
#
# Subest to jmp handwashing indicators
#
jmpHandResults &lt;- subset(surveyResultsLong, indicatorCode %in% jmpHandList)
#
# Sort jmpHandResults by indicatorCode
#
jmpHandResults &lt;- jmpHandResults[order(jmpHandResults$indicatorCode), ]
#
# Convert indicatorCode to factor and sort accordingly to match ladder
#
jmpHandResults$indicatorCode &lt;- with(jmpHandResults, factor(x = indicatorCode,
                                                            levels = rev(jmpHandList))) 
#
# Convert type to factor and sort accordingly
#
jmpHandResults$type &lt;- with(jmpHandResults, factor(x = type,
                                                   levels = c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Overall&quot;)))
#
# Convert surveyArea to factor and sort accordingly
#
jmpHandResults$surveyArea &lt;- with(jmpHandResults, factor(x = surveyArea,
                                                         levels = c(&quot;Survey Area 1&quot;,
                                                                    &quot;Survey Area 2&quot;,
                                                                    &quot;Survey Area 3&quot;,
                                                                    &quot;Survey Area 4&quot;,
                                                                    &quot;Survey Area 5&quot;,
                                                                    &quot;Survey Area 6&quot;,
                                                                    &quot;Survey Area 7&quot;,
                                                                    &quot;Survey Area 8&quot;,
                                                                    &quot;Survey Area 9&quot;)))


################################################################################
#
# Define plotting layers for ggplot - stacked bar by survey area grouped by type
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(data = jmpHandResults, mapping = aes(x = type, 
                                                        y = estimate, 
                                                        fill = indicatorCode))
#
# Bar plot
#
barPlot &lt;- geom_bar(stat = &quot;identity&quot;, position = &quot;fill&quot;, alpha = 0.8)
#
# Bar fill
#
barFill &lt;- scale_fill_manual(name = &quot;Handwashing Ladder&quot;,
                             labels = c(&quot;Basic&quot;,
                                        &quot;Unimproved&quot;,
                                        &quot;No facility&quot;),
                             values = handwashLadder)
#
# Facets
#
barFacet &lt;- facet_wrap( ~ surveyArea, nrow = 3)
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Area Type&quot;, y = &quot;Proportion&quot;)
#
# x-axis tick mark labels
#
xLabels &lt;- scale_x_discrete(labels = c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Overall&quot;))


################################################################################
#
# Plot
#
################################################################################
#
# Open graphics device
#
png(filename = paste(&quot;outputFigures/charts/handwashLadderByArea&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 12, height = 4 * ceiling(length(levels(jmpHandResults$surveyArea)) / 3), units = &quot;in&quot;,
    res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFill + barFacet + barLabels + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# Define plotting layers for ggplot - stacked bar by type grouped by surveyArea
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(data = jmpHandResults, 
                   mapping = aes(x = surveyArea,
                                 y = estimate,
                                 fill = indicatorCode))
#
# Bar plot
#        
barPlot &lt;- geom_bar(stat = &quot;identity&quot;, position = &quot;fill&quot;, alpha = 0.8)
#
# Bar fill
#
barFill &lt;- scale_fill_manual(name = &quot;Handwashing Ladder&quot;,
                             labels = c(&quot;Basic&quot;,
                                        &quot;Unimproved&quot;,
                                        &quot;No facility&quot;),
                             values = handwashLadder)
#
#
#
barFacet &lt;- facet_wrap( ~ type, ncol = 3)
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Survey Area&quot;, y = &quot;Proportion&quot;)
#
# x-axis tick mark labels
#
xLabels &lt;- scale_x_discrete(labels = 1:length(levels(jmpHandResults$surveyArea)))

################################################################################
#
# Plot
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/handwashLadderByType&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 10, height = 4, units = &quot;in&quot;, res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFill + barFacet + barLabels + xLabels + theme_wsup
#
# Close graphics device
#
dev.off()</command>
											<property title="Ladders" shape="CHART"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<node id="97" date="1510899093937" uid="eed35174b310fb11" x="50" y="110">
											<command>
################################################################################
#
#  Select and read indicator steering file: Accepts CSV data files
#
################################################################################
#
# Prompt user to supply indicator steering file
#
tkmessageBox(title = &quot;Load file&quot;,
             message = &quot;Select indicators steering file&quot;, 
	        icon = &quot;info&quot;, 
	        type = &quot;ok&quot;)
#
# Cycle through indicator steering file selection prompts
#
repeat
  {
  #
  # Cycle through indicator steering file selection prompts when no file is selected
  #
  repeat
    {
    #
    # Select indicator steering file
    #
    fileName &lt;- tclvalue(tkgetOpenFile())
    #
    # Determine if a indicator steering file has been selected
    #	
    if(!nchar(fileName)) 
      {
      #
      # Prompt user that no file has been selected
      #
      error1 &lt;- tkmessageBox(title = &quot;Error&quot;,
				         message = &quot;No file was selected! Please try again.&quot;,
				         icon = &quot;error&quot;,
				         type = &quot;retrycancel&quot;)
      }
    #
    # Break repeat once any file has been selected
    #	
    if(nchar(fileName) &gt; 0) break
    #
    # Break repeat if user cancels option to select file
    #
    if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
    } 
  #
  # Break repeat if user cancels option to select file
  #
  if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  #
  # Try to read indicator steering file based on filename provided by user
  #	
  steerIndicators &lt;- try(expr = read.csv(file = fileName, header = TRUE, sep = &quot;,&quot;), 
		               silent = TRUE)
  #
  # Check if indicator steering file provided is in correct format (CSV file)
  #
  if(exists(&quot;steerIndicators&quot;) &amp;&amp; class(steerIndicators) == &quot;try-error&quot;)
    {
    #
    # Prompt user that file format is incorrect
    #
    error2 &lt;- tkmessageBox(title = &quot;Error&quot;,
			            message = paste(&quot;Problem reading file &apos;&quot;, basename(fileName), &quot;&apos;. Please try again&quot;, sep = &quot;,&quot;),
			            icon = &quot;error&quot;,
			            type = &quot;retrycancel&quot;)
    }
  #
  # Break repeat once selected indicator steering file is in correct format
  #
  if(exists(&quot;steerIndicators&quot;) &amp;&amp; class(steerIndicators) != &quot;try-error&quot;) break
  #
  # Break repeat if user cancels option to retry providing a new file
  #
  if(exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;) break
  }
#
# Determine if user cancels option to select file or cancels option to retry providing a new file
#
if((exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) | (exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;))
  {
  #
  # Prompt user that no file has been loaded
  #
  tkmessageBox(title = &quot;Warning&quot;,
		     message = &quot;You have not loaded any data file&quot;,
		     icon = &quot;warning&quot;,
		     type = &quot;ok&quot;)
  }
#
# Determine user has successfully selected and loaded an appropriate data file
#
if(exists(&quot;steerIndicators&quot;) &amp;&amp; class(steerIndicators) != &quot;try-error&quot;)
  {
  #
  # Prompt use of the filename of the indicator steering file file selected
  #
  tkmessageBox(title = &quot;Success!&quot;,
     		message = paste(&quot;You have loaded the data file named &apos;&quot;, basename(fileName), &quot;&apos;.&quot;, sep = &quot;&quot;),
		     icon = &quot;info&quot;,
		     type = &quot;ok&quot;)
  }
#
# Clean-up filename
#
rm(fileName)
#
# Clean-up error1 if present
#
if(exists(&quot;error1&quot;))
  {
  rm(error1)
  }
#
# Clean-up error2 if present
#
if(exists(&quot;error2&quot;))
  {
  rm(error2)
  }

</command>
											<property title="Read steering file" shape="INOUT"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<node id="98" date="1510899093937" uid="d12720abec7ba08f" x="500" y="0">
											<command>
################################################################################
#
# Transform results data to long format for ggplot
#
################################################################################
#
# Read survey results
#
surveyResults &lt;- read.csv(&quot;outputTables/surveyResultsBGD.csv&quot;)
#
# Subset survey results to columns needed for plotting
#
temp1 &lt;- subset(surveyResults, select = c(indicatorName, indicatorCode, surveyArea, slumTotal, slumEst))
temp2 &lt;- subset(surveyResults, select = c(indicatorName, indicatorCode, surveyArea, otherTotal, otherEst))
temp3 &lt;- subset(surveyResults, select = c(indicatorName, indicatorCode, surveyArea, total, totalEst))
#
# Add area type variable
#
temp1$type &lt;- rep(&quot;Slum&quot;, nrow(temp1))
temp2$type &lt;- rep(&quot;Other&quot;, nrow(temp2))
temp3$type &lt;- rep(&quot;Overall&quot;, nrow(temp3))
#
# Rename variables
#
names(temp1) &lt;- c(&quot;indicatorName&quot;, &quot;indicatorCode&quot;, &quot;surveyArea&quot;, &quot;n&quot;, &quot;estimate&quot;, &quot;type&quot;)
names(temp2) &lt;- c(&quot;indicatorName&quot;, &quot;indicatorCode&quot;, &quot;surveyArea&quot;, &quot;n&quot;, &quot;estimate&quot;, &quot;type&quot;)
names(temp3) &lt;- c(&quot;indicatorName&quot;, &quot;indicatorCode&quot;, &quot;surveyArea&quot;, &quot;n&quot;, &quot;estimate&quot;, &quot;type&quot;)
#
# Create single long data.frame
#
surveyResultsLong &lt;- data.frame(rbind(temp1, temp2, temp3))


################################################################################
#
# formalWater: subset surveyResultsLong to indicators for formal water services
#
################################################################################
#
# List of formal water services
#
formalWaterList &lt;- c(&quot;water2a&quot;, &quot;water17&quot;)
#
# Subest to formal water services
#
formalWaterResults &lt;- subset(surveyResultsLong, indicatorCode %in% formalWaterList)
#
# Sort formallWaterResults by indicatorCode
#
formalWaterResults &lt;- formalWaterResults[order(formalWaterResults$indicatorCode), ]
#
# Convert indicatorCode to factor and sort accordingly to match ladder
#
formalWaterResults$indicatorCode &lt;- with(formalWaterResults, factor(x = indicatorCode,
                                                                    levels = formalWaterList)) 
#
# Convert type to factor and sort accordingly
#
formalWaterResults$type &lt;- with(formalWaterResults, factor(x = type,
                                                           levels = c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Overall&quot;)))
#
# Convert surveyArea to factor and sort accordingly
#
formalWaterResults$surveyArea &lt;- with(formalWaterResults, factor(x = surveyArea,
                                                                 levels = c(&quot;Survey Area 1&quot;,
                                                                            &quot;Survey Area 2&quot;,
                                                                            &quot;Survey Area 3&quot;,
                                                                            &quot;Survey Area 4&quot;,
                                                                            &quot;Survey Area 5&quot;,
                                                                            &quot;Survey Area 6&quot;,
                                                                            &quot;Survey Area 7&quot;,
                                                                            &quot;Survey Area 8&quot;,
                                                                            &quot;Survey Area 9&quot;)))


################################################################################
#
# Define plotting layers for ggplot - stacked bar by survey area grouped by type
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(data = formalWaterResults, mapping = aes(x = type, 
                                                            y = estimate, 
                                                            fill = indicatorCode))
#
# Bar plot
#
barPlot &lt;- geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;, alpha = 0.6)
#
# Bar fill
#
barFill &lt;- scale_fill_manual(name = &quot;Water Service Provision&quot;,
                             labels = c(&quot;Formal water service provision&quot;,
                                        &quot;Formal water service maintenance&quot;),
                             values = formalColour)
#
# Facets
#
barFacet &lt;- facet_wrap( ~ surveyArea, nrow = 3)
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Area Type&quot;, y = &quot;Proportion&quot;)
#
# x-axis tick mark labels
#
xLabels &lt;- scale_x_discrete(labels = c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Overall&quot;))


################################################################################
#
# Plot
#
################################################################################
#
# Open graphics device
#
png(filename = paste(&quot;outputFigures/charts/formalWaterByArea&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 12, height = 4 * ceiling(length(levels(formalWaterResults$surveyArea)) / 3), units = &quot;in&quot;,
    res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFill + barFacet + barLabels + theme_wsup + theme(legend.position = &quot;top&quot;)
#
# Close graphics device
#
dev.off()


################################################################################
#
# Define plotting layers for ggplot - stacked bar by type grouped by surveyArea
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(data = formalWaterResults, 
                   mapping = aes(x = surveyArea,
                                 y = estimate,
                                 fill = indicatorCode))
#
# Bar plot
#        
barPlot &lt;- geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;, alpha = 0.6)
#
# Bar fill
#
barFill &lt;- scale_fill_manual(name = &quot;Water Service Provision&quot;,
                             labels = c(&quot;Formal water service provision&quot;,
                                        &quot;Formal water service maintenance&quot;),
                             values = formalColour)
#
#
#
barFacet &lt;- facet_wrap( ~ type, nrow = 3)
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Survey Area&quot;, y = &quot;Proportion&quot;)
#
# x-axis tick mark labels
#
xLabels &lt;- scale_x_discrete(labels = 1:length(levels(formalWaterResults$surveyArea)))

################################################################################
#
# Plot
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/formalWaterByType&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 8, height = 10, units = &quot;in&quot;, res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFill + barFacet + barLabels + xLabels + theme_wsup + theme(legend.position = &quot;top&quot;)
#
# Close graphics device
#
dev.off()



################################################################################
#
# formalSan: subset surveyResultsLong to indicators for formal sanitation services
#
################################################################################
#
# List of formal water services
#
formalSanList &lt;- c(&quot;san25&quot;, &quot;san35&quot;)
#
# Subest to formal water services
#
formalSanResults &lt;- subset(surveyResultsLong, indicatorCode %in% formalSanList)
#
# Sort formalSanResults by indicatorCode
#
formalSanResults &lt;- formalSanResults[order(formalSanResults$indicatorCode), ]
#
# Convert indicatorCode to factor and sort accordingly to match ladder
#
formalSanResults$indicatorCode &lt;- with(formalSanResults, factor(x = indicatorCode,
                                                                levels = formalSanList)) 
#
# Convert type to factor and sort accordingly
#
formalSanResults$type &lt;- with(formalSanResults, factor(x = type,
                                                       levels = c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Overall&quot;)))
#
# Convert surveyArea to factor and sort accordingly
#
formalSanResults$surveyArea &lt;- with(formalSanResults, factor(x = surveyArea,
                                                             levels = c(&quot;Survey Area 1&quot;,
                                                                        &quot;Survey Area 2&quot;,
                                                                        &quot;Survey Area 3&quot;,
                                                                        &quot;Survey Area 4&quot;,
                                                                        &quot;Survey Area 5&quot;,
                                                                        &quot;Survey Area 6&quot;,
                                                                        &quot;Survey Area 7&quot;,
                                                                        &quot;Survey Area 8&quot;,
                                                                        &quot;Survey Area 9&quot;)))


################################################################################
#
# Define plotting layers for ggplot - stacked bar by survey area grouped by type
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(data = formalSanResults, mapping = aes(x = type, 
                                                            y = estimate, 
                                                            fill = indicatorCode))
#
# Bar plot
#
barPlot &lt;- geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;, alpha = 0.6)
#
# Bar fill
#
barFill &lt;- scale_fill_manual(name = &quot;Sanitation Service Provision&quot;,
                             labels = c(&quot;Formal service operators&quot;,
                                        &quot;Formal pit emptier&quot;),
                             values = formalColour)
#
# Facets
#
barFacet &lt;- facet_wrap( ~ surveyArea, nrow = 3)
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Area Type&quot;, y = &quot;Proportion&quot;)
#
# x-axis tick mark labels
#
xLabels &lt;- scale_x_discrete(labels = c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Overall&quot;))


################################################################################
#
# Plot
#
################################################################################
#
# Open graphics device
#
png(filename = paste(&quot;outputFigures/charts/formalSanByArea&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 12, height = 4 * ceiling(length(levels(formalSanResults$surveyArea)) / 3), units = &quot;in&quot;,
    res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFill + barFacet + barLabels + theme_wsup + theme(legend.position = &quot;top&quot;)
#
# Close graphics device
#
dev.off()


################################################################################
#
# Define plotting layers for ggplot - stacked bar by type grouped by surveyArea
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(data = formalSanResults, 
                   mapping = aes(x = surveyArea,
                                 y = estimate,
                                 fill = indicatorCode))
#
# Bar plot
#        
barPlot &lt;- geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;, alpha = 0.6)
#
# Bar fill
#
barFill &lt;- scale_fill_manual(name = &quot;Sanitation Service Provision&quot;,
                             labels = c(&quot;Formal service operators&quot;,
                                        &quot;Formal pit emptier&quot;),
                             values = formalColour)
#
#
#
barFacet &lt;- facet_wrap( ~ type, nrow = 3)
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Survey Area&quot;, y = &quot;Proportion&quot;)
#
# x-axis tick mark labels
#
xLabels &lt;- scale_x_discrete(labels = 1:length(levels(formalSanResults$surveyArea)))

################################################################################
#
# Plot
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/formalSanByType&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 8, height = 10, units = &quot;in&quot;, res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFill + barFacet + barLabels + xLabels + theme_wsup + theme(legend.position = &quot;top&quot;)
#
# Close graphics device
#
dev.off()




</command>
											<property title="Others" shape="CHART"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<node id="99" date="1510899093936" uid="88d3dbe405b81367" x="590" y="110">
											<command></command>
											<property/>
											<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
												<entry key="io">out</entry>
											</option>
										</node>
										<node id="100" date="1510899093938" uid="3170dfda0a8c6cd6" x="-30" y="0">
											<command></command>
											<property/>
											<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
												<entry key="io">in</entry>
											</option>
										</node>
										<node id="101" date="1510899093937" uid="9711e24796ffc0b6" x="390" y="110">
											<command>          
################################################################################
#
# Transform results data by wealth quintile to long format for ggplot
#
################################################################################
#
# Read survey results
#
surveyResults &lt;- read.csv(&quot;outputTables/surveyResultsWealthBGD.csv&quot;)
#
# Subset survey results to columns needed for plotting
#
temp1 &lt;- subset(surveyResults, select = c(indicatorName, indicatorCode, wealthQuintile, slumTotal, slumEst))
temp2 &lt;- subset(surveyResults, select = c(indicatorName, indicatorCode, wealthQuintile, otherTotal, otherEst))
temp3 &lt;- subset(surveyResults, select = c(indicatorName, indicatorCode, wealthQuintile, total, totalEst))
#
# Add area type variable
#
temp1$type &lt;- rep(&quot;Slum&quot;, nrow(temp1))
temp2$type &lt;- rep(&quot;Other&quot;, nrow(temp2))
temp3$type &lt;- rep(&quot;Overall&quot;, nrow(temp3))
#
# Rename variables
#
names(temp1) &lt;- c(&quot;indicatorName&quot;, &quot;indicatorCode&quot;, &quot;wealthQuintile&quot;, &quot;n&quot;, &quot;estimate&quot;, &quot;type&quot;)
names(temp2) &lt;- c(&quot;indicatorName&quot;, &quot;indicatorCode&quot;, &quot;wealthQuintile&quot;, &quot;n&quot;, &quot;estimate&quot;, &quot;type&quot;)
names(temp3) &lt;- c(&quot;indicatorName&quot;, &quot;indicatorCode&quot;, &quot;wealthQuintile&quot;, &quot;n&quot;, &quot;estimate&quot;, &quot;type&quot;)
#
# Create single long data.frame
#
surveyResultsLong &lt;- data.frame(rbind(temp1, temp2, temp3))


################################################################################
#
# expenseWater: subset surveyResultsLong to indicators for drinking water expense
#
################################################################################
#
# Subest to jmp water indicators
#
expenseWater &lt;- subset(surveyResultsLong, indicatorCode == &quot;water12&quot;)
#
# Convert type to factor and sort accordingly
#
expenseWater$type &lt;- with(expenseWater, factor(x = type,
                                               levels = c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Overall&quot;)))
#
# Convert wealth quintile to factor and sort accordingly
#
expenseWater$wealthQuintile &lt;- with(expenseWater, factor(x = wealthQuintile,
                                                         levels = c(&quot;Wealth Quintile 1&quot;,
                                                                    &quot;Wealth Quintile 2&quot;,
                                                                    &quot;Wealth Quintile 3&quot;,
                                                                    &quot;Wealth Quintile 4&quot;,
                                                                    &quot;Wealth Quintile 5&quot;)))

################################################################################
#
# Define plotting layers for ggplot - barplot by wealth quintile grouped by type
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(data = expenseWater, mapping = aes(x = wealthQuintile, 
                                                      y = estimate))
#
# Bar plot
#
barPlot &lt;- geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;, 
                    colour = wsupColour, fill = wsupColour, alpha = 0.6)
#
# Facets
#
barFacet &lt;- facet_wrap( ~ type, nrow = 3)
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Wealth Quintiles&quot;, y = &quot;Mean Expenditure&quot;)
#
# x-axis tick mark labels
#
xLabels &lt;- scale_x_discrete(labels = 1:5)


################################################################################
#
# Plot
#
################################################################################
#
# Open graphics device
#
png(filename = paste(&quot;outputFigures/charts/expenseWater&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 8, height = 10, units = &quot;in&quot;,
    res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFacet + barLabels + xLabels + theme_wsup
#
# Close graphics device
#
dev.off()



################################################################################
#
# expenseSan: subset surveyResultsLong to indicators for sanitation expense
#
################################################################################
#
# Subest to sanitation expense indicator
#
expenseSan &lt;- subset(surveyResultsLong, indicatorCode == &quot;san14&quot;)
#
# Convert type to factor and sort accordingly
#
expenseSan$type &lt;- with(expenseSan, factor(x = type,
                                           levels = c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Overall&quot;)))
#
# Convert wealth quintile to factor and sort accordingly
#
expenseSan$wealthQuintile &lt;- with(expenseSan, factor(x = wealthQuintile,
                                                     levels = c(&quot;Wealth Quintile 1&quot;,
                                                                &quot;Wealth Quintile 2&quot;,
                                                                &quot;Wealth Quintile 3&quot;,
                                                                &quot;Wealth Quintile 4&quot;,
                                                                &quot;Wealth Quintile 5&quot;)))

################################################################################
#
# Define plotting layers for ggplot - barplot by wealth quintile grouped by type
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(data = expenseSan, mapping = aes(x = wealthQuintile, 
                                                      y = estimate))
#
# Bar plot
#
barPlot &lt;- geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;, 
                    colour = wsupColour, fill = wsupColour, alpha = 0.6)
#
# Facets
#
barFacet &lt;- facet_wrap( ~ type, nrow = 3)
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Wealth Quintiles&quot;, y = &quot;Mean Expenditure&quot;)
#
# x-axis tick mark labels
#
xLabels &lt;- scale_x_discrete(labels = 1:5)


################################################################################
#
# Plot
#
################################################################################
#
# Open graphics device
#
png(filename = paste(&quot;outputFigures/charts/expenseSan&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 8, height = 10, units = &quot;in&quot;,
    res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFacet + barLabels + xLabels + theme_wsup
#
# Close graphics device
#
dev.off()



</command>
											<property title="Wealth" shape="CHART"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<node id="102" date="1510899093938" uid="273d94e38435ad29" x="160" y="0">
											<command>
################################################################################
#
# Create population pyramids
#
################################################################################
#
# Open PNG graphics device
#
png(filename = &quot;outputFigures/charts/agePyramidSurveyArea.png&quot;,
    height = 9, width = 9, units = &quot;in&quot;, res = 100)
#
# Create 3 x 3 grid for figures
#
par(mfrow = c(3,3))
#
# Cycle through survey areas
#
for(i in unique(indicatorsDF$zone))
  {
  #
  # Subset to current zone
  #
  temp &lt;- subset(indicatorsDF, zone == i)
  #
  # Create expanded data.frames for boys
  #
  nBoys  &lt;- temp$nBoys[temp$nBoys &gt; 0]
  ageGrp &lt;- rep(&quot;4 to 15 years&quot;, length(nBoys))
  sex    &lt;- rep(&quot;Male&quot;, length(nBoys))
  nBoys  &lt;- data.frame(ageGrp, sex, nBoys)
  boys   &lt;- nBoys[rep(row.names(nBoys), nBoys$nBoys), 1:2]
  #
  # Create expanded data.frame for girls
  #
  nGirls &lt;- temp$nGirls[temp$nGirls &gt; 0]
  ageGrp &lt;- rep(&quot;4 to 15 years&quot;, length(nGirls))
  sex    &lt;- rep(&quot;Female&quot;, length(nGirls))
  nGirls &lt;- data.frame(ageGrp, sex, nGirls)
  girls  &lt;- nGirls[rep(row.names(nGirls), nGirls$nGirls), 1:2]
  #
  # Create expanded data.frame for men
  #
  nMen   &lt;- temp$nMen[temp$nMen &gt; 0]
  ageGrp &lt;- rep(&quot;16 - 60 years&quot;, length(nMen))
  sex    &lt;- rep(&quot;Male&quot;, length(nMen))
  nMen   &lt;- data.frame(ageGrp, sex, nMen)
  men    &lt;- nMen[rep(row.names(nMen), nMen$nMen), 1:2]
  #
  # Create expanded data.frame for women
  #
  nWomen &lt;- temp$nWomen[temp$nWomen &gt; 0]
  ageGrp &lt;- rep(&quot;16 - 60 years&quot;, length(nWomen))
  sex    &lt;- rep(&quot;Female&quot;, length(nWomen))
  nWomen &lt;- data.frame(ageGrp, sex, nWomen)
  women  &lt;- nWomen[rep(row.names(nWomen), nWomen$nWomen), 1:2]
  #
  # Create expanded data.frame for old men
  #
  nOldMen &lt;- temp$nOldMen[temp$nOldMen &gt; 0]
  ageGrp  &lt;- rep(&quot;60 years and above&quot;, length(nOldMen))
  sex     &lt;- rep(&quot;Male&quot;, length(nOldMen))
  nOldMen &lt;- data.frame(ageGrp, sex, nOldMen)
  oldMen  &lt;- nOldMen[rep(row.names(nOldMen), nOldMen$nOldMen), 1:2]
  #
  # Create expanded data.frame for old women
  #
  nOldWomen &lt;- temp$nOldWomen[temp$nOldWomen &gt; 0]
  ageGrp    &lt;- rep(&quot;60 years and above&quot;, length(nOldWomen))
  sex       &lt;- rep(&quot;Female&quot;, length(nOldWomen))
  nOldWomen &lt;- data.frame(ageGrp, sex, nOldWomen)
  oldWomen  &lt;- nOldWomen[rep(row.names(nOldWomen), nOldWomen$nOldWomen), 1:2]
  #
  # Concatenate ageGrp data.frames
  #
  assign(paste(&quot;ageDF&quot;, i, sep = &quot;&quot;), data.frame(rbind(boys, girls, men, women, oldMen, oldWomen)))
  #
  # Create pyramid plot for current zone
  #
  pyramid.plot(x = get(paste(&quot;ageDF&quot;, i, sep = &quot;&quot;))$ageGrp,
               g = get(paste(&quot;ageDF&quot;, i, sep = &quot;&quot;))$sex,
               main = paste(&quot;Survey Area&quot;, i, sep = &quot; &quot;),
               xlab = &quot;Male     /     Female&quot;,
               ylab = &quot;Age Groups&quot;)
  }
#
# Close graphics device
#
dev.off()
#
# Concatenate survey area age data.frames
#
ageDF &lt;- data.frame(rbind(ageDF1, ageDF2, ageDF3, ageDF4, ageDF5, ageDF6, ageDF7, ageDF8, ageDF9))
#
# Open PNG graphics device
#
png(filename = &quot;outputFigures/charts/agePyramidOverall.png&quot;,
    height = 10, width = 10, units = &quot;in&quot;, res = 100)
#
# Create pyramid plot for entire survey area
#
pyramid.plot(x = ageDF$ageGrp, g = ageDF$sex,
             main = &quot;&quot;, xlab = &quot;Male     /     Female&quot;,
             ylab = &quot;Age Groups&quot;)
#
# Close graphics device
#
dev.off()

</command>
											<property title="Population Pyramid" shape="CHART"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<node id="103" date="1510899093938" uid="d2a5a962feb04689" x="500" y="110">
											<command>
################################################################################
#
# overallResults: subset surveyResultsLong to indicators for overall results
#
################################################################################
#
# List of overall indicators
#
overallList &lt;- c(&quot;overall1&quot;, &quot;overall2&quot;, &quot;overall3&quot;, &quot;overall4&quot;)
#
# Subest to overall indicators
#
overallResults &lt;- subset(surveyResultsLong, indicatorCode %in% overallList)
#
# Sort overallResults by indicatorCode
#
overallResults &lt;- overallResults[order(overallResults$indicatorCode), ]
#
# Convert indicatorCode to factor and sort accordingly to match ladder
#
overallResults$indicatorCode &lt;- with(overallResults, factor(x = indicatorCode,
                                                            levels = rev(overallList))) 
#
# Convert type to factor and sort accordingly
#
overallResults$type &lt;- with(overallResults, factor(x = type,
                                                   levels = c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Overall&quot;)))
#
# Convert surveyArea to factor and sort accordingly
#
overallResults$surveyArea &lt;- with(overallResults, factor(x = surveyArea,
                                                         levels = c(&quot;Survey Area 1&quot;,
                                                                    &quot;Survey Area 2&quot;,
                                                                    &quot;Survey Area 3&quot;,
                                                                    &quot;Survey Area 4&quot;,
                                                                    &quot;Survey Area 5&quot;,
                                                                    &quot;Survey Area 6&quot;,
                                                                    &quot;Survey Area 7&quot;,
                                                                    &quot;Survey Area 8&quot;,
                                                                    &quot;Survey Area 9&quot;)))


################################################################################
#
# Define plotting layers for ggplot - stacked bar by survey area grouped by type
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(data = overallResults, mapping = aes(x = type, 
                                                        y = estimate, 
                                                        fill = indicatorCode))
#
# Bar plot
#
barPlot &lt;- geom_bar(stat = &quot;identity&quot;, position = &quot;fill&quot;, alpha = 0.8)
#
# Bar fill
#
barFill &lt;- scale_fill_manual(name = &quot;Overall access&quot;,
                             labels = c(&quot;Adequate water and sanitation&quot;,
                                        &quot;Adequate water only&quot;,
                                        &quot;Adequate sanitation only&quot;,
                                        &quot;No access to adequate services&quot;),
                             values = rev(overallColour))
#
# Facets
#
barFacet &lt;- facet_wrap( ~ surveyArea, nrow = 3)
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Area Type&quot;, y = &quot;Proportion&quot;)
#
# x-axis tick mark labels
#
xLabels &lt;- scale_x_discrete(labels = c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Overall&quot;))


################################################################################
#
# Plot
#
################################################################################
#
# Open graphics device
#
png(filename = paste(&quot;outputFigures/charts/overallByArea&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 12, height = 4 * ceiling(length(levels(overallResults$surveyArea)) / 3), units = &quot;in&quot;,
    res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFill + barFacet + barLabels + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# Define plotting layers for ggplot - stacked bar by type grouped by surveyArea
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(data = overallResults, 
                   mapping = aes(x = surveyArea,
                                 y = estimate,
                                 fill = indicatorCode))
#
# Bar plot
#        
barPlot &lt;- geom_bar(stat = &quot;identity&quot;, position = &quot;fill&quot;, alpha = 0.8)
#
# Bar fill
#
barFill &lt;- scale_fill_manual(name = &quot;Overall access&quot;,
                             labels = c(&quot;Adequate water and sanitation&quot;,
                                        &quot;Adequate water only&quot;,
                                        &quot;Adequate sanitation only&quot;,
                                        &quot;No access to adequate services&quot;),
                             values = rev(overallColour))
#
#
#
barFacet &lt;- facet_wrap( ~ type, ncol = 3)
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Survey Area&quot;, y = &quot;Proportion&quot;)
#
# x-axis tick mark labels
#
xLabels &lt;- scale_x_discrete(labels = 1:length(levels(overallResults$surveyArea)))

################################################################################
#
# Plot
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/overallByType&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 10, height = 4, units = &quot;in&quot;, res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFill + barFacet + barLabels + xLabels + theme_wsup
#
# Close graphics device
#
dev.off()</command>
											<property title="Overall" shape="CHART"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<node id="104" date="1510899093938" uid="595e4dba42380525" x="270" y="0">
											<command>################################################################################
#
# Read processed data
#
################################################################################

indicatorsDF &lt;- read.table(&quot;data/indicatorsDataBGD.csv&quot;, header = TRUE, sep = &quot;,&quot;)


################################################################################
#
# Create graphics for all indicators
#
################################################################################
#
# Read steering file for water indicators
#
steerIndicators &lt;- read.csv(file = &quot;outputLists/steerIndicatorsV7.csv&quot;, 
                            header = TRUE, sep = &quot;,&quot;)


steerHist &lt;- subset(steerIndicators, varFunction == &quot;histogram&quot;)


################################################################################
#
# Create histograms by survey area
#
################################################################################
#
# Re-code zone variable for ggplot
#
indicatorsDF$zone &lt;- with(indicatorsDF, paste(&quot;Survey Area&quot;, zone, sep = &quot; &quot;))
#
# Re-code type variable for ggplot
#
indicatorsDF$type &lt;- with(indicatorsDF, ifelse(type == 1, &quot;Slum&quot;, &quot;Other&quot;))
indicatorsDF$type &lt;- factor(indicatorsDF$type, levels = c(&quot;Slum&quot;, &quot;Other&quot;))


################################################################################
#
# Create WSUP theme
#
################################################################################

theme_wsup &lt;- theme_bw() + 
              theme(strip.text = element_text(size = 14), 
                    strip.background = element_rect(colour = &quot;black&quot;, size = 0.5),
                    axis.title = element_text(size = 14),
                    axis.text = element_text(size = 12),
                    panel.border = element_rect(colour = &quot;gray90&quot;, fill = NA),
                    legend.key = element_rect(colour = NA, fill = NA),
                    legend.key.size = unit(25, &quot;pt&quot;),
                    legend.title = element_text(size = 14),
                    legend.text = element_text(size = 12))

  
################################################################################
#
# Create plotting layers
#
################################################################################
#
# Create ggplot mapping base
#
basePlot &lt;- ggplot(data = indicatorsDF, mapping = aes(x = nMembers))
#
# Layers
#
histPlot &lt;- geom_histogram(binwidth = 1, color = wsupColour, fill = wsupColour, alpha = 0.6)
#
#
#
allPlot &lt;- basePlot + histPlot


################################################################################
#
# nMembers: number of household members by survey area and area type
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/nMembersByArea&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 18, height = 8, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap(zone ~ type, nrow = 3) + labs(x = &quot;No. of Household Members&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()
 

################################################################################
#
# nMembers: number of household members for all of Dhaka by survey area
#
################################################################################ 
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/nMembersByAreaTotal&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 12, height = 9, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap( ~ zone, ncol = 3) + labs(x = &quot;No. of Household Members&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# nMembers: number of household members for all of Dhaka by area type
#
################################################################################ 
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/nMembersByTypeTotal&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 8, height = 3, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap( ~ type) + labs(x = &quot;No. of Household Members&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# nMembers: number of household members total
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/nMembersOverall&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 9, height = 6, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + labs(x = &quot;No. of Household Members&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphis device
#
dev.off()



################################################################################
#
# Create plotting layers
#
################################################################################
#
# Create ggplot mapping base
#
basePlot &lt;- ggplot(data = indicatorsDF, mapping = aes(x = ppi))
#
# Layers
#
histPlot &lt;- geom_histogram(binwidth = 10, color = wsupColour, fill = wsupColour, alpha = 0.6)
#
#
#
allPlot &lt;- basePlot + histPlot


################################################################################
#
# ppi: ppi by survey area and area type
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/ppiByArea&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 18, height = 8, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap(zone ~ type, nrow = 3) + labs(x = &quot;PPI Score&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()
 

################################################################################
#
# ppi: ppi for all of Dhaka by survey area
#
################################################################################ 
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/ppiByAreaTotal&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 12, height = 9, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap( ~ zone, ncol = 3) + labs(x = &quot;PPI Score&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# ppi: ppi for all of Dhaka by area type
#
################################################################################ 
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/ppiByTypeTotal&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 8, height = 3, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap( ~ type) + labs(x = &quot;PPI Score&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# ppi: ppi total
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/ppiOverall&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 9, height = 6, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + labs(x = &quot;PPI Score&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphis device
#
dev.off()



################################################################################
#
# Create plotting layers - pQuintile
#
################################################################################
#
# Create ggplot mapping base
#
basePlot &lt;- ggplot(data = indicatorsDF, mapping = aes(x = pQuintile))
#
# Layers
#
histPlot &lt;- geom_histogram(binwidth = 1, color = wsupColour, fill = wsupColour, alpha = 0.6)
#
#
#
allPlot &lt;- basePlot + histPlot


################################################################################
#
# pQuintile: pQuintile by survey area and area type
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/pQuintileByArea&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 18, height = 8, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap(zone ~ type, nrow = 3) + labs(x = &quot;Wealth Quintiles based on PPI Score&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()
 

################################################################################
#
# pQuintile: wealth quintiles for all of Dhaka by survey area
#
################################################################################ 
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/pQuintileByAreaTotal&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 12, height = 9, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap( ~ zone, ncol = 3) + labs(x = &quot;Wealth Quintiles based on PPI Score&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# pQuintile: wealth quintiles for all of Dhaka by area type
#
################################################################################ 
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/pQuintileByTypeTotal&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 8, height = 3, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap( ~ type) + labs(x = &quot;Wealth Quintiles based on PPI Score&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# pQuintile: wealth quintiles total
#
################################################################################
#
# Open PNG graphics device
#
#png(filename = paste(&quot;outputFigures/charts/pQuintileOverall&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
#    width = 9, height = 6, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
#allPlot + labs(x = &quot;Wealth Quintiles based on PPI Score&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphis device
#
#dev.off()


################################################################################
#
# Create plotting layers - acceptScore
#
################################################################################
#
# Create ggplot mapping base
#
basePlot &lt;- ggplot(data = indicatorsDF, mapping = aes(x = acceptScore))
#
# Layers
#
histPlot &lt;- geom_histogram(binwidth = 1, color = wsupColour, fill = wsupColour, alpha = 0.6)
#
#
#
allPlot &lt;- basePlot + histPlot


################################################################################
#
# acceptScore: acceptScore by survey area and area type
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/acceptScoreByArea&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 18, height = 8, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap(zone ~ type, nrow = 3) + labs(x = &quot;Household acceptable sanitation score&quot;, y = &quot;&quot;) + xlim(c(0,5)) + theme_wsup
#
# Close graphics device
#
dev.off()
 

################################################################################
#
# acceptScore: acceptable sanitation score for all of Dhaka by survey area
#
################################################################################ 
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/acceptScoreByAreaTotal&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 12, height = 9, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap( ~ zone, ncol = 3) + labs(x = &quot;Household acceptable sanitation score&quot;, y = &quot;&quot;) + xlim(c(0,5)) + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# acceptScore: acceptable sanitation score for all of Dhaka by area type
#
################################################################################ 
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/acceptScoreByTypeTotal&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 8, height = 3, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap( ~ type) + labs(x = &quot;Household acceptable sanitation score&quot;, y = &quot;&quot;) + xlim(c(0,5)) + theme_wsup
#
# Close graphics device
#
dev.off()</command>
											<property title="Histograms" shape="CHART"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<node id="105" date="1510899093938" uid="98a2f90d9fac790d" x="160" y="110">
											<command>

################################################################################
#
#  Select and read results data: Accepts CSV data files
#
################################################################################
#
# Prompt user to supply indicator data file
#
tkmessageBox(title = &quot;Load file&quot;,
	        message = &quot;Select results data file&quot;, 
	        icon = &quot;info&quot;, 
	        type = &quot;ok&quot;)
#
# Cycle through results data file selection prompts
#
repeat
  {
  #
  # Cycle through results data file selection prompts when no file is selected
  #
  repeat
    {
    #
    # Select results data file
    #
    fileName &lt;- tclvalue(tkgetOpenFile())
    #
    # Determine if a results data file has been selected
    #	
    if(!nchar(fileName)) 
      {
      #
      # Prompt user that no file has been selected
      #
      error1 &lt;- tkmessageBox(title = &quot;Error&quot;,
				         message = &quot;No file was selected! Please try again.&quot;,
				         icon = &quot;error&quot;,
				         type = &quot;retrycancel&quot;)
      }
    #
    # Break repeat once any file has been selected
    #	
    if(nchar(fileName) &gt; 0) break
    #
    # Break repeat if user cancels option to select file
    #
    if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  }
  #
  # Break repeat if user cancels option to select file
  #
  if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  #
  # Try to read results data file based on filename provided by user
  #
  surveyResults &lt;- try(expr = read.csv(file = fileName, header = TRUE, sep = &quot;,&quot;), 
		             silent = TRUE)
  #
  # Check if results data file provided is in correct format (CSV file)
  #
  if(exists(&quot;surveyResults&quot;) &amp;&amp; class(surveyResults) == &quot;try-error&quot;)
    {
    #
    # Prompt user that file format is incorrect
    #
    error2 &lt;- tkmessageBox(title = &quot;Error&quot;,
			            message = paste(&quot;Problem reading file &apos;&quot;, basename(fileName), &quot;&apos;. Please try again&quot;, sep = &quot;,&quot;),
			            icon = &quot;error&quot;,
			            type = &quot;retrycancel&quot;)
    }
  #
  # Break repeat once selected results data file is in correct format
  #
  if(exists(&quot;surveyResults&quot;) &amp;&amp; class(surveyResults) != &quot;try-error&quot;) break
  #
  # Break repeat if user cancels option to retry providing a new file
  #
  if(exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;) break
  }
#
# Determine if user cancels option to select file or cancels option to retry providing a new file
#
if((exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) | (exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;))
  {
  #
  # Prompt user that no file has been loaded
  #
  tkmessageBox(title = &quot;Warning&quot;,
 		     message = &quot;You have not loaded any data file&quot;,
		     icon = &quot;warning&quot;,
		     type = &quot;ok&quot;)
  }
#
# Determine user has successfully selected and loaded an appropriate data file
#
if(exists(&quot;surveyResults&quot;) &amp;&amp; class(surveyResults) != &quot;try-error&quot;)
  {
  #
  # Prompt use of the filename of the results data file file selected
  #
  tkmessageBox(title = &quot;Success!&quot;,
		     message = paste(&quot;You have loaded the data file named &apos;&quot;, basename(fileName), &quot;&apos;.&quot;, sep = &quot;&quot;),
		     icon = &quot;info&quot;,
		     type = &quot;ok&quot;)
  }
#
# Clean-up filename
#
rm(fileName)
#
# Clean-up error1 if present
#
if(exists(&quot;error1&quot;))
  {
  rm(error1)
  }
#
# Clean-up error2 if present
#
if(exists(&quot;error2&quot;))
  {
  rm(error2)
  }

</command>
											<property title="Read results data" shape="INOUT"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<node id="106" date="1510899093937" uid="d85a5b0938a91040" x="50" y="0">
											<command>

################################################################################
#
#  Select and read indicator data: Accepts CSV data files
#
################################################################################
#
# Prompt user to supply indicator data file
#
tkmessageBox(title = &quot;Load file&quot;,
	        message = &quot;Select indicators data file&quot;, 
	        icon = &quot;info&quot;, 
	        type = &quot;ok&quot;)
#
# Cycle through indicator data file selection prompts
#
repeat
  {
  #
  # Cycle through indicator data file selection prompts when no file is selected
  #
  repeat
    {
    #
    # Select indicator data file
    #
    fileName &lt;- tclvalue(tkgetOpenFile())
    #
    # Determine if a indicator data file has been selected
    #	
    if(!nchar(fileName)) 
      {
      #
      # Prompt user that no file has been selected
      #
      error1 &lt;- tkmessageBox(title = &quot;Error&quot;,
				         message = &quot;No file was selected! Please try again.&quot;,
				         icon = &quot;error&quot;,
				         type = &quot;retrycancel&quot;)
      }
    #
    # Break repeat once any file has been selected
    #	
    if(nchar(fileName) &gt; 0) break
    #
    # Break repeat if user cancels option to select file
    #
    if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  }
  #
  # Break repeat if user cancels option to select file
  #
  if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  #
  # Try to read indicator steering file based on filename provided by user
  #
  indicatorsDF &lt;- try(expr = read.csv(file = fileName, header = TRUE, sep = &quot;,&quot;), 
		            silent = TRUE)
  #
  # Check if indicator steering file provided is in correct format (CSV file)
  #
  if(exists(&quot;indicatorsDF&quot;) &amp;&amp; class(indicatorsDF) == &quot;try-error&quot;)
    {
    #
    # Prompt user that file format is incorrect
    #
    error2 &lt;- tkmessageBox(title = &quot;Error&quot;,
			            message = paste(&quot;Problem reading file &apos;&quot;, basename(fileName), &quot;&apos;. Please try again&quot;, sep = &quot;,&quot;),
			            icon = &quot;error&quot;,
			            type = &quot;retrycancel&quot;)
    }
  #
  # Break repeat once selected indicator data file is in correct format
  #
  if(exists(&quot;indicatorsDF&quot;) &amp;&amp; class(indicatorsDF) != &quot;try-error&quot;) break
  #
  # Break repeat if user cancels option to retry providing a new file
  #
  if(exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;) break
  }
#
# Determine if user cancels option to select file or cancels option to retry providing a new file
#
if((exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) | (exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;))
  {
  #
  # Prompt user that no file has been loaded
  #
  tkmessageBox(title = &quot;Warning&quot;,
 		     message = &quot;You have not loaded any data file&quot;,
		     icon = &quot;warning&quot;,
		     type = &quot;ok&quot;)
  }
#
# Determine user has successfully selected and loaded an appropriate data file
#
if(exists(&quot;indicatorsDF&quot;) &amp;&amp; class(indicatorsDF) != &quot;try-error&quot;)
  {
  #
  # Prompt use of the filename of the indicator steering file file selected
  #
  tkmessageBox(title = &quot;Success!&quot;,
		     message = paste(&quot;You have loaded the data file named &apos;&quot;, basename(fileName), &quot;&apos;.&quot;, sep = &quot;&quot;),
		     icon = &quot;info&quot;,
		     type = &quot;ok&quot;)
  }
#
# Clean-up filename
#
rm(fileName)
#
# Clean-up error1 if present
#
if(exists(&quot;error1&quot;))
  {
  rm(error1)
  }
#
# Clean-up error2 if present
#
if(exists(&quot;error2&quot;))
  {
  rm(error2)
  }

</command>
											<property title="Read indicator data" shape="INOUT"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<edge from="95" to="98"/>
										<edge from="98" to="103"/>
										<edge from="97" to="105"/>
										<edge from="96" to="101"/>
										<edge from="105" to="102"/>
										<edge from="102" to="104"/>
										<edge from="100" to="106"/>
										<edge from="106" to="97"/>
										<edge from="104" to="96"/>
										<edge from="103" to="99"/>
										<edge from="101" to="95"/>
									</graph>
								</subflow>
							</option>
						</node>
						<node id="107" date="1510899095244" uid="c88101eb55f54908" x="400" y="170">
							<command>################################################################################
#                                                                              #
#                                                                              #
#                            MAPPING OF RESULTS                                #
#                                                                              #
#                                                                              #
################################################################################

################################################################################
#
# Map areas surveyed 
#
################################################################################
#
# Open PNG graphics device
#
png(filename = &quot;surveyAreas.png&quot;,
    height = 10, width = 10, units = &quot;in&quot;,
    res = 100)
#
# Set plot margins
#    
par(mar = c(0,0,0,0), pty = &quot;s&quot;)
#
# Plot Dhaka level 4 map (wards)
#
plot(dhaka4,
     col = ifelse(dhaka4@data$noSurvey == 1, &quot;#fc8d62&quot;, &quot;#66c2a5&quot;))
#
# Add legend
#
legend(x = &quot;bottomleft&quot;, 
       inset = 0.02,
       y.intersp = 1.2,
       legend = c(&quot;Areas included in survey&quot;,
                  &quot;Areas not included in survey&quot;),
       pch = 22,
       pt.bg = c(&quot;#66c2a5&quot;, &quot;#fc8d62&quot;),
       pt.cex = 3)
#
# Close graphics device
#    
dev.off()



################################################################################
#
# Plot sampling points relative to their sampling grids
#
################################################################################
#
# Cycle through enumeration areas
#
for(i in unique(enumerationArea))
{
  #
  # Subset dhaka4 to current surveyArea
  #
  surveyArea &lt;- subset(dhaka4, dhaka4@data$surveyArea == i)
  #
  # Read sampling grid data for current enumeration area
  #
  gridArea &lt;- readOGR(dsn = paste(&quot;samplingGrids/surveyArea&quot;, i, sep = &quot;&quot;),
                      layer = paste(&quot;surveyArea&quot;, i, sep = &quot;&quot;),
                      verbose = FALSE)
  #
  # Transform coordinate reference system of gridArea
  #
  gridArea &lt;- spTransform(x = gridArea, CRSobj = CRS(proj4string(surveyArea)))
  #
  # Open PNG graphics device
  #
  png(filename = paste(&quot;outputFigures/maps/surveyAreaGridUpdate&quot;, i, &quot;.png&quot;, sep = &quot;&quot;),
      height = 10, width = 10, units = &quot;in&quot;, res = 600)
  #
  # Set plotting margins
  #
  par(mar = c(0,0,0,0), pty = &quot;s&quot;)  
  #
  # Plot dummy map to set bounding box
  #
  plot(surveyArea, lty = 0)
  #
  # Plot Dhaka level 4 map (wards)
  #
  plot(dhaka4, lwd = 2, add = TRUE)
  #
  # Plot surveyed areas
  #
  plot(surveyArea, 
       col = ifelse(surveyArea@data$UpzCode %in% c(302695, 302606, 302608, 302626, 302654) | 
                   (surveyArea@data$UpzCode == 302616 &amp; surveyArea@data$Union %in% c(&quot;Ward No-49&quot;, &quot;Ward No-48 (Part)&quot;)), &quot;gray90&quot;, NA),
       border = &quot;yellow&quot;, 
       lwd = 3, 
       add = TRUE)  
  #
  # Plot sampling grids
  #
  plot(gridArea,
       lwd = 1,
       border = &quot;darkgreen&quot;,
       add = TRUE)
  #
  # Plot sampling points
  #
  plot(surveySP[surveySP@data$zone == i, ], 
       pch = 19, 
       cex = 0.5, 
       col = ifelse(surveySP@data$type[surveySP@data$zone == i] == 1, &quot;blue&quot;, &quot;red&quot;), 
       add = TRUE)
  #
  # Add annotations
  #
  text(surveySP[surveySP@data$zone == i, ], 
       labels = &quot;psu&quot;,
       pos = 3,
       offset = 0.3,
       cex = 0.3)
  #
  # Add legend
  #
  legend(x = &quot;topright&quot;, 
         inset = 0.02,
         y.intersp = 1.2,
         legend = c(&quot;Sampling Grid&quot;,
                    &quot;Enumeration Area&quot;,
                    &quot;Not surveyed&quot;,
                    &quot;Slum PSU&quot;,
                    &quot;Non-slum PSU&quot;),
         pch = c(22, 22, 22, 20, 20),
         pt.bg = c(NA, NA, &quot;gray90&quot;, NA, NA),
         pt.lwd = c(2, 2, 2, NA, NA),
         col = c(&quot;darkgreen&quot;, &quot;yellow&quot;, &quot;yellow&quot;, &quot;blue&quot;, &quot;red&quot;),
         pt.cex = 3)
  #
  # Close graphics device
  #
  dev.off()
}



################################################################################
#
# Results mapping for proprtion indicators
#
################################################################################
#
# Read survey area map
#
surveyArea &lt;- readOGR(dsn = &quot;outputGrids/surveyArea&quot;,
                      layer = &quot;surveyArea&quot;,
                      verbose = FALSE)
#
# Read outline of surveyArea
#
outline &lt;- readOGR(dsn = &quot;outputGrids/surveyArea3&quot;,
                   layer = &quot;surveyArea3&quot;,
                   verbose = FALSE)                        
#
# Create steering vector for slum, other, and total results
#
steerMap &lt;- c(&quot;slumEst&quot;, &quot;otherEst&quot;, &quot;totalEst&quot;)
#
# Subset surveyResults to proportions
#
propResults &lt;- subset(surveyResults, indicatorCode %in% steerIndicators$varList[steerIndicators$varFunction == &quot;proportion&quot;])
#
# Cycle through indicators
#
for(i in propResults$indicatorCode)
  {
  #
  # Subset survey results to current indicator
  #
  tempResults &lt;- subset(propResults, indicatorCode == i)
  #
  # Merge survey area map with current indicator results
  #
  tempMap &lt;- merge(surveyArea, tempResults)
  #
  # Open PNG graphics device - 1 x 3 layout
  #
  png(filename = paste(&quot;outputFigures/maps/&quot;, i, &quot;.png&quot;, sep = &quot;&quot;),
      width = 15, height = 5, units = &quot;in&quot;, res = 100)
  #
  # Set plotting margins
  #
  par(mar = c(0,0,0,0), mfrow = c(1,3))
  #
  # Cycle through slum, other and total results
  #
  for(j in steerMap)
    {
    #
    # Plot current area type map
    #
    plot(surveyArea,
         col = ifelse(tempMap@data$UpzCode %in% c(302695, 302606, 302608, 302626, 302654) | (tempMap@data$UpzCode == 302616 &amp; tempMap@data$Union %in% c(&quot;Ward No-49&quot;, &quot;Ward No-48 (Part)&quot;)), &quot;gray90&quot;,
                 ifelse(tempMap[[j]] &lt;= 0.2, aRdYlGn5[1],
                   ifelse(tempMap[[j]] &lt;= 0.4 &amp; tempMap[[j]] &gt; 0.2, aRdYlGn5[2],
                     ifelse(tempMap[[j]] &lt;= 0.6 &amp; tempMap[[j]] &gt; 0.4, aRdYlGn5[3],
                       ifelse(tempMap[[j]] &lt;= 0.8 &amp; tempMap[[j]] &gt; 0.6, aRdYlGn5[4], aRdYlGn5[5]))))),
         border = ifelse(tempMap@data$UpzCode %in% c(302695, 302606, 302608, 302626, 302654) | (tempMap@data$UpzCode == 302616 &amp; tempMap@data$Union %in% c(&quot;Ward No-49&quot;, &quot;Ward No-48 (Part)&quot;)), &quot;gray90&quot;,
                    ifelse(tempMap[[j]] &lt;= 0.2, RdYlGn5[1],
                      ifelse(tempMap[[j]] &lt;= 0.4 &amp; tempMap[[j]] &gt; 0.2, RdYlGn5[2],
                        ifelse(tempMap[[j]] &lt;= 0.6 &amp; tempMap[[j]] &gt; 0.4, RdYlGn5[3],
                          ifelse(tempMap[[j]] &lt;= 0.8 &amp; tempMap[[j]] &gt; 0.6, RdYlGn5[4], RdYlGn5[5]))))),
         lwd = 1)
    #
    # Plot survey area outline (survey area 1 to 9)
    #
    plot(outline, border = &quot;gray50&quot;, lwd = 2, add = TRUE)
    #
    # Add title on top of map identifying slum, other or overall
    #
    title(main = ifelse(j == &quot;slumEst&quot;, &quot;Slum&quot;,
                   ifelse(j == &quot;otherEst&quot;, &quot;Other&quot;, &quot;Overall&quot;)), 
          line = -1)
    #
    # Add inset on rightmost map to show different survey area labels 
    #  
    if(j == &quot;totalEst&quot;)
      {
      #
      # Add inset 
      #
      par(plt = c(0.74, 0.99, 0.74, 0.99), new = TRUE)
      plot(outline, lwd = 1, col = &quot;gray90&quot;, border = &quot;gray50&quot;)
      title(main = &quot;Survey Areas &quot;, line = -1, adj = 1, cex.main = 1)
      text(x = outline, 
           labels = ifelse(outline@data$surveyArea == &quot;Survey Area 1&quot;, 1,
                      ifelse(outline@data$surveyArea == &quot;Survey Area 2&quot;, 2,
                        ifelse(outline@data$surveyArea == &quot;Survey Area 3&quot;, 3,
                          ifelse(outline@data$surveyArea == &quot;Survey Area 4&quot;, 4,
                            ifelse(outline@data$surveyArea == &quot;Survey Area 5&quot;, 5,
                              ifelse(outline@data$surveyArea == &quot;Survey Area 6&quot;, 6,
                                ifelse(outline@data$surveyArea == &quot;Survey Area 7&quot;, 7,
                                  ifelse(outline@data$surveyArea == &quot;Survey Area 8&quot;, 8, 9)))))))), 
           cex = ifelse(outline@data$surveyArea %in% c(&quot;Survey Area 5&quot;, &quot;Survey Area 8&quot;), 0.85, 1), 
           col = &quot;blue&quot;)
      box(which = &quot;plot&quot;, lty = &quot;solid&quot;, lwd = 1)
      }
    #
    # Add legend on leftmost map
    #
    if(j == &quot;slumEst&quot;)
      {
      #
      # Add legend
      #
      legend(x = &quot;bottomleft&quot;, inset = 0.01, y.intersp = 1.2,
             legend = c(&quot;Not surveyed&quot;,
                        &quot;20% or less&quot;,
                        &quot;21% to 40%&quot;,
                        &quot;41% to 60%&quot;,
                        &quot;61% to 80%&quot;,
                        &quot;81% to 100%&quot;),
             pch = 22, pt.cex = 2, 
             col = c(&quot;gray90&quot;, RdYlGn5),
             pt.bg = c(&quot;gray90&quot;, aRdYlGn5),
             cex = 1)
      }
    }
  #
  # Close graphics device
  #
  dev.off()
  }


################################################################################
#
# Results mapping for mean indicators
#
################################################################################
#
# Subset surveyResults to mean results
#
meanResults &lt;- subset(surveyResults, indicatorCode %in% steerIndicators$varList[steerIndicators$varFunction == &quot;histogram&quot;])
#
# Cycle through indicators
#
for(i in meanResults$indicatorCode)
  {
  #
  # Subset survey results to current indicator
  #
  tempResults &lt;- subset(meanResults, indicatorCode == i)
  #
  # Merge survey area map to current indicator results
  #
  tempMap &lt;- merge(surveyArea, tempResults)
  #
  # Open PNG graphics device - 1 x 3 layout
  #
  png(filename = paste(&quot;outputFigures/maps/&quot;, i, &quot;.png&quot;, sep = &quot;&quot;),
      width = 15, height = 5, units = &quot;in&quot;, res = 100)
  #
  # Set plotting margins
  #
  par(mar = c(0,0,0,0), mfrow = c(1,3))
  #
  # Cycle through slum, other, total results
  #
  for(j in steerMap)
    {
    #
    # Scale reuslts for current indicator using quantile function
    #
    tempScale &lt;- scaleValue(tempResults[[j]], n = 5, style = &quot;quantile&quot;)
    #
    # Get corresponding legend labels based on scaling of results
    #
    tempScaleLabel &lt;- classIntervals(tempResults[[j]], n = 5, style = &quot;quantile&quot;)    
    #
    # Plot current indicator map
    #
    plot(surveyArea,
         col = ifelse(tempMap@data$UpzCode %in% c(302695, 302606, 302608, 302626, 302654) | (tempMap@data$UpzCode == 302616 &amp; tempMap@data$Union %in% c(&quot;Ward No-49&quot;, &quot;Ward No-48 (Part)&quot;)), &quot;gray90&quot;, 
                 ifelse(tempMap@data$surveyArea == &quot;Survey Area 1&quot;, aYlBl5[tempScale[1]],
                   ifelse(tempMap@data$surveyArea == &quot;Survey Area 2&quot;, aYlBl5[tempScale[2]],
                     ifelse(tempMap@data$surveyArea == &quot;Survey Area 3&quot;, aYlBl5[tempScale[3]],
                       ifelse(tempMap@data$surveyArea == &quot;Survey Area 4&quot;, aYlBl5[tempScale[4]],
                         ifelse(tempMap@data$surveyArea == &quot;Survey Area 5&quot;, aYlBl5[tempScale[5]],
                           ifelse(tempMap@data$surveyArea == &quot;Survey Area 6&quot;, aYlBl5[tempScale[6]],
                             ifelse(tempMap@data$surveyArea == &quot;Survey Area 7&quot;, aYlBl5[tempScale[7]],
                               ifelse(tempMap@data$surveyArea == &quot;Survey Area 8&quot;, aYlBl5[tempScale[8]], aYlBl5[tempScale[9]]))))))))),
         border = ifelse(tempMap@data$UpzCode %in% c(302695, 302606, 302608, 302626, 302654) | (tempMap@data$UpzCode == 302616 &amp; tempMap@data$Union %in% c(&quot;Ward No-49&quot;, &quot;Ward No-48 (Part)&quot;)), &quot;gray90&quot;, 
                    ifelse(tempMap@data$surveyArea == &quot;Survey Area 1&quot;, YlBl5[tempScale[1]],
                      ifelse(tempMap@data$surveyArea == &quot;Survey Area 2&quot;, YlBl5[tempScale[2]],
                        ifelse(tempMap@data$surveyArea == &quot;Survey Area 3&quot;, YlBl5[tempScale[3]],
                          ifelse(tempMap@data$surveyArea == &quot;Survey Area 4&quot;, YlBl5[tempScale[4]],
                            ifelse(tempMap@data$surveyArea == &quot;Survey Area 5&quot;, YlBl5[tempScale[5]],
                              ifelse(tempMap@data$surveyArea == &quot;Survey Area 6&quot;, YlBl5[tempScale[6]],
                                ifelse(tempMap@data$surveyArea == &quot;Survey Area 7&quot;, YlBl5[tempScale[7]],
                                  ifelse(tempMap@data$surveyArea == &quot;Survey Area 8&quot;, YlBl5[tempScale[8]], YlBl5[tempScale[9]]))))))))),
         lwd = 1)
    #
    # Plot survey area outline (survey area 1 to 9)
    #
    plot(outline, border = &quot;gray50&quot;, lwd = 2, add = TRUE)
    #
    # Add title on top of map identifying slum, other or overall
    #
    title(main = ifelse(j == &quot;slumEst&quot;, &quot;Slum&quot;,
                   ifelse(j == &quot;otherEst&quot;, &quot;Other&quot;, &quot;Overall&quot;)), 
          line = -1)
    #
    # Add legend
    #
   legend(x = &quot;bottomleft&quot;, inset = 0.01, y.intersp = 1.2,
          legend = c(&quot;Not surveyed&quot;, names(print(tempScaleLabel, 
                                                 cutlabels = FALSE))),
          pch = 22, pt.cex = 2, 
          col = c(&quot;gray90&quot;, YlBl5),
          pt.bg = c(&quot;gray90&quot;, aYlBl5),
          cex = 1)
    #
    # Add inset on rightmost map to show different survey area labels
    #  
    if(j == &quot;totalEst&quot;)
      {
      #
      # Add inset
      #
      par(plt = c(0.74, 0.99, 0.74, 0.99), new = TRUE)
      plot(outline, lwd = 1, col = &quot;gray90&quot;, border = &quot;gray50&quot;)
      title(main = &quot;Survey Areas&quot;, line = -1, adj = 1, cex = 0.85)
      text(x = outline, 
           labels = ifelse(outline@data$surveyArea == &quot;Survey Area 1&quot;, 1,
                      ifelse(outline@data$surveyArea == &quot;Survey Area 2&quot;, 2,
                        ifelse(outline@data$surveyArea == &quot;Survey Area 3&quot;, 3,
                          ifelse(outline@data$surveyArea == &quot;Survey Area 4&quot;, 4,
                            ifelse(outline@data$surveyArea == &quot;Survey Area 5&quot;, 5,
                              ifelse(outline@data$surveyArea == &quot;Survey Area 6&quot;, 6,
                                ifelse(outline@data$surveyArea == &quot;Survey Area 7&quot;, 7,
                                  ifelse(outline@data$surveyArea == &quot;Survey Area 8&quot;, 8, 9)))))))), 
           cex = ifelse(outline@data$surveyArea %in% c(&quot;Survey Area 5&quot;, &quot;Survey Area 8&quot;), 0.85, 1), 
           col = &quot;blue&quot;)
      box(which = &quot;plot&quot;, lty = &quot;solid&quot;, lwd = 1)
      }
    }
  #
  # Close graphics device
  #
  dev.off()
  }        
                   
</command>
							<property title="Maps" shape="CHART"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="108" date="1510899093935" uid="85f46e2d63e64c8b" x="250" y="170">
							<command>################################################################################
#                                                                              #
#                                                                              #
#            CLASSIFICATION AND ESTIMATION OF WATER INDICATORS                 #
#                                                                              #
#                                                                              #
################################################################################

################################################################################
#
# Create steering file for indicators reporting - water
#
################################################################################
#
# Create variable code list
#
varList &lt;- c(&quot;jmpWater1&quot;, &quot;jmpWater2&quot;, &quot;jmpWater3&quot;, &quot;wLevel1&quot;, &quot;wLevel2&quot;, &quot;wLevel3&quot;, 
             &quot;wLevel4&quot;, &quot;waterSource&quot;, &quot;water11b&quot;, &quot;water11d&quot;, &quot;water2a&quot;, &quot;water3a&quot;, 
             &quot;water4&quot;, &quot;water4b&quot;, &quot;water5b&quot;, &quot;water6a&quot;, &quot;water7&quot;, &quot;water7a&quot;, &quot;water7c&quot;, 
             &quot;water8&quot;, &quot;water10&quot;, &quot;water10b&quot;, &quot;water12&quot;, &quot;water12b&quot;, &quot;water13a&quot;, 
             &quot;water14a&quot;, &quot;water16a&quot;, &quot;water17&quot;, &quot;water18&quot;)
#
# Create variable functions list
#
varFunction &lt;- c(&quot;proportion&quot;, &quot;proportion&quot;, &quot;proportion&quot;, &quot;proportion&quot;, &quot;proportion&quot;, 
                 &quot;proportion&quot;, &quot;proportion&quot;, &quot;pareto&quot;, &quot;pareto&quot;, &quot;proportion&quot;, 
                 &quot;proportion&quot;, &quot;proportion&quot;, &quot;histogram&quot;, &quot;proportion&quot;, &quot;proportion&quot;, 
                 &quot;proportion&quot;, &quot;histogram&quot;, &quot;proportion&quot;, &quot;proportion&quot;, &quot;proportion&quot;, 
                 &quot;pareto&quot;, &quot;proportion&quot;, &quot;histogram&quot;, &quot;proportion&quot;, &quot;proportion&quot;, 
                 &quot;proportion&quot;, &quot;proportion&quot;, &quot;pareto&quot;, &quot;proportion&quot;)
#
# Create variable statistics list
#
varStatistic &lt;- c(&quot;oneMean&quot;, &quot;oneMean&quot;, &quot;oneMean&quot;, &quot;oneMean&quot;, &quot;oneMean&quot;, &quot;oneMean&quot;, 
                  &quot;oneMean&quot;, &quot;barplot&quot;, &quot;barplot&quot;, &quot;oneMean&quot;, &quot;oneMean&quot;, &quot;oneMean&quot;, 
                  &quot;oneMean&quot;, &quot;oneMean&quot;, &quot;oneMean&quot;, &quot;oneMean&quot;, &quot;oneMean&quot;, &quot;oneMean&quot;, 
                  &quot;oneMean&quot;, &quot;oneMean&quot;, &quot;barplot&quot;, &quot;oneMean&quot;, &quot;oneMean&quot;, &quot;oneMean&quot;, 
                  &quot;oneMean&quot;, &quot;oneMean&quot;, &quot;oneMean&quot;, &quot;barplot&quot;, &quot;oneMean&quot;)
#
# Create variable names list
#
varNames &lt;- c(&quot;Households using surface water as source of drinking water&quot;, 
              &quot;Households using unimproved source of drinking water&quot;, 
              &quot;Households using basic source of drinking water&quot;, 
              &quot;Any source of drinking water other than surface water&quot;, 
              &quot;Acceptable source of drinking water&quot;, 
              &quot;Basic source of drinking water (accessiblity coverage)&quot;, 
              &quot;Basic source of drinking water that is always available (contact coverage)&quot;, 
              &quot;Main sources of drinking water&quot;, 
              &quot;Secondary sources of drinking water&quot;, 
              &quot;Main and secondary sources of drinking water are basic&quot;, 
              &quot;Households with formal source of drinking water&quot;, 
              &quot;Households with WSUP-supported water facility&quot;, 
              &quot;Mean number of hours per day water is available&quot;, 
              &quot;Households with access to water for a whole day&quot;, 
              &quot;Households with access to water for a whole week&quot;, 
              &quot;Households with access to water for a whole year&quot;, 
              &quot;Mean number of minutes to collect water&quot;, 
              &quot;Water collection time (including queuing) is 30 minutes or less&quot;, 
              &quot;Satisfied with duration of water collection time&quot;, 
              &quot;Satisfied with duration of queuing time when collecting water&quot;, 
              &quot;Amount of water (in litres) used by household per day&quot;, 
              &quot;Households that consider amount of water used per day as sufficient&quot;, 
              &quot;Mean spend (BGD Taka) on water&quot;, 
              &quot;Households satisfied with their spending on water&quot;, 
              &quot;Households willing to invest in improving water source&quot;, 
              &quot;Households satisfied with water quality&quot;, 
              &quot;Households satisfied with water pressure&quot;, 
              &quot;Individuals/organisations contacted by household for support on water-related issues&quot;,
              &quot;Households with clean water storage&quot;)
#
# Create variable set list
#
varSet &lt;- c(rep(&quot;waterSet1&quot;, 12), rep(&quot;waterSet2&quot;, 12), rep(&quot;waterSet3&quot;, 5))
#
# Create variable set titles list
#
varTitle &lt;- c(&quot;Types of Water Sources&quot;,
              &quot;Types of Water Sources&quot;,
              &quot;Types of Water Sources&quot;,
              &quot;Types of Water Sources&quot;,
              &quot;Types of Water Sources&quot;,
              &quot;Types of Water Sources&quot;,
              &quot;Types of Water Sources&quot;,
              &quot;Types of Water Sources&quot;,
              &quot;Types of Water Sources&quot;,
              &quot;Types of Water Sources&quot;,
              &quot;Types of Water Sources&quot;,
              &quot;Types of Water Sources&quot;,
              &quot;Access to Water Sources&quot;,
              &quot;Access to Water Sources&quot;,
              &quot;Access to Water Sources&quot;,
              &quot;Access to Water Sources&quot;,
              &quot;Access to Water Sources&quot;,
              &quot;Access to Water Sources&quot;,
              &quot;Access to Water Sources&quot;, 
              &quot;Access to Water Sources&quot;,
              &quot;Access to Water Sources&quot;,
              &quot;Access to Water Sources&quot;,
              &quot;Access to Water Sources&quot;,
              &quot;Access to Water Sources&quot;,
              &quot;Other Water Indicators&quot;,
              &quot;Other Water Indicators&quot;,
              &quot;Other Water Indicators&quot;,
              &quot;Other Water Indicators&quot;,
              &quot;Other Water Indicators&quot;)
#
# Create variable file names list
#
varFile &lt;- c(rep(&quot;types-water-sources&quot;, 12), 
             rep(&quot;access-water-sources&quot;, 12), 
             rep(&quot;other-water-indicators&quot;, 5))
#
# Concatenate steering fectors into data.frame
#
steerIndicators &lt;- data.frame(varList, varFunction, varStatistic, varNames, 
                              varSet, varTitle, varFile)
#
# Save steerIndicators for water indicators
#
write.table(x = steerIndicators,
            file = &quot;outputLists/steerIndicatorsWater.csv&quot;,
            quote = FALSE,
            sep = &quot;,&quot;,
            row.names = FALSE)
#
# Clean-up
#
rm(varList, varFunction, varStatistic, varNames, varSet, varTitle, varFile)


################################################################################
#
# Perform LQAS - water indicators
#
################################################################################
#
# Set cut-offs
#
lowerClass &lt;- 0.5
upperClass &lt;- 0.8


################################################################################
#
# Results by indicator single output - LQAS - Water
#
################################################################################
#
# Create empty aggregator object for LQAS results
#
resultAll &lt;- NULL
#
# Cycle through indicators
#
for(i in steerIndicators$varList)
  {
  #
  # Create empty matrix to aggregate interim output
  #
  resultDF &lt;- matrix(ncol = 9, nrow = max(unique(indicatorsDF$zone)))
  #
  # Check type of function required for current indicator is a proportion
  #
  if(steerIndicators$varFunction[steerIndicators$varList == i] == &quot;proportion&quot;)
    {
    #
    # Cycle through survey zones
    #
    for(j in unique(indicatorsDF$zone))
      {
      #
      # Cycle through area types i.e. slum and other
      #
      for(k in unique(indicatorsDF$type))
        {
        #
        # Subset indicator data to current zone and current area type
        #
        temp &lt;- indicatorsDF[indicatorsDF$zone == j &amp; indicatorsDF$type == k, i]
        #
        # Count total sample size for current area type
        #
        total &lt;- length(!is.na(temp))
        #
        # Calculate lower target
        #
        class1 &lt;- floor(total * lowerClass)
        #
        # Calculate upper target
        #
        class2 &lt;- floor(total * upperClass)
        #
        # Count total number of cases i.e. those for which indicator is TRUE
        #
        cases &lt;- sum(temp, na.rm = TRUE)
        #
        # Classify
        #
        class &lt;- ifelse(cases &lt;= class1, &quot;Low&quot;,
                   ifelse(cases &gt; class2, &quot;High&quot;, &quot;Moderate&quot;))
        #      
        # Determine if area is slum or other
        #     
        typeCol &lt;- rep(k, 3)
        #
        # Add interim results to empty matrix
        #
        resultDF[j, ifelse(typeCol == 1, 4:6, 7:9)] &lt;- c(total, cases, class)
        }
      }
    }
  #
  # If current indicator does not require proportion function
  #  
  else
    {
    #
    # Cylce through zones
    #
    for(j in unique(indicatorsDF$zone))
      {
      #
      # Cycle through area types i.e. slum or other
      #
      for(k in unique(indicatorsDF$type))
        {
        #
        # Subset indicator data to current zone and current area type
        #
        temp &lt;- indicatorsDF[indicatorsDF$zone == j &amp; indicatorsDF$type == k, i]
        #
        # Count total sample size for current area type
        #
        total &lt;- length(!is.na(temp))
        #
        # Set cases to 0 as indicator is not a proportion
        #
        cases &lt;- 0
        #
        # No classification as current indicator is not a proportion
        #
        class &lt;- NA
        #      
        # Determine if area is slum or other
        #     
        typeCol &lt;- rep(k, 3)
        #
        # Add interim results to empty matrix
        #
        resultDF[j, ifelse(typeCol == 1, 4:6, 7:9)] &lt;- c(total, cases, class)
        }
      }
    }
  #
  # Add identifying data to interim results matrix
  #  
  resultDF[,1] &lt;- steerIndicators$varNames[steerIndicators$varList == i]
  resultDF[,2] &lt;- i
  resultDF[,3] &lt;- paste(&quot;Survey Area&quot;, 1:j, sep = &quot; &quot;)
  #
  # Convert interim results matrix to data.frame
  #
  resultDF &lt;- data.frame(resultDF)
  #
  # Name variables in interim results data.frame
  #
  names(resultDF) &lt;- c(&quot;Indicator Name&quot;, &quot;Indicator Code&quot;, &quot;Survey Area&quot;, 
                       &quot;Slum Total Respondents&quot;, &quot;Slum Cases&quot;, &quot;Slum Classification&quot;, 
                       &quot;Other Total Respondents&quot;, &quot;Other Cases&quot;, &quot;Other Classification&quot;)
  #
  # Concatenate interim results data.frame with resulst aggregator
  #
  resultAll &lt;- rbind(resultAll, resultDF)
  }
#
# Save results aggregator as CSV
#
write.table(x = resultAll,
		    file = &quot;outputTables/surveyResultsWaterLQAS.csv&quot;,
		    quote = FALSE,
		    sep = &quot;,&quot;,
		    row.names = FALSE)


################################################################################
#
# Perform bootstrap - water indicators
#
################################################################################
#
# Subset steerIndicators to those that can be bootstrapped
#
steerBoot &lt;- subset(steerIndicators, varStatistic == &quot;oneMean&quot;)
#
# Specify number of bootstrap replicates
#
REPLICATES &lt;- 399


################################################################################
#
# All results in a single output - Bootstrap - water
#
################################################################################
#
# Create empty container object for bootstrap results
#
summaryTable &lt;- NULL
#
# Cycle through each enumeration zones
#
for(i in unique(indicatorsDF$zone))
  {
  #
  # Subset population data to slum areas
  #
  slum.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 1, ]
  #
  # Subset population data to other areas
  #
  other.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 2, ]
  #
  # Subset survey data to slum areas
  #
  slum.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 1, ]
  #
  # Subset survey data to other areas
  #
  other.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 2, ]  
  #
  # Get population data for all areas in current zone
  #
  all.pop &lt;- popDF[popDF$zone == i, ]
  #
  # Get survey data for all areas in current zone
  #
  all.data &lt;- indicatorsDF[indicatorsDF$zone == i, ]
  #
  # Cycle through indicator codes
  #
  for(j in steerBoot$varList)
    {
    #
    # Select indicator and statistic pair
    #
    INDICATOR &lt;- j
    STATISTIC &lt;- steerBoot$varStatistic[steerBoot$varList == j]
    #
    # Report progress
    #
    cat(&quot;\n\n&quot;, INDICATOR, &quot; : Survey Area &quot;, i, &quot;\n\n&quot;, sep = &quot;&quot;)
    #
    # Boostrap (BBW) for current indicator and statistic pair - slum
    #
    boot.slum &lt;- bootBW(x = slum.data, 
                        w = slum.pop, 
                        statistic = eval(parse(text = STATISTIC)), 
                        params = INDICATOR, 
                        outputColumns = INDICATOR, 
                        replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - other
    #
    boot.other &lt;- bootBW(x = other.data, 
                         w = other.pop, 
                         statistic = eval(parse(text = STATISTIC)), 
                         params = INDICATOR, 
                         outputColumns = INDICATOR, 
                         replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - total
    #
    boot.total &lt;- bootBW(x = all.data, 
                         w = all.pop, 
                         statistic = eval(parse(text = STATISTIC)), 
                         params = INDICATOR, 
                         outputColumns = INDICATOR, 
                         replicates = REPLICATES)     
    #
    # Concatenate various boot vectors into data.frame
    #
    boot.all &lt;- data.frame(boot.slum, boot.other, boot.total)
    names(boot.all) &lt;- c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Total&quot;)
    #
    # Create a row of results and insert quantiles of boot results
    #
    rowResult &lt;- c(steerBoot$varNames[steerBoot$varList == j], j, paste(&quot;Survey Area &quot;, i, sep = &quot;&quot;))
    for(k in names(boot.all))
      {
      rowResult &lt;- c(rowResult, quantile(boot.all[[k]], probs = c(0.5, 0.025, 0.975), na.rm = TRUE))
      }
    #
    # Record results
    #
    summaryTable &lt;- rbind(summaryTable, rowResult)
    }
  #
  # Tidy results (row names, column types, column names, and order of rows)
  #
  summaryTable &lt;- data.frame(summaryTable, row.names = 1:nrow(summaryTable))
  #
  # Convert estimate results into numeric
  #
  for(col in 4:ncol(summaryTable))
    {
    summaryTable[, col] &lt;- as.numeric(summaryTable[, col])
    }
  }
#
# Rename summaryTable
#
names(summaryTable) &lt;- c(&quot;Indicator&quot;, &quot;Indicator Code&quot;, &quot;Survey Area&quot;, 
                         &quot;Slum Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
                         &quot;Other Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
                         &quot;Total Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;)
#
# Round-off estimates to the nearest 4 decimal places
#
summaryTable[ , 4:ncol(summaryTable)] &lt;- round(summaryTable[  , 4:ncol(summaryTable)], 4)
#
# Keep the rounding off of results for table output
#
options(scipen = 10)
#
# Save summaryTable as CSV file
#
write.table(x = summaryTable, 
            file = &quot;outputTables/surveyResultsWaterBoot.csv&quot;, 
            quote = FALSE, 
            sep = &quot;,&quot;, 
            row.names = FALSE)
#
# Reset scipen back to 0
#
options(scipen = 0)





################################################################################
#                                                                              #
#                                                                              #
#                     ESTIMATION OF SANITATION INDICATORS                      #
#                                                                              #
#                                                                              #
################################################################################

################################################################################
#
# Create steering file for indicators reporting - sanitation
#
################################################################################
#
# Create variable code list
#
varList &lt;- c(&quot;jmpSan1&quot;, &quot;jmpSan2&quot;, &quot;jmpSan3&quot;, &quot;jmpSan4&quot;,
             &quot;san2&quot;, &quot;san5&quot;, &quot;san6&quot;, &quot;san7&quot;, &quot;san9&quot;, &quot;san10&quot;, &quot;san11&quot;, &quot;san12&quot;,
             &quot;san13&quot;, &quot;san14&quot;, &quot;san15&quot;, &quot;san16&quot;, &quot;san17&quot;, &quot;san18&quot;, &quot;san19&quot;,
             &quot;san21&quot;, &quot;san25&quot;, &quot;san26&quot;, &quot;san27&quot;, &quot;san28&quot;, &quot;san29&quot;, &quot;san30&quot;,
             &quot;san32&quot;, &quot;san33&quot;,  &quot;san34&quot;, &quot;san35&quot;, &quot;san36&quot;, &quot;san37&quot;)
#
# Create variable functions list
#             
varFunction &lt;- c(&quot;proportion&quot;, &quot;proportion&quot;, &quot;proportion&quot;, &quot;proportion&quot;,
                 &quot;histogram&quot;, &quot;proportion&quot;, &quot;proportion&quot;, &quot;proportion&quot;,
                 &quot;proportion&quot;, &quot;proportion&quot;, &quot;proportion&quot;, &quot;proportion&quot;,
                 &quot;histogram&quot;, &quot;histogram&quot;, &quot;proportion&quot;, &quot;proportion&quot;,
                 &quot;histogram&quot;, &quot;proportion&quot;, &quot;proportion&quot;, &quot;proportion&quot;,
                 &quot;pareto&quot;, &quot;proportion&quot;, &quot;proportion&quot;, &quot;pareto&quot;,
                 &quot;pareto&quot;, &quot;pareto&quot;, &quot;proportion&quot;, &quot;pareto&quot;,
                 &quot;histogram&quot;, &quot;pareto&quot;, &quot;pareto&quot;, &quot;proportion&quot;)
#
# Create variable statistic list
#
varStatistic &lt;- ifelse(varFunction == &quot;pareto&quot;, &quot;barplot&quot;, &quot;oneMean&quot;)
#
# Create variable names list
#                        
varNames &lt;- c(&quot;Households using open defecation&quot;,
              &quot;Households using unimproved sanitation facility&quot;,
              &quot;Households using shared improved sanitation facility&quot;,
              &quot;Households using improved sanitation facility not shared with others&quot;,
              &quot;Mean number of people sharing a sanitation facility&quot;,
              &quot;Households using a WSUP-supported sanitation facility&quot;,
              &quot;Households using sanitation facility with water for handwashing&quot;,
              &quot;Satisfied with handwashing facility&quot;,
              &quot;Households using sanitation facility with lights&quot;,
              &quot;Households using sanitation facility with a lockable door&quot;,
              &quot;Households using sanitation facility with container for menstrual hygiene management&quot;,
              &quot;Sanitary disposal of child&apos;s faeces&quot;,
              &quot;Mean waiting time to use sanitation facility&quot;,
              &quot;Mean amount (in BGD Taka) spent by household per week for using sanitation facility&quot;,
              &quot;Satisfied with amount spent weekly for using sanitation facility&quot;,
              &quot;Households that made an initial investment in their sanitation facility&quot;,
              &quot;Mean amount (in BGD Taka) of initial investment in household&apos;s sanitation facility&quot;,
              &quot;Households willing to invest in improving sanitation facility&quot;,
              &quot;Satisfied with cleanliness of household&apos;s sanitation facility&quot;,
              &quot;Everyone in household is able to use sanitation facility&quot;,
              &quot;Individuals/organisations contacted by household for support on sanitation-related issues&quot;,
              &quot;Women and girls in household feel safe using sanitation facility&quot;,
              &quot;Women and girls in household feel safe using sanitation facility during their menstruation period&quot;,
              &quot;Material used by women and girls in household during their menstruation period&quot;,
              &quot;How menstrual cloth is washed&quot;,
              &quot;How napkin/pad is disposed of&quot;,
              &quot;Households with handwashing facility with soap and water&quot;,
              &quot;Frequency of septic tank/pit emptying&quot;,
              &quot;Mean cost of emptying septic tank/pit&quot;,
              &quot;Individuals/organisations who empty septic tank/pit&quot;,
              &quot;Individuals/organisation who pay for emptying septic tank/pit&quot;,
              &quot;Satisfied with septic tank emptying service&quot;)
#
# Create variable set list
#
varSet &lt;- c(&quot;sanSet1&quot;, &quot;sanSet1&quot;, &quot;sanSet1&quot;, &quot;sanSet1&quot;, &quot;sanSet2&quot;, &quot;sanSet1&quot;,
            &quot;sanSet1&quot;, &quot;sanSet1&quot;, &quot;sanSet1&quot;, &quot;sanSet1&quot;, &quot;sanSet1&quot;, &quot;sanSet3&quot;,
            &quot;sanSet2&quot;, &quot;sanSet2&quot;, &quot;sanSet2&quot;, &quot;sanSet4&quot;, &quot;sanSet4&quot;, &quot;sanSet4&quot;, 
            &quot;sanSet4&quot;, &quot;sanSet2&quot;, &quot;sanSet4&quot;, &quot;sanSet2&quot;, &quot;sanSet2&quot;, &quot;sanSet3&quot;, 
            &quot;sanSet3&quot;, &quot;sanSet3&quot;, &quot;sanSet3&quot;, &quot;sanSet4&quot;, &quot;sanSet4&quot;, &quot;sanSet4&quot;, 
            &quot;sanSet4&quot;, &quot;sanSet4&quot;) 
#
# Create variable title list
#
varTitle &lt;- c(&quot;Types of Sanitation Facilities&quot;,
              &quot;Types of Sanitation Facilities&quot;,
              &quot;Types of Sanitation Facilities&quot;,
              &quot;Types of Sanitation Facilities&quot;,
              &quot;Access to Sanitation Facilities&quot;,
              &quot;Types of Sanitation Facilities&quot;,
              &quot;Types of Sanitation Facilities&quot;,
              &quot;Types of Sanitation Facilities&quot;,
              &quot;Types of Sanitation Facilities&quot;,
              &quot;Types of Sanitation Facilities&quot;,
              &quot;Types of Sanitation Facilities&quot;,
              &quot;Sanitation Practices and Behaviours&quot;,
              &quot;Access to Sanitation Facilities&quot;,
              &quot;Access to Sanitation Facilities&quot;,
              &quot;Access to Sanitation Facilities&quot;,
              &quot;Other Sanitation Indicators&quot;,
              &quot;Other Sanitation Indicators&quot;,
              &quot;Other Sanitation Indicators&quot;,
              &quot;Other Sanitation Indicators&quot;,
              &quot;Access to Sanitation Facilities&quot;,
              &quot;Other Sanitation Indicators&quot;,
              &quot;Access to Sanitation Facilities&quot;,
              &quot;Access to Sanitation Facilities&quot;,
              &quot;Sanitation Practices and Behaviours&quot;,
              &quot;Sanitation Practices and Behaviours&quot;,
              &quot;Sanitation Practices and Behaviours&quot;,
              &quot;Sanitation Practices and Behaviours&quot;,
              &quot;Other Sanitation Indicators&quot;,
              &quot;Other Sanitation Indicators&quot;,
              &quot;Other Sanitation Indicators&quot;,
              &quot;Other Sanitation Indicators&quot;,
              &quot;Other Sanitation Indicators&quot;)
#
# Crear variable filename list
#
varFile &lt;- ifelse(varSet == &quot;sanSet1&quot;, &quot;types-sanitation-facilities&quot;,
             ifelse(varSet == &quot;sanSet2&quot;, &quot;access-sanitation-facilities&quot;,
               ifelse(varSet == &quot;sanSet3&quot;, &quot;sanitation-practices&quot;, &quot;other-sanitation-indicators&quot;)))
#
# Concatenate steering vectors into a data.frame
#
steerIndicators &lt;- data.frame(varList, varFunction, varStatistic, varNames, varSet, varTitle, varFile)
#
# Save sanitation steering file as CSV
#
write.table(x = steerIndicators,
            file = &quot;outputLists/steerIndicatorsSanitation.csv&quot;,
            quote = FALSE,
            sep = &quot;,&quot;,
            row.names = FALSE)
#
# Clean-up
#
rm(varList, varFunction, varStatistic, varNames, varSet, varTitle, varFile)


################################################################################
#
# Results by indicator single output - LQAS - Sanitation
#
################################################################################
#
# Create empty aggregator object for LQAS results
#
resultAll &lt;- NULL
#
# Cycle through indicators
#
for(i in steerIndicators$varList)
  {
  #
  # Create empty matrix to aggregate interim output
  #
  resultDF &lt;- matrix(ncol = 9, nrow = max(unique(indicatorsDF$zone)))
  #
  # Check type of function required for current indicator is a proportion
  #
  if(steerIndicators$varFunction[steerIndicators$varList == i] == &quot;proportion&quot;)
    {
    #
    # Cycle through survey zones
    #
    for(j in unique(indicatorsDF$zone))
      {
      #
      # Cycle through area types i.e. slum and other
      #
      for(k in unique(indicatorsDF$type))
        {
        #
        # Subset indicator data to current zone and current area type
        #
        temp &lt;- indicatorsDF[indicatorsDF$zone == j &amp; indicatorsDF$type == k, i]
        #
        # Count total sample size for current area type
        #
        total &lt;- length(!is.na(temp))
        #
        # Calculate lower target
        #
        class1 &lt;- floor(total * lowerClass)
        #
        # Calculate upper target
        #
        class2 &lt;- floor(total * upperClass)
        #
        # Count total number of cases i.e. those for which indicator is TRUE
        #
        cases &lt;- sum(temp, na.rm = TRUE)
        #
        # Classify
        #
        class &lt;- ifelse(cases &lt;= class1, &quot;Low&quot;,
                   ifelse(cases &gt; class2, &quot;High&quot;, &quot;Moderate&quot;))
        #      
        # Determine if area is slum or other
        #     
        typeCol &lt;- rep(k, 3)
        #
        # Add interim results to empty matrix
        #
        resultDF[j, ifelse(typeCol == 1, 4:6, 7:9)] &lt;- c(total, cases, class)
        }
      }
    }
  #
  # If current indicator does not require proportion function
  #  
  else
    {
    #
    # Cylce through zones
    #
    for(j in unique(indicatorsDF$zone))
      {
      #
      # Cycle through area types i.e. slum or other
      #
      for(k in unique(indicatorsDF$type))
        {
        #
        # Subset indicator data to current zone and current area type
        #
        temp &lt;- indicatorsDF[indicatorsDF$zone == j &amp; indicatorsDF$type == k, i]
        #
        # Count total sample size for current area type
        #
        total &lt;- length(!is.na(temp))
        #
        # Set cases to 0 as indicator is not a proportion
        #
        cases &lt;- 0
        #
        # No classification as current indicator is not a proportion
        #
        class &lt;- NA
        #      
        # Determine if area is slum or other
        #     
        typeCol &lt;- rep(k, 3)
        #
        # Add interim results to empty matrix
        #
        resultDF[j, ifelse(typeCol == 1, 4:6, 7:9)] &lt;- c(total, cases, class)
        }
      }
    }
  #
  # Add identifying data to interim results matrix
  #  
  resultDF[,1] &lt;- steerIndicators$varNames[steerIndicators$varList == i]
  resultDF[,2] &lt;- i
  resultDF[,3] &lt;- paste(&quot;Survey Area&quot;, 1:j, sep = &quot; &quot;)
  #
  # Convert interim results matrix to data.frame
  #
  resultDF &lt;- data.frame(resultDF)
  #
  # Name variables in interim results data.frame
  #
  names(resultDF) &lt;- c(&quot;Indicator Name&quot;, &quot;Indicator Code&quot;, &quot;Survey Area&quot;, 
                       &quot;Slum Total Respondents&quot;, &quot;Slum Cases&quot;, &quot;Slum Classification&quot;, 
                       &quot;Other Total Respondents&quot;, &quot;Other Cases&quot;, &quot;Other Classification&quot;)
  #
  # Concatenate interim results data.frame with resulst aggregator
  #
  resultAll &lt;- rbind(resultAll, resultDF)
  }
#
# Save results aggregator as CSV
#
write.table(x = resultAll,
		    file = &quot;outputTables/surveyResultsSanitationLQAS.csv&quot;,
		    quote = FALSE,
		    sep = &quot;,&quot;,
		    row.names = FALSE)


################################################################################
#
# Perform bootstrap - sanitation
#
################################################################################
#
# Subset steerIndicators to those that can be bootstrapped
#
steerBoot &lt;- subset(steerIndicators, varStatistic == &quot;oneMean&quot;)
#
# Specify number of bootstrap replicates
#
REPLICATES &lt;- 399


################################################################################
#
# All results in a single output - Bootstrap - sanitation
#
################################################################################
#
# Create empty container object for bootstrap results
#
summaryTable &lt;- NULL
#
# Cycle through each enumeration zones
#
for(i in unique(indicatorsDF$zone))
  {
  #
  # Subset population data to slum areas
  #
  slum.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 1, ]
  #
  # Subset population data to other areas
  #
  other.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 2, ]
  #
  # Subset survey data to slum areas
  #
  slum.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 1, ]
  #
  # Subset survey data to other areas
  #
  other.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 2, ]  
  #
  # Get population data for all areas in current zone
  #
  all.pop &lt;- popDF[popDF$zone == i, ]
  #
  # Get survey data for all areas in current zone
  #
  all.data &lt;- indicatorsDF[indicatorsDF$zone == i, ]
  #
  # Cycle through indicator codes
  #
  for(j in steerBoot$varList)
    {
    #
    # Select indicator and statistic pair
    #
    INDICATOR &lt;- j
    STATISTIC &lt;- steerBoot$varStatistic[steerBoot$varList == j]
    #
    # Report progress
    #
    cat(&quot;\n\n&quot;, INDICATOR, &quot; : Survey Area &quot;, i, &quot;\n\n&quot;, sep = &quot;&quot;)
    #
    # Boostrap (BBW) for current indicator and statistic pair - slum
    #
    boot.slum &lt;- bootBW(x = slum.data, 
                        w = slum.pop, 
                        statistic = eval(parse(text = STATISTIC)), 
                        params = INDICATOR, 
                        outputColumns = INDICATOR, 
                        replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - other
    #
    boot.other &lt;- bootBW(x = other.data, 
                         w = other.pop, 
                         statistic = eval(parse(text = STATISTIC)), 
                         params = INDICATOR, 
                         outputColumns = INDICATOR, 
                         replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - total
    #
    boot.total &lt;- bootBW(x = all.data, 
                         w = all.pop, 
                         statistic = eval(parse(text = STATISTIC)), 
                         params = INDICATOR, 
                         outputColumns = INDICATOR, 
                         replicates = REPLICATES)     
    #
    # Concatenate various boot vectors into data.frame
    #
    boot.all &lt;- data.frame(boot.slum, boot.other, boot.total)
    names(boot.all) &lt;- c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Total&quot;)
    #
    # Create a row of results and insert quantiles of boot results
    #
    rowResult &lt;- c(steerBoot$varNames[steerBoot$varList == j], j, paste(&quot;Survey Area &quot;, i, sep = &quot;&quot;))
    for(k in names(boot.all))
      {
      rowResult &lt;- c(rowResult, quantile(boot.all[[k]], probs = c(0.5, 0.025, 0.975), na.rm = TRUE))
      }
    #
    # Record results
    #
    summaryTable &lt;- rbind(summaryTable, rowResult)
    }
  #
  # Tidy results (row names, column types, column names, and order of rows)
  #
  summaryTable &lt;- data.frame(summaryTable, row.names = 1:nrow(summaryTable))
  #
  # Convert estimate results into numeric
  #
  for(col in 4:ncol(summaryTable))
    {
    summaryTable[, col] &lt;- as.numeric(summaryTable[, col])
    }
  }
#
# Rename summaryTable
#
names(summaryTable) &lt;- c(&quot;Indicator&quot;, &quot;Indicator Code&quot;, &quot;Survey Area&quot;, 
                         &quot;Slum Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
                         &quot;Other Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
                         &quot;Total Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;)
#
# Round-off estimates to the nearest 4 decimal places
#
summaryTable[ , 4:ncol(summaryTable)] &lt;- round(summaryTable[  , 4:ncol(summaryTable)], 4)
#
# Keep the rounding off of results for table output
#
options(scipen = 10)
#
# Save summaryTable as CSV file
#
write.table(x = summaryTable, 
            file = &quot;outputTables/surveyResultsSanitationBoot.csv&quot;, 
            quote = FALSE, 
            sep = &quot;,&quot;, 
            row.names = FALSE)
#
# Reset scipen back to 0
#
options(scipen = 0)





################################################################################
#                                                                              #
#                                                                              #
#                     ESTIMATION OF POVERTY INDICATORS                         #
#                                                                              #
#                                                                              #
################################################################################

################################################################################
#
# Create steering file for indicators reporting - poverty
#
################################################################################
#
# Create variable code list
#
varList &lt;- c(&quot;ppi&quot;, &quot;nl&quot;, &quot;nu100&quot;, &quot;nu150&quot;, &quot;nu200&quot;, &quot;extreme&quot;, 
             &quot;ppp125&quot;, &quot;ppp175&quot;, &quot;ppp200&quot;, &quot;ppp250&quot;)
#
# Create variable function list
#
varFunction &lt;- c(rep(&quot;histogram&quot;, 10))
#
# Create variable statistic list
#
varStatistic &lt;- c(rep(&quot;oneMean&quot;, 10))
#
# Create variable names list
#
varNames &lt;- c(&quot;Mean poverty score&quot;,
              &quot;Mean likelihood of household being below the Bangladesh lower national poverty line&quot;,
              &quot;Mean likelihood of household being below 100% of the Bangladesh upper national poverty line&quot;,
              &quot;Mean likelihood of household being below 150% of the Bangladesh upper national poverty line&quot;,
              &quot;Mean likelihood of household being below 200% of the Bangladesh upper national poverty line&quot;,
              &quot;Mean likelihood of household being below the USAID extreme poverty line&quot;,
              &quot;Mean likelihood of household being below the $1.25/day 2005 PPP poverty line&quot;,
              &quot;Mean likelihood of household being below the $1.75/day 2005 PPP poverty line&quot;,
              &quot;Mean likelihood of household being below the $2.00/day 2005 PPP poverty line&quot;,
              &quot;Mean likelihood of household being below the $2.50/day 2005 PPP poverty line&quot;)
#
# Create variable set list 
#
varSet &lt;- c(rep(&quot;poverty&quot;, 10))
#
# Create variable title list
#
varTitle &lt;- c(rep(&quot;Poverty Rates&quot;), 10)
#
# Create variable filename list
#
varFile &lt;- c(rep(&quot;poverty-rates&quot;), 10)
#
# Concatenate steering vectors into data.frame
#
steerIndicators &lt;- data.frame(varList, varFunction, varStatistic, varNames, varSet, varTitle, varFile)
#
# Save steering indicators as CSV
#
write.table(x = steerIndicators,
            file = &quot;outputLists/steerIndicatorsPoverty.csv&quot;,
            quote = FALSE,
            sep = &quot;,&quot;,
            row.names = FALSE)
#
# Clean-up
#
rm(varList, varFunction, varStatistic, varNames, varSet, varTitle, varFile)


################################################################################
#
# Results by indicator - single output - poverty
#
################################################################################
#
# Create empty aggregator object for LQAS results
#
resultAll &lt;- NULL
#
# Cycle through indicators
#
for(i in steerIndicators$varList)
  {
  #
  # Create empty matrix to aggregate interim output
  #
  resultDF &lt;- matrix(ncol = 9, nrow = max(unique(indicatorsDF$zone)))
  #
  # Check type of function required for current indicator is a proportion
  #
  if(steerIndicators$varFunction[steerIndicators$varList == i] == &quot;proportion&quot;)
    {
    #
    # Cycle through survey zones
    #
    for(j in unique(indicatorsDF$zone))
      {
      #
      # Cycle through area types i.e. slum and other
      #
      for(k in unique(indicatorsDF$type))
        {
        #
        # Subset indicator data to current zone and current area type
        #
        temp &lt;- indicatorsDF[indicatorsDF$zone == j &amp; indicatorsDF$type == k, i]
        #
        # Count total sample size for current area type
        #
        total &lt;- length(!is.na(temp))
        #
        # Calculate lower target
        #
        class1 &lt;- floor(total * lowerClass)
        #
        # Calculate upper target
        #
        class2 &lt;- floor(total * upperClass)
        #
        # Count total number of cases i.e. those for which indicator is TRUE
        #
        cases &lt;- sum(temp, na.rm = TRUE)
        #
        # Classify
        #
        class &lt;- ifelse(cases &lt;= class1, &quot;Low&quot;,
                   ifelse(cases &gt; class2, &quot;High&quot;, &quot;Moderate&quot;))
        #      
        # Determine if area is slum or other
        #     
        typeCol &lt;- rep(k, 3)
        #
        # Add interim results to empty matrix
        #
        resultDF[j, ifelse(typeCol == 1, 4:6, 7:9)] &lt;- c(total, cases, class)
        }
      }
    }
  #
  # If current indicator does not require proportion function
  #  
  else
    {
    #
    # Cylce through zones
    #
    for(j in unique(indicatorsDF$zone))
      {
      #
      # Cycle through area types i.e. slum or other
      #
      for(k in unique(indicatorsDF$type))
        {
        #
        # Subset indicator data to current zone and current area type
        #
        temp &lt;- indicatorsDF[indicatorsDF$zone == j &amp; indicatorsDF$type == k, i]
        #
        # Count total sample size for current area type
        #
        total &lt;- length(!is.na(temp))
        #
        # Set cases to 0 as indicator is not a proportion
        #
        cases &lt;- 0
        #
        # No classification as current indicator is not a proportion
        #
        class &lt;- NA
        #      
        # Determine if area is slum or other
        #     
        typeCol &lt;- rep(k, 3)
        #
        # Add interim results to empty matrix
        #
        resultDF[j, ifelse(typeCol == 1, 4:6, 7:9)] &lt;- c(total, cases, class)
        }
      }
    }
  #
  # Add identifying data to interim results matrix
  #  
  resultDF[,1] &lt;- steerIndicators$varNames[steerIndicators$varList == i]
  resultDF[,2] &lt;- i
  resultDF[,3] &lt;- paste(&quot;Survey Area&quot;, 1:j, sep = &quot; &quot;)
  #
  # Convert interim results matrix to data.frame
  #
  resultDF &lt;- data.frame(resultDF)
  #
  # Name variables in interim results data.frame
  #
  names(resultDF) &lt;- c(&quot;Indicator Name&quot;, &quot;Indicator Code&quot;, &quot;Survey Area&quot;, 
                       &quot;Slum Total Respondents&quot;, &quot;Slum Cases&quot;, &quot;Slum Classification&quot;, 
                       &quot;Other Total Respondents&quot;, &quot;Other Cases&quot;, &quot;Other Classification&quot;)
  #
  # Concatenate interim results data.frame with resulst aggregator
  #
  resultAll &lt;- rbind(resultAll, resultDF)
  }
#
# Save results aggregator as CSV
#
write.table(x = resultAll,
		    file = &quot;outputTables/surveyResultsPovertyLQAS.csv&quot;,
		    quote = FALSE,
		    sep = &quot;,&quot;,
		    row.names = FALSE)


################################################################################
#
# Perform bootstrap - Poverty
#
################################################################################
#
# Subset steerIndicators to those that can be bootstrapped
#
steerBoot &lt;- subset(steerIndicators, varStatistic == &quot;oneMean&quot;)
#
# Specify number of bootstrap replicates
#
REPLICATES &lt;- 399


################################################################################
#
# All results in a single output - Bootstrap - poverty
#
################################################################################
#
# Create empty container object for bootstrap results
#
summaryTable &lt;- NULL
#
# Cycle through each enumeration zones
#
for(i in unique(indicatorsDF$zone))
  {
  #
  # Subset population data to slum areas
  #
  slum.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 1, ]
  #
  # Subset population data to other areas
  #
  other.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 2, ]
  #
  # Subset survey data to slum areas
  #
  slum.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 1, ]
  #
  # Subset survey data to other areas
  #
  other.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 2, ]  
  #
  # Get population data for all areas in current zone
  #
  all.pop &lt;- popDF[popDF$zone == i, ]
  #
  # Get survey data for all areas in current zone
  #
  all.data &lt;- indicatorsDF[indicatorsDF$zone == i, ]
  #
  # Cycle through indicator codes
  #
  for(j in steerBoot$varList)
    {
    #
    # Select indicator and statistic pair
    #
    INDICATOR &lt;- j
    STATISTIC &lt;- steerBoot$varStatistic[steerBoot$varList == j]
    #
    # Report progress
    #
    cat(&quot;\n\n&quot;, INDICATOR, &quot; : Survey Area &quot;, i, &quot;\n\n&quot;, sep = &quot;&quot;)
    #
    # Boostrap (BBW) for current indicator and statistic pair - slum
    #
    boot.slum &lt;- bootBW(x = slum.data, 
                        w = slum.pop, 
                        statistic = eval(parse(text = STATISTIC)), 
                        params = INDICATOR, 
                        outputColumns = INDICATOR, 
                        replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - other
    #
    boot.other &lt;- bootBW(x = other.data, 
                         w = other.pop, 
                         statistic = eval(parse(text = STATISTIC)), 
                         params = INDICATOR, 
                         outputColumns = INDICATOR, 
                         replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - total
    #
    boot.total &lt;- bootBW(x = all.data, 
                         w = all.pop, 
                         statistic = eval(parse(text = STATISTIC)), 
                         params = INDICATOR, 
                         outputColumns = INDICATOR, 
                         replicates = REPLICATES)     
    #
    # Concatenate various boot vectors into data.frame
    #
    boot.all &lt;- data.frame(boot.slum, boot.other, boot.total)
    names(boot.all) &lt;- c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Total&quot;)
    #
    # Create a row of results and insert quantiles of boot results
    #
    rowResult &lt;- c(steerBoot$varNames[steerBoot$varList == j], j, paste(&quot;Survey Area &quot;, i, sep = &quot;&quot;))
    for(k in names(boot.all))
      {
      rowResult &lt;- c(rowResult, quantile(boot.all[[k]], probs = c(0.5, 0.025, 0.975), na.rm = TRUE))
      }
    #
    # Record results
    #
    summaryTable &lt;- rbind(summaryTable, rowResult)
    }
  #
  # Tidy results (row names, column types, column names, and order of rows)
  #
  summaryTable &lt;- data.frame(summaryTable, row.names = 1:nrow(summaryTable))
  #
  # Convert estimate results into numeric
  #
  for(col in 4:ncol(summaryTable))
    {
    summaryTable[, col] &lt;- as.numeric(summaryTable[, col])
    }
  }
#
# Rename summaryTable
#
names(summaryTable) &lt;- c(&quot;Indicator&quot;, &quot;Indicator Code&quot;, &quot;Survey Area&quot;, 
                         &quot;Slum Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
                         &quot;Other Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
                         &quot;Total Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;)
#
# Round-off estimates to the nearest 4 decimal places
#
summaryTable[ , 4:ncol(summaryTable)] &lt;- round(summaryTable[  , 4:ncol(summaryTable)], 4)
#
# Keep the rounding off of results for table output
#
options(scipen = 10)
#
# Save summaryTable as CSV file
#
write.table(x = summaryTable, 
            file = &quot;outputTables/surveyResultsPovertyBoot.csv&quot;, 
            quote = FALSE, 
            sep = &quot;,&quot;, 
            row.names = FALSE)
#
# Reset scipen back to 0
#
options(scipen = 0)

</command>
							<property title="Classify and Estimate" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="109" date="1510899093939" uid="f97471ef50798577" x="520" y="270">
							<command>
################################################################################
#
# Create histograms by survey area
#
################################################################################
#
# Subset indicator steering file to those requiring histograms
#
steerHist &lt;- subset(steerIndicators, varFunction == &quot;histogram&quot;)
#
# Re-code zone variable for ggplot
#
indicatorsDF$zone &lt;- with(indicatorsDF, ifelse(zone == 1, &quot;Survey Area 1&quot;,
                                          ifelse(zone == 2, &quot;Survey Area 2&quot;,
                                            ifelse(zone == 3, &quot;Survey Area 3&quot;,
                                              ifelse(zone == 4, &quot;Survey Area 4&quot;,
                                                ifelse(zone == 5, &quot;Survey Area 5&quot;,
                                                  ifelse(zone == 6, &quot;Survey Area 6&quot;,
                                                    ifelse(zone == 7, &quot;Survey Area 7&quot;,
                                                      ifelse(zone == 8, &quot;Survey Area 8&quot;, &quot;Survey Area 9&quot;)))))))))
#
# Re-code type variable for ggplot
#
indicatorsDF$type &lt;- with(indicatorsDF, ifelse(type == 1, &quot;Slum&quot;, &quot;Other&quot;))
indicatorsDF$type &lt;- factor(indicatorsDF$type, levels = c(&quot;Slum&quot;, &quot;Other&quot;))


################################################################################
#
# Create WSUP plotting theme
#
################################################################################

theme_wsup &lt;- theme_bw() + 
              theme(strip.text = element_text(size = 14), 
                    strip.background = element_rect(colour = &quot;black&quot;, size = 0.5),
                    panel.border = element_rect(colour = &quot;gray90&quot;, fill = NA),
                    legend.key = element_rect(colour = NA, fill = NA))

  
################################################################################
#
# Create plotting layers - number of household members
#
################################################################################
#
# Create ggplot mapping base
#
basePlot &lt;- ggplot(data = indicatorsDF, mapping = aes(x = nMembers))
#
# Layers
#
histPlot &lt;- geom_histogram(binwidth = 1, color = wsupColour, fill = wsupColour, alpha = 0.6)
#
# Combine layers
#
allPlot &lt;- basePlot + histPlot


################################################################################
#
# nMembers: number of household members by survey area and area type
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/nMembersByArea&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 18, height = 8, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap(zone ~ type, nrow = 3) + labs(x = &quot;No. of Household Members&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()
 

################################################################################
#
# nMembers: number of household members for all of Dhaka by survey area
#
################################################################################ 
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/nMembersByAreaTotal&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 12, height = 9, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap( ~ zone, ncol = 3) + labs(x = &quot;No. of Household Members&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# nMembers: number of household members for all of Dhaka by area type
#
################################################################################ 
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/nMembersByTypeTotal&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 8, height = 3, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap( ~ type) + labs(x = &quot;No. of Household Members&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# nMembers: number of household members total
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/nMembersOverall&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 9, height = 6, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + labs(x = &quot;No. of Household Members&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphis device
#
dev.off()



################################################################################
#
# Create plotting layers - PPI
#
################################################################################
#
# Create ggplot plotting base
#
basePlot &lt;- ggplot(data = indicatorsDF, mapping = aes(x = ppi))
#
# Layers
#
histPlot &lt;- geom_histogram(binwidth = 10, color = wsupColour, fill = wsupColour, alpha = 0.6)
#
# Assemble layers
#
allPlot &lt;- basePlot + histPlot


################################################################################
#
# ppi: ppi by survey area and area type
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/ppiByArea&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 18, height = 8, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap(zone ~ type, nrow = 3) + labs(x = &quot;PPI Score&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()
 

################################################################################
#
# ppi: ppi for all of Dhaka by survey area
#
################################################################################ 
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/ppiByAreaTotal&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 12, height = 9, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap( ~ zone, ncol = 3) + labs(x = &quot;PPI Score&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# ppi: ppi for all of Dhaka by area type
#
################################################################################ 
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/ppiByTypeTotal&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 8, height = 3, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap( ~ type) + labs(x = &quot;PPI Score&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# ppi: ppi total
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/ppiOverall&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 9, height = 6, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + labs(x = &quot;PPI Score&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphis device
#
dev.off()



################################################################################
#
# Create plotting layers - pQuintile
#
################################################################################
#
# Create ggplot mapping base
#
basePlot &lt;- ggplot(data = indicatorsDF, mapping = aes(x = pQuintile))
#
# Layers
#
histPlot &lt;- geom_histogram(binwidth = 1, color = wsupColour, fill = wsupColour, alpha = 0.6)
#
#
#
allPlot &lt;- basePlot + histPlot


################################################################################
#
# pQuintile: pQuintile by survey area and area type
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/pQuintileByArea&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 18, height = 8, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap(zone ~ type, nrow = 3) + labs(x = &quot;Wealth Quintiles based on PPI Score&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()
 

################################################################################
#
# pQuintile: wealth quintiles for all of Dhaka by survey area
#
################################################################################ 
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/pQuintileByAreaTotal&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 12, height = 9, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap( ~ zone, ncol = 3) + labs(x = &quot;Wealth Quintiles based on PPI Score&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# pQuintile: wealth quintiles for all of Dhaka by area type
#
################################################################################ 
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/pQuintileByTypeTotal&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 8, height = 3, units = &quot;in&quot;, pointsize = 14, res = 200)
#
# Plot all layers
#
allPlot + facet_wrap( ~ type) + labs(x = &quot;Wealth Quintiles based on PPI Score&quot;, y = &quot;&quot;) + theme_wsup
#
# Close graphics device
#
dev.off()


</command>
							<property title="Histograms" shape="CHART"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="110" date="1510899093935" uid="eec9d8cac82e4d04" x="330" y="170">
							<command>################################################################################
#                                                                              #
#                                                                              #
#                               CREATE CHARTS                                  #
#                                                                              #
#                                                                              #
################################################################################

################################################################################
#
# Read processed data
#
################################################################################

indicatorsDF &lt;- read.csv(file = paste(&quot;data/indicatorsData&quot;, unique(ccode), &quot;.csv&quot;, sep = &quot;&quot;), 
                         header = TRUE, sep = &quot;,&quot;)


################################################################################
#
# Create graphics for water indicators
#
################################################################################
#
# Read steering file
#
steerIndicators &lt;- read.csv(file = paste(&quot;outputLists/steerIndicators&quot;, unique(ccode), &quot;.csv&quot;, sep = &quot;&quot;),
                            header = TRUE, sep = &quot;,&quot;)
#
# Subset to water indicators
#
steerIndicators &lt;- steerIndicators[1:29, ]

################################################################################
#
# Create histograms by survey area - water
#
################################################################################
#
# Subset steering file into indicators needing histograms
#
steerHist &lt;- subset(steerIndicators, varFunction == &quot;histogram&quot;)
#
# Cycle through indicators needing histograms
#
for(i in steerHist$varList)
  {
  #
  # Cycle through survey areas
  #
  for(j in unique(indicatorsDF$zone))
    {
    #
    # Subset data to current zone
    #
    temp &lt;- subset(indicatorsDF, zone == j)
    #
    # Open PNG graphics device
    #
    png(filename = paste(&quot;outputFigures/charts/&quot;, i, &quot;SurveyArea&quot;, j, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
        width = 9, height = 3, units = &quot;in&quot;, res = 100)
    #
    #
    #    
    par(mfrow = c(1,3))
    #
    # Cycle through area type
    #
    for(k in unique(indicatorsDF$type))
      {
      #
      # Create histogram for current area type
      #
      hist(x = temp[temp$type == k, i],
           main = ifelse(k == 1, &quot;Slum&quot;, &quot;Other&quot;),
           xlab = ifelse(i == &quot;water4&quot;, &quot;Hours&quot;,
                   ifelse(i == &quot;water7&quot;, &quot;Minutes&quot;, &quot;Cost (BGD Taka)&quot;)))
      }
    #
    # Create histgram for entire survey area
    #
    hist(x = temp[[i]],
         main = &quot;Overall&quot;,
         xlab = ifelse(i == &quot;water4&quot;, &quot;Hours&quot;,
                   ifelse(i == &quot;water7&quot;, &quot;Minutes&quot;, &quot;Cost (BGD Taka)&quot;)))
    #
    # Close graphics device
    #
    dev.off()
    }
  }


################################################################################
#
# Create pareto charts - by survey area
#
################################################################################
#
# Subset steering file into indicators needing histograms
#
steerBar &lt;- subset(steerIndicators, varFunction == &quot;pareto&quot;)
#
# Cycle through indicators needing histograms
#
for(i in steerBar$varList)
  {
  #
  # Cycle through survey areas
  #
  for(j in unique(indicatorsDF$zone))
    {
    #
    # Subset data to current zone
    #
    temp &lt;- subset(indicatorsDF, zone == j)
    #
    # Open PNG graphics device
    #
    png(filename = paste(&quot;outputFigures/charts/&quot;, i, &quot;SurveyArea&quot;, j, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
        width = 12, height = 3, units = &quot;in&quot;, res = 100)
    #
    #
    #    
    par(mar = c(3,14,1,1), mfrow = c(1,3))
    #
    # Cycle through area type
    #
    for(k in unique(indicatorsDF$type))
      {
      #
      # Create histogram for current area type
      #
      barplot(height = sort(table(temp[[i]]), decreasing = TRUE),
              horiz = TRUE,
              las = 1,
              xlab = &quot;&quot;,
              main = &quot;&quot;)
      }
    #
    # Create histgram for entire survey area
    #
    barplot(height = sort(table(temp[[i]]), decreasing = TRUE),
            horiz = TRUE,
            las = 1,
            xlab = &quot;&quot;,
            main = &quot;&quot;)
    #
    # Close graphics device
    #
    dev.off()
    }
  }


################################################################################
#
# Create graphics for sanitation indicators
#
################################################################################
#
# Read steering file
#
steerIndicators &lt;- read.csv(file = paste(&quot;outputLists/steerIndicators&quot;, unique(ccode), &quot;.csv&quot;, sep = &quot;&quot;),
	header = TRUE, sep = &quot;,&quot;)
#
# Subset to water indicators
#
steerIndicators &lt;- steerIndicators[30:56, ]


################################################################################
#
# Create histograms - by survey area
#
################################################################################
#
# Subset steering file into indicators needing histograms
#
steerHist &lt;- subset(steerIndicators, varFunction == &quot;histogram&quot;)
#
# Cycle through indicators needing histograms
#
for(i in steerHist$varList)
  {
  #
  # Cycle through survey areas
  #
  for(j in unique(indicatorsDF$zone))
    {
    #
    # Subset data to current zone
    #
    temp &lt;- subset(indicatorsDF, zone == j)
    #
    # Open PNG graphics device
    #
    png(filename = paste(&quot;outputFigures/charts/&quot;, i, &quot;SurveyArea&quot;, j, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
        width = 9, height = 3, units = &quot;in&quot;, res = 100)
    #
    #
    #    
    par(mfrow = c(1,3))
    #
    # Cycle through area type
    #
    for(k in unique(indicatorsDF$type))
      {
      #
      #
      #
      if(sum(temp[temp$type == k, i], na.rm = TRUE) != 0)
        {
        #
        # Create histogram for current area type
        #
        hist(x = temp[temp$type == k, i],
             main = ifelse(k == 1, &quot;Slum&quot;, &quot;Other&quot;),
             xlab = ifelse(i == &quot;san2&quot;, &quot;No. of people&quot;,
                     ifelse(i == &quot;san13&quot;, &quot;Minutes&quot;, &quot;Cost (BGD Taka)&quot;)))
        }
      }
    #
    #
    #
    if(sum(temp[[i]], na.rm = TRUE) != 0)
      {
      #
      # Create histgram for entire survey area
      #
      hist(x = temp[[i]],
           main = &quot;Overall&quot;,
           xlab = ifelse(i == &quot;san2&quot;, &quot;No. of people&quot;,
                     ifelse(i == &quot;san13&quot;, &quot;Minutes&quot;, &quot;Cost (BGD Taka)&quot;)))
      }
    #
    # Close graphics device
    #
    dev.off()
    }
  }


################################################################################
#
# Create pareto charts - by survey area
#
################################################################################
#
# Subset steering file into indicators needing histograms
#
steerBar &lt;- subset(steerIndicators, varFunction == &quot;pareto&quot;)
#
# Cycle through indicators needing histograms
#
for(i in steerBar$varList)
  {
  #
  # Cycle through survey areas
  #
  for(j in unique(indicatorsDF$zone))
    {
    #
    # Subset data to current zone
    #
    temp &lt;- subset(indicatorsDF, zone == j)
    #
    # Open PNG graphics device
    #
    png(filename = paste(&quot;outputFigures/charts/&quot;, i, &quot;SurveyArea&quot;, j, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
        width = 12, height = 3, units = &quot;in&quot;, res = 100)
    #
    #
    #    
    par(mar = c(3,14,1,1), mfrow = c(1,3))
    #
    # Cycle through area type
    #
    for(k in unique(indicatorsDF$type))
      {
      #
      # Create histogram for current area type
      #
      barplot(height = sort(table(temp[[i]]), decreasing = TRUE),
              horiz = TRUE,
              las = 1,
              xlab = &quot;&quot;,
              main = &quot;&quot;)
      }
    #
    # Create histgram for entire survey area
    #
    barplot(height = sort(table(temp[[i]]), decreasing = TRUE),
            horiz = TRUE,
            las = 1,
            xlab = &quot;&quot;,
            main = &quot;&quot;)
    #
    # Close graphics device
    #
    dev.off()
    }
  }
  

################################################################################
#
# Create graphics for poverty indicators
#
################################################################################
#
# Read steering file
#
steerIndicators &lt;- read.csv(file = paste(&quot;outputLists/steerIndicators&quot;, unique(ccode), &quot;.csv&quot;, sep = &quot;&quot;),
	header = TRUE, sep = &quot;,&quot;)
#
# Subset to water indicators
#
steerIndicators &lt;- steerIndicators[57:66, ]


################################################################################
#
# Create histograms - by survey area
#
################################################################################
#
# Subset steering file into indicators needing histograms
#
steerHist &lt;- subset(steerIndicators, varFunction == &quot;histogram&quot;)
#
# Cycle through indicators needing histograms
#
for(i in steerHist$varList)
  {
  #
  # Cycle through survey areas
  #
  for(j in unique(indicatorsDF$zone))
    {
    #
    # Subset data to current zone
    #
    temp &lt;- subset(indicatorsDF, zone == j)
    #
    # Open PNG graphics device
    #
    png(filename = paste(&quot;outputFigures/charts/&quot;, i, &quot;SurveyArea&quot;, j, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
        width = 9, height = 3, units = &quot;in&quot;, res = 100)
    #
    #
    #    
    par(mfrow = c(1,3))
    #
    # Cycle through area type
    #
    for(k in unique(indicatorsDF$type))
      {
      #
      #
      #
      if(sum(temp[temp$type == k, i], na.rm = TRUE) != 0)
        {
        #
        # Create histogram for current area type
        #
        hist(x = temp[temp$type == k, i],
             main = ifelse(k == 1, &quot;Slum&quot;, &quot;Other&quot;),
             xlab = ifelse(i == &quot;ppi&quot;, &quot;Poverty score&quot;, &quot;Probability of being below poverty line&quot;))
        }
      }
    #
    #
    #
    if(sum(temp[[i]], na.rm = TRUE) != 0)
      {
      #
      # Create histgram for entire survey area
      #
      hist(x = temp[[i]],
           main = &quot;Overall&quot;,
           xlab = ifelse(i == &quot;ppi&quot;, &quot;Poverty score&quot;, &quot;Probability of being below poverty line&quot;))
      }
    #
    # Close graphics device
    #
    dev.off()
    }
  }

</command>
							<property title="Charts" shape="CHART"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="111" date="1510899093935" uid="81330b7c75043f48" x="190" y="270">
							<command>################################################################################
#
# Create graphics for water indicators
#
################################################################################
#
# Subset to water indicators
#
steerIndicators &lt;- steerIndicatorsX[2:30, ]


################################################################################
#
# Create histograms by survey area - water
#
################################################################################
#
# Subset steering file into indicators needing histograms
#
steerHist &lt;- subset(steerIndicators, varFunction == &quot;histogram&quot;)
#
# Cycle through indicators needing histograms
#
for(i in steerHist$varList)
  {
  #
  # Cycle through survey areas
  #
  for(j in unique(indicatorsDF$zone))
    {
    #
    # Subset data to current zone
    #
    temp &lt;- subset(indicatorsDF, zone == j)
    #
    # Open PNG graphics device
    #
    png(filename = paste(&quot;outputFigures/charts/&quot;, i, &quot;SurveyArea&quot;, j, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
        width = 9, height = 3, units = &quot;in&quot;, res = 100)
    #
    #
    #    
    par(mfrow = c(1,3))
    #
    # Cycle through area type
    #
    for(k in unique(indicatorsDF$type))
      {
      #
      # Create histogram for current area type
      #
      hist(x = temp[temp$type == k, i],
           main = ifelse(k == 1, &quot;Slum&quot;, &quot;Other&quot;),
           xlab = ifelse(i == &quot;water4&quot;, &quot;Hours&quot;,
                   ifelse(i == &quot;water7&quot;, &quot;Minutes&quot;, &quot;Cost (BGD Taka)&quot;)))
      }
    #
    # Create histgram for entire survey area
    #
    hist(x = temp[[i]],
         main = &quot;Overall&quot;,
         xlab = ifelse(i == &quot;water4&quot;, &quot;Hours&quot;,
                   ifelse(i == &quot;water7&quot;, &quot;Minutes&quot;, &quot;Cost (BGD Taka)&quot;)))
    #
    # Close graphics device
    #
    dev.off()
    }
  }


################################################################################
#
# Create pareto charts - by survey area
#
################################################################################
#
# Subset steering file into indicators needing histograms
#
steerBar &lt;- subset(steerIndicators, varFunction == &quot;pareto&quot;)
#
# Cycle through indicators needing histograms
#
for(i in steerBar$varList)
  {
  #
  # Cycle through survey areas
  #
  for(j in unique(indicatorsDF$zone))
    {
    #
    # Subset data to current zone
    #
    temp &lt;- subset(indicatorsDF, zone == j)
    #
    # Open PNG graphics device
    #
    png(filename = paste(&quot;outputFigures/charts/&quot;, i, &quot;SurveyArea&quot;, j, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
        width = 12, height = 3, units = &quot;in&quot;, res = 100)
    #
    #
    #    
    par(mar = c(3,14,1,1), mfrow = c(1,3))
    #
    # Cycle through area type
    #
    for(k in unique(indicatorsDF$type))
      {
      #
      # Create histogram for current area type
      #
      barplot(height = sort(table(temp[[i]]), decreasing = TRUE),
              horiz = TRUE,
              las = 1,
              xlab = &quot;&quot;,
              main = &quot;&quot;)
      }
    #
    # Create histgram for entire survey area
    #
    barplot(height = sort(table(temp[[i]]), decreasing = TRUE),
            horiz = TRUE,
            las = 1,
            xlab = &quot;&quot;,
            main = &quot;&quot;)
    #
    # Close graphics device
    #
    dev.off()
    }
  }</command>
							<property title="Water charts" shape="CHART"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="112" date="1510899093938" uid="94e002798a4c934d" x="158" y="164">
							<command>
################################################################################
#
# Function
#
################################################################################

onOK &lt;- function()
  {
  #
  # 
  #
  cValue &lt;- as.character(tclvalue(choice.value))
  #
  #
  #
  tkdestroy(choice)
  #
  #
  #
  tkmessageBox(title = &quot;Selected analysis&quot;,
               message = paste(&quot;You have selected to &quot;, cValue, &quot;.&quot;, sep = &quot;&quot;),
               icon = &quot;info&quot;,
               type = &quot;ok&quot;)
  #
  #
  #
  return(cValue)
  }


################################################################################
#                                                                              
# Select type of analysis to perform                                           
#                                                                              
################################################################################
#
# Vector of analysis techniques
#
techniques &lt;- c(&quot;classify&quot;, &quot;estimate&quot;, &quot;classify and estimate&quot;)
#
# Open dialog box
#
choice &lt;- tktoplevel()
#
# Add title to dialog box
#
tkwm.title(choice, &quot;Select analysis&quot;)
#
# Cycle through techniques
#
for(i in 1:length(techniques))
  {
  #
  # Create radio buttons
  # 	
  assign(x = paste(&quot;choice$env$choice&quot;, i, sep = &quot;&quot;),
         value = tk2radiobutton(choice))
  }
#
# Set selected radio buttons by default
#
choice.value &lt;- tclVar(techniques[1])
#
# Cycle through techniques
#
for(i in 1:length(techniques))
  {
  #
  # Configure the radio buttons
  #
  tkconfigure(widget = get(paste(&quot;choice$env$choice&quot;, i, sep = &quot;&quot;)),
              variable = choice.value,
              value = techniques[i])
  }
#
# Add prompt asking which analysis to perform
#
tkgrid(tk2label(parent = choice, text = &quot;What analysis do you want to perform?&quot;),
                columnspan = 2, padx = 10, pady = c(15, 5))
#
# Cycle through techniques
#
for(i in 1:length(techniques))
  {
  #
  # Add radio button labels
  #    
  tkgrid(tk2label(parent = choice, text = techniques[i]),
         get(paste(&quot;choice$env$choice&quot;, i, sep = &quot;&quot;)),
         padx = 10, pady = c(0, i + 5))
  }
#
#
#  
choice$env$butOK &lt;- tk2button(choice, text = &quot;OK&quot;, width = -6, command = onOK)
#
#
#
tkgrid(choice$env$butOK, columnspan = 2, padx = 10, pady = c(5, 15))
#
#
#
tkfocus(choice)
#
#
#
analysis &lt;- choice.value


</command>
							<property title="Choose analysis" shape="INPUT"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="113" date="1510899093941" uid="349b2b29d28ec0a1" x="610" y="270">
							<command>################################################################################
#
# Transform results data to long format for ggplot
#
################################################################################
#
# Read survey results
#
surveyResults &lt;- read.csv(&quot;outputTables/surveyResultsBGD.csv&quot;)
#
# Subset survey results to columns needed for plotting
#
temp1 &lt;- subset(surveyResults, select = c(indicatorName, indicatorCode, surveyArea, slumTotal, slumEst))
temp2 &lt;- subset(surveyResults, select = c(indicatorName, indicatorCode, surveyArea, otherTotal, otherEst))
temp3 &lt;- subset(surveyResults, select = c(indicatorName, indicatorCode, surveyArea, total, totalEst))
#
# Add area type variable
#
temp1$type &lt;- rep(&quot;Slum&quot;, nrow(temp1))
temp2$type &lt;- rep(&quot;Other&quot;, nrow(temp2))
temp3$type &lt;- rep(&quot;Overall&quot;, nrow(temp3))
#
# Rename variables
#
names(temp1) &lt;- c(&quot;indicatorName&quot;, &quot;indicatorCode&quot;, &quot;surveyArea&quot;, &quot;n&quot;, &quot;estimate&quot;, &quot;type&quot;)
names(temp2) &lt;- c(&quot;indicatorName&quot;, &quot;indicatorCode&quot;, &quot;surveyArea&quot;, &quot;n&quot;, &quot;estimate&quot;, &quot;type&quot;)
names(temp3) &lt;- c(&quot;indicatorName&quot;, &quot;indicatorCode&quot;, &quot;surveyArea&quot;, &quot;n&quot;, &quot;estimate&quot;, &quot;type&quot;)
#
# Create single long data.frame
#
surveyResultsLong &lt;- data.frame(rbind(temp1, temp2, temp3))


################################################################################
#
# jmpWaterResults: subset surveyResultsLong to indicators for water ladder
#
################################################################################
#
# List of jmp water indicators
#
jmpWaterList &lt;- c(&quot;jmpWater1&quot;, &quot;jmpWater2&quot;, &quot;jmpWater3&quot;, &quot;jmpWater4&quot;, &quot;jmpWater5&quot;)
#
# Subest to jmp water indicators
#
jmpWaterResults &lt;- subset(surveyResultsLong, indicatorCode %in% jmpWaterList)
#
# Sort jmpWaterResults by indicatorCode
#
jmpWaterResults &lt;- jmpWaterResults[order(jmpWaterResults$indicatorCode), ]
#
# Convert indicatorCode to factor and sort accordingly to match ladder
#
jmpWaterResults$indicatorCode &lt;- with(jmpWaterResults, factor(x = indicatorCode,
                                                              levels = rev(jmpWaterList))) 
#
# Convert type to factor and sort accordingly
#
jmpWaterResults$type &lt;- with(jmpWaterResults, factor(x = type,
                                                     levels = c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Overall&quot;)))
#
# Convert surveyArea to factor and sort accordingly
#
jmpWaterResults$surveyArea &lt;- with(jmpWaterResults, factor(x = surveyArea,
                                                           levels = c(&quot;Survey Area 1&quot;,
                                                                      &quot;Survey Area 2&quot;,
                                                                      &quot;Survey Area 3&quot;,
                                                                      &quot;Survey Area 4&quot;,
                                                                      &quot;Survey Area 5&quot;,
                                                                      &quot;Survey Area 6&quot;,
                                                                      &quot;Survey Area 7&quot;,
                                                                      &quot;Survey Area 8&quot;,
                                                                      &quot;Survey Area 9&quot;)))

################################################################################
#
# Define plotting layers for ggplot - stacked bar by survey area grouped by type
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(data = jmpWaterResults, mapping = aes(x = type, 
                                                         y = estimate, 
                                                         fill = indicatorCode))
#
# Bar plot
#
barPlot &lt;- geom_bar(stat = &quot;identity&quot;, position = &quot;fill&quot;, alpha = 0.8)
#
# Bar fill
#
barFill &lt;- scale_fill_manual(name = &quot;Drinking Water Ladder&quot;,
                             labels = c(&quot;Basic Plus&quot;,
                                        &quot;Basic&quot;,
                                        &quot;Limited&quot;,
                                        &quot;Unimproved&quot;,
                                        &quot;Surface Water&quot;),
                             values = waterLadder)
#
# Facets
#
barFacet &lt;- facet_wrap( ~ surveyArea, nrow = 3)
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Area Type&quot;, y = &quot;Proportion&quot;)
#
# x-axis tick mark labels
#
xLabels &lt;- scale_x_discrete(labels = c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Overall&quot;))


################################################################################
#
# Plot
#
################################################################################
#
# Open graphics device
#
png(filename = paste(&quot;outputFigures/charts/waterLadderByArea&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 12, height = 4 * ceiling(length(levels(jmpWaterResults$surveyArea)) / 3), units = &quot;in&quot;,
    res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFill + barFacet + barLabels + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# Define plotting layers for ggplot - stacked bar by type grouped by surveyArea
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(data = jmpWaterResults, 
                   mapping = aes(x = surveyArea,
                                 y = estimate,
                                 fill = indicatorCode))
#
# Bar plot
#        
barPlot &lt;- geom_bar(stat = &quot;identity&quot;, position = &quot;fill&quot;, alpha = 0.8)
#
# Bar fill
#
barFill &lt;- scale_fill_manual(name = &quot;Drinking Water Ladder&quot;,
                             labels = c(&quot;Basic Plus&quot;,
                                        &quot;Basic&quot;,
                                        &quot;Limited&quot;,
                                        &quot;Unimproved&quot;,
                                        &quot;Surface Water&quot;),
                             values = waterLadder)
#
#
#
barFacet &lt;- facet_wrap( ~ type, ncol = 3)
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Survey Area&quot;, y = &quot;Proportion&quot;)
#
# x-axis tick mark labels
#
xLabels &lt;- scale_x_discrete(labels = 1:length(unique(jmpWaterResults$surveyArea)))

################################################################################
#
# Plot
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/waterLadderByType&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 10, height = 4, units = &quot;in&quot;, res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFill + barFacet + barLabels + xLabels + theme_wsup
#
# Close graphics device
#
dev.off()



################################################################################
#
# jmpSanResults: subset surveyResultsLong to indicators for sanitation ladder
#
################################################################################
#
# List of jmp sanitation indicators
#
jmpSanList &lt;- c(&quot;jmpSan1&quot;, &quot;jmpSan2&quot;, &quot;jmpSan3&quot;, &quot;jmpSan4&quot;, &quot;jmpSan5&quot;)
#
# Subest to jmp sanitation indicators
#
jmpSanResults &lt;- subset(surveyResultsLong, indicatorCode %in% jmpSanList)
#
# Sort jmpSanResults by indicatorCode
#
jmpSanResults &lt;- jmpSanResults[order(jmpSanResults$indicatorCode), ]
#
# Convert indicatorCode to factor and sort accordingly to match ladder
#
jmpSanResults$indicatorCode &lt;- with(jmpSanResults, factor(x = indicatorCode,
                                                          levels = rev(jmpSanList))) 
#
# Convert type to factor and sort accordingly
#
jmpSanResults$type &lt;- with(jmpSanResults, factor(x = type,
                                                 levels = c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Overall&quot;)))
#
# Convert surveyArea to factor and sort accordingly
#
jmpSanResults$surveyArea &lt;- with(jmpSanResults, factor(x = surveyArea,
                                                           levels = c(&quot;Survey Area 1&quot;,
                                                                      &quot;Survey Area 2&quot;,
                                                                      &quot;Survey Area 3&quot;,
                                                                      &quot;Survey Area 4&quot;,
                                                                      &quot;Survey Area 5&quot;,
                                                                      &quot;Survey Area 6&quot;,
                                                                      &quot;Survey Area 7&quot;,
                                                                      &quot;Survey Area 8&quot;,
                                                                      &quot;Survey Area 9&quot;)))


################################################################################
#
# Define plotting layers for ggplot - stacked bar by survey area grouped by type
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(data = jmpSanResults, mapping = aes(x = type, 
                                                       y = estimate, 
                                                       fill = indicatorCode))
#
# Bar plot
#
barPlot &lt;- geom_bar(stat = &quot;identity&quot;, position = &quot;fill&quot;, alpha = 0.8)
#
# Bar fill
#
barFill &lt;- scale_fill_manual(name = &quot;Sanitation Ladder&quot;,
                             labels = c(&quot;Self-managed&quot;,
                                        &quot;Basic&quot;,
                                        &quot;Limited&quot;,
                                        &quot;Unimproved&quot;,
                                        &quot;Open defecation&quot;),
                             values = sanitationLadder)
#
# Facets
#
barFacet &lt;- facet_wrap( ~ surveyArea, nrow = 3)
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Area Type&quot;, y = &quot;Proportion&quot;)
#
# x-axis tick mark labels
#
xLabels &lt;- scale_x_discrete(labels = c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Overall&quot;))


################################################################################
#
# Plot
#
################################################################################
#
# Open graphics device
#
png(filename = paste(&quot;outputFigures/charts/sanitationLadderByArea&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 12, height = 4 * ceiling(length(levels(jmpSanResults$surveyArea)) / 3), units = &quot;in&quot;,
    res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFill + barFacet + barLabels + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# Define plotting layers for ggplot - stacked bar by type grouped by surveyArea
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(data = jmpSanResults, 
                   mapping = aes(x = surveyArea,
                                 y = estimate,
                                 fill = indicatorCode))
#
# Bar plot
#        
barPlot &lt;- geom_bar(stat = &quot;identity&quot;, position = &quot;fill&quot;, alpha = 0.8)
#
# Bar fill
#
barFill &lt;- scale_fill_manual(name = &quot;Sanitation Ladder&quot;,
                             labels = c(&quot;Basic Plus&quot;,
                                        &quot;Basic&quot;,
                                        &quot;Limited&quot;,
                                        &quot;Unimproved&quot;,
                                        &quot;Open Defecation&quot;),
                             values = sanitationLadder)
#
#
#
barFacet &lt;- facet_wrap( ~ type, ncol = 3)
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Survey Area&quot;, y = &quot;Proportion&quot;)
#
# x-axis tick mark labels
#
xLabels &lt;- scale_x_discrete(labels = 1:length(levels(jmpSanResults$surveyArea)))

################################################################################
#
# Plot
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/sanitationLadderByType&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 10, height = 4, units = &quot;in&quot;, res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFill + barFacet + barLabels + xLabels + theme_wsup
#
# Close graphics device
#
dev.off()



################################################################################
#
# jmpHandResults: subset surveyResultsLong to indicators for handwashing ladder
#
################################################################################
#
# List of jmp handwashing indicators
#
jmpHandList &lt;- c(&quot;jmpHand1&quot;, &quot;jmpHand2&quot;, &quot;jmpHand3&quot;)
#
# Subest to jmp handwashing indicators
#
jmpHandResults &lt;- subset(surveyResultsLong, indicatorCode %in% jmpHandList)
#
# Sort jmpHandResults by indicatorCode
#
jmpHandResults &lt;- jmpHandResults[order(jmpHandResults$indicatorCode), ]
#
# Convert indicatorCode to factor and sort accordingly to match ladder
#
jmpHandResults$indicatorCode &lt;- with(jmpHandResults, factor(x = indicatorCode,
                                                            levels = rev(jmpHandList))) 
#
# Convert type to factor and sort accordingly
#
jmpHandResults$type &lt;- with(jmpHandResults, factor(x = type,
                                                   levels = c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Overall&quot;)))
#
# Convert surveyArea to factor and sort accordingly
#
jmpHandResults$surveyArea &lt;- with(jmpHandResults, factor(x = surveyArea,
                                                         levels = c(&quot;Survey Area 1&quot;,
                                                                    &quot;Survey Area 2&quot;,
                                                                    &quot;Survey Area 3&quot;,
                                                                    &quot;Survey Area 4&quot;,
                                                                    &quot;Survey Area 5&quot;,
                                                                    &quot;Survey Area 6&quot;,
                                                                    &quot;Survey Area 7&quot;,
                                                                    &quot;Survey Area 8&quot;,
                                                                    &quot;Survey Area 9&quot;)))


################################################################################
#
# Define plotting layers for ggplot - stacked bar by survey area grouped by type
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(data = jmpHandResults, mapping = aes(x = type, 
                                                        y = estimate, 
                                                        fill = indicatorCode))
#
# Bar plot
#
barPlot &lt;- geom_bar(stat = &quot;identity&quot;, position = &quot;fill&quot;, alpha = 0.8)
#
# Bar fill
#
barFill &lt;- scale_fill_manual(name = &quot;Handwashing Ladder&quot;,
                             labels = c(&quot;Basic&quot;,
                                        &quot;Unimproved&quot;,
                                        &quot;No facility&quot;),
                             values = handwashLadder)
#
# Facets
#
barFacet &lt;- facet_wrap( ~ surveyArea, nrow = 3)
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Area Type&quot;, y = &quot;Proportion&quot;)
#
# x-axis tick mark labels
#
xLabels &lt;- scale_x_discrete(labels = c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Overall&quot;))


################################################################################
#
# Plot
#
################################################################################
#
# Open graphics device
#
png(filename = paste(&quot;outputFigures/charts/handwashLadderByArea&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 12, height = 4 * ceiling(length(levels(jmpHandResults$surveyArea)) / 3), units = &quot;in&quot;,
    res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFill + barFacet + barLabels + theme_wsup
#
# Close graphics device
#
dev.off()


################################################################################
#
# Define plotting layers for ggplot - stacked bar by type grouped by surveyArea
#
################################################################################
#
# Base plot
#
basePlot &lt;- ggplot(data = jmpHandResults, 
                   mapping = aes(x = surveyArea,
                                 y = estimate,
                                 fill = indicatorCode))
#
# Bar plot
#        
barPlot &lt;- geom_bar(stat = &quot;identity&quot;, position = &quot;fill&quot;, alpha = 0.8)
#
# Bar fill
#
barFill &lt;- scale_fill_manual(name = &quot;Handwashing Ladder&quot;,
                             labels = c(&quot;Basic&quot;,
                                        &quot;Unimproved&quot;,
                                        &quot;No facility&quot;),
                             values = handwashLadder)
#
#
#
barFacet &lt;- facet_wrap( ~ type, ncol = 3)
#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Survey Area&quot;, y = &quot;Proportion&quot;)
#
# x-axis tick mark labels
#
xLabels &lt;- scale_x_discrete(labels = 1:length(levels(jmpHandResults$surveyArea)))

################################################################################
#
# Plot
#
################################################################################
#
# Open PNG graphics device
#
png(filename = paste(&quot;outputFigures/charts/handwashLadderByType&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 10, height = 4, units = &quot;in&quot;, res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFill + barFacet + barLabels + xLabels + theme_wsup
#
# Close graphics device
#
dev.off()



</command>
							<property title="Ladders" shape="CHART"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="114" date="1510899093934" uid="2be662b9c925eaa8" x="1090" y="590">
							<command>
################################################################################
#
# If Country is Bangladesh...
#
################################################################################

################################################################################
#
# Identify sampling points within North and South Corporations
#
################################################################################

if(unique(country) == &quot;Bangladesh&quot;)
  {
  xx &lt;- readOGR(dsn = &quot;dhakaCorporations&quot;,
  	           layer = &quot;dhakaCorporations&quot;,
	           verbose = FALSE)

  long.lat.crs &lt;- &quot;+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0&quot;

  xx &lt;- spTransform(x = xx, CRSobj = CRS(long.lat.crs))                          


  yy &lt;- SpatialPoints(coords = indicatorsDF[ , c(&quot;longitude&quot;, &quot;latitude&quot;)],
	                 proj4string = CRS(long.lat.crs))

  north &lt;- subset(xx, corprtn == &quot;north&quot;)
  south &lt;- subset(xx, corprtn == &quot;south&quot;)

  indicatorsDF[indicatorsDF$longitude %in% yy[north]@coords[,1] &amp; indicatorsDF$latitude %in% yy[north]@coords[,2], ]$corporation &lt;- &quot;north&quot;
  indicatorsDF[indicatorsDF$longitude %in% yy[south]@coords[,1] &amp; indicatorsDF$latitude %in% yy[south]@coords[,2], ]$corporation &lt;- &quot;south&quot;

  corporation &lt;- ifelse(indicatorsDF$longitude %in% yy[north]@coords[,1] &amp; indicatorsDF$latitude %in% yy[north]@coords[,2], &quot;north&quot;,
	              ifelse(indicatorsDF$longitude %in% yy[south]@coords[,1] &amp; indicatorsDF$latitude %in% yy[south]@coords[,2], &quot;south&quot;, NA))

  indicatorsDF$corporation &lt;- corporation
  
  temp &lt;- indicatorsDF[ , c(&quot;psu&quot;, &quot;corporation&quot;)]
  
  popDF &lt;- merge(popDF, temp, by = &quot;psu&quot;)

################################################################################
#
# Perform bootstrap
#
################################################################################
#
# Subset steerIndicators to those that can be bootstrapped
#
steerBoot &lt;- subset(steerIndicators, varStatistic == &quot;oneMean&quot;)
#
# Extract number of replicates specified by user
#
REPLICATES &lt;- as.numeric(tclvalue(replicates))


################################################################################
#
# All results in a single output - Bootstrap
#
################################################################################
#
# Create empty container object for bootstrap results
#
summaryTable &lt;- NULL
#
# Subset population data to slum areas
#
slum.pop &lt;- popDF[popDF$type == 1, ]
#
# Subset population data to other areas
#
other.pop &lt;- popDF[popDF$type == 2, ]
#
# Subset survey data to slum areas
#
slum.data &lt;- indicatorsDF[indicatorsDF$type == 1, ]
#
# Subset survey data to other areas
#
other.data &lt;- indicatorsDF[indicatorsDF$type == 2, ]  
#
# Get population data for all areas in current zone
#
all.pop &lt;- popDF
#
# Get survey data for all areas in current zone
#
all.data &lt;- indicatorsDF
#
# Cycle through indicator codes
#
for(i in steerBoot$varList)
  {
  #
  # Select indicator and statistic pair
  #
  INDICATOR &lt;- i
  STATISTIC &lt;- steerBoot$varStatistic[steerBoot$varList == i]
  #
  # Report progress
  #
  cat(&quot;\n\n&quot;, INDICATOR, &quot;\n\n&quot;, sep = &quot;&quot;)
  #
  # Boostrap (BBW) for current indicator and statistic pair - slum
  #
  boot.slum &lt;- bootBW(x = slum.data, 
                      w = slum.pop, 
                      statistic = eval(parse(text = STATISTIC)), 
			       params = INDICATOR, 
			       outputColumns = INDICATOR, 
			       replicates = REPLICATES)
  #
  # Boostrap (BBW) for current indicator and statistic pair - other
  #
  boot.other &lt;- bootBW(x = other.data, 
			        w = other.pop, 
			        statistic = eval(parse(text = STATISTIC)), 
			        params = INDICATOR, 
			        outputColumns = INDICATOR, 
			        replicates = REPLICATES)
  #
  # Boostrap (BBW) for current indicator and statistic pair - total
  #
  boot.total &lt;- bootBW(x = all.data, 
			        w = all.pop, 
			        statistic = eval(parse(text = STATISTIC)), 
			        params = INDICATOR, 
			        outputColumns = INDICATOR, 
			        replicates = REPLICATES)     
  #
  # Concatenate various boot vectors into data.frame
  #
  boot.all &lt;- data.frame(boot.slum, boot.other, boot.total)
  names(boot.all) &lt;- c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Total&quot;)
  #
  # Create a row of results and insert quantiles of boot results
  #
  rowResult &lt;- c(unique(country), unique(ccode), unique(month), unique(year),
                 steerBoot$varNames[steerBoot$varList == i], i, &quot;Overall&quot;)
  for(j in names(boot.all))
    {
    rowResult &lt;- c(rowResult, quantile(boot.all[[j]], probs = c(0.5, 0.025, 0.975), na.rm = TRUE))
    }
  #
  # Record results
  #
  summaryTable &lt;- rbind(summaryTable, rowResult)
  }
#
# Tidy results (row names, column types, column names, and order of rows)
#
summaryTable &lt;- data.frame(summaryTable, row.names = 1:nrow(summaryTable))
#
# Convert estimate results into numeric
#
for(col in 8:ncol(summaryTable))
  {
  summaryTable[, col] &lt;- as.numeric(summaryTable[, col])
  }
#
# Rename summaryTable
#
names(summaryTable) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;, &quot;Month&quot;, &quot;Year&quot;,
	                    &quot;Indicator&quot;, &quot;Indicator Code&quot;, &quot;Survey Area&quot;,
           	          &quot;Slum Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Other Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Total Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;)
#
# Round-off estimates to the nearest 4 decimal places
#
summaryTable[ , 8:ncol(summaryTable)] &lt;- round(summaryTable[  , 8:ncol(summaryTable)], 4)
#
# Keep the rounding off of results for table output
#
options(scipen = 10)
#
# Save summaryTable as CSV file
#
#write.csv(x = summaryTable, 
#  	     file = paste(&quot;outputTables/surveyResultsBootOverall&quot;, 
#  	                  unique(ccode), unique(month), unique(year),
#  	                  &quot;.csv&quot;, sep = &quot;&quot;),
#	     row.names = FALSE)

write.csv(x = summaryTable, 
	     file = paste(&quot;outputTables/water/surveyResultsBootOverall&quot;, 
		             unique(ccode), unique(month), unique(year),
		             &quot;.csv&quot;, sep = &quot;&quot;),
	     row.names = FALSE)

#
# Reset scipen back to 0
#
options(scipen = 0)

}
</command>
							<property title="Estimate Overall" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="115" date="1510899093939" uid="c41b41699c502c86" x="1150" y="150" disabled="true">
							<command>
################################################################################
#                                                                              #
# Step 4a: Specify LQAS standards                                              #
#                                                                              #
#      This step asks the user to specify the parameters needed to             #
#      perform LQAS analysis on the indicators data.                           #
#                                                                              #
#      Specifically, the user is asked to specify an upper and a lower         #
#      standard (as a proportion i.e. standard ÷ 100) that will be used to     #
#      classify the indicator into either of three classes:                    #
#                                                                              #
#        &apos;Low&apos;      - indicator proportion is ≤ lower standard                 #
#        &apos;Moderate&apos; - indicator proportion is &gt; lower standard but ≤ upper     #
#                     standard                                                 #
#        &apos;High&apos;     - indicator proportion is &gt; upper standard                 #
#                                                                              #
#     The default (and our recommendeded) standards for use in WASH            #
#     indicators are:                                                          #
#                                                                              #
#        upper - 0.8 (80%)                                                     #
#        lower - 0.5 (50%)                                                     #
#                                                                              #
#     Remember that the standards should be specified as proportions (not      #
#     percentages.                                                             #
#                                                                              #
################################################################################</command>
							<property title="Run STEP 4a" shape="STAR">
								<comment state="opened" x="60" y="-20">STEP 4a: Specify LQAS    
         standards</comment>
							</property>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="116" date="1510899095245" uid="3756d982be514538" x="1090" y="510">
							<command>
################################################################################
#
# Perform bootstrap
#
################################################################################
#
# Subset steerIndicators to those that can be bootstrapped
#
steerBoot &lt;- subset(steerIndicators, varStatistic == &quot;oneMean&quot;)
#
# Extract number of replicates specified by user
#
REPLICATES &lt;- as.numeric(tclvalue(replicates))


################################################################################
#
# All results in a single output - Bootstrap
#
################################################################################
#
# Create empty container object for bootstrap results
#
summaryTable &lt;- NULL
#
# Cycle through each wealth quintile
#
for(i in unique(indicatorsDF$pQuintile))
  {
  #
  # Subset survey data to slum areas
  #
  slum.data &lt;- indicatorsDF[indicatorsDF$pQuintile == i &amp; indicatorsDF$type == 1, ]
  #
  # Subset survey data to other areas
  #
  other.data &lt;- indicatorsDF[indicatorsDF$pQuintile == i &amp; indicatorsDF$type == 2, ]  
  #
  # Get survey data for all areas in current zone
  #
  all.data &lt;- indicatorsDF[indicatorsDF$pQuintile == i, ]
  #
  # Subset population data to slum areas
  #
  slum.pop &lt;- popDF[popDF$psu %in% unique(slum.data$psu) &amp; popDF$type == 1, ]
  #
  # Subset population data to other areas
  #
  other.pop &lt;- popDF[popDF$psu %in% unique(other.data$psu) &amp; popDF$type == 2, ]
  #
  # Get population data for all areas in current zone
  #
  all.pop &lt;- popDF[popDF$psu %in% unique(all.data$psu), ]
  #
  # Cycle through indicator codes
  #
  for(j in steerBoot$varList)
    {
    #
    # Select indicator and statistic pair
    #
    INDICATOR &lt;- j
    STATISTIC &lt;- steerBoot$varStatistic[steerBoot$varList == j]
    #
    # Report progress
    #
    cat(&quot;\n\n&quot;, INDICATOR, &quot; : Wealth Quintile &quot;, i, &quot;\n\n&quot;, sep = &quot;&quot;)
    #
    # Boostrap (BBW) for current indicator and statistic pair - slum
    #
    boot.slum &lt;- bootBW(x = slum.data, 
                        w = slum.pop, 
                        statistic = eval(parse(text = STATISTIC)), 
			         params = INDICATOR, 
			         outputColumns = INDICATOR, 
			         replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - other
    #
    boot.other &lt;- bootBW(x = other.data, 
			          w = other.pop, 
			          statistic = eval(parse(text = STATISTIC)), 
			          params = INDICATOR, 
			          outputColumns = INDICATOR, 
			          replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - total
    #
    boot.total &lt;- bootBW(x = all.data, 
			          w = all.pop, 
			          statistic = eval(parse(text = STATISTIC)), 
			          params = INDICATOR, 
			          outputColumns = INDICATOR, 
			          replicates = REPLICATES)     
    #
    # Concatenate various boot vectors into data.frame
    #
    boot.all &lt;- data.frame(boot.slum, boot.other, boot.total)
    names(boot.all) &lt;- c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Total&quot;)
    #
    # Create a row of results and insert quantiles of boot results
    #
    rowResult &lt;- c(unique(country), unique(ccode), unique(month), unique(year),
                   steerBoot$varNames[steerBoot$varList == j], j, paste(&quot;Wealth Quintile &quot;, i, sep = &quot;&quot;))
    for(k in names(boot.all))
      {
	 rowResult &lt;- c(rowResult, quantile(boot.all[[k]], probs = c(0.5, 0.025, 0.975), na.rm = TRUE))
      }
    #
    # Record results
    #
    summaryTable &lt;- rbind(summaryTable, rowResult)
    }
  #
  # Tidy results (row names, column types, column names, and order of rows)
  #
  summaryTable &lt;- data.frame(summaryTable, row.names = 1:nrow(summaryTable))
  #
  # Convert estimate results into numeric
  #
  for(col in 8:ncol(summaryTable))
    {
    summaryTable[, col] &lt;- as.numeric(summaryTable[, col])
    }
  }
#
# Rename summaryTable
#
names(summaryTable) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;, &quot;Month&quot;, &quot;Year&quot;,
	                    &quot;Indicator&quot;, &quot;Indicator Code&quot;, &quot;Wealth Quintile&quot;, 
           	          &quot;Slum Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Other Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Total Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;)
#
# Round-off estimates to the nearest 4 decimal places
#
summaryTable[ , 8:ncol(summaryTable)] &lt;- round(summaryTable[  , 8:ncol(summaryTable)], 4)
#
# Keep the rounding off of results for table output
#
options(scipen = 10)
#
# Save summaryTable as CSV file
#
write.csv(x = summaryTable, 
  	     file = paste(&quot;outputTables/surveyResultsBootWealth&quot;, 
  	                  unique(ccode), unique(month), unique(year),
  	                  &quot;.csv&quot;, sep = &quot;&quot;),
	     row.names = FALSE)
#
# Reset scipen back to 0
#
options(scipen = 0)


################################################################################
#
# Perform bootstrap
#
################################################################################
#
# Subset steerIndicators to those that can be bootstrapped
#
steerBoot &lt;- subset(steerIndicators, varStatistic != &quot;oneMean&quot;)

################################################################################
#
# All results in a single output - Bootstrap
#
################################################################################


#
# Determine if steerBoot is empty and decide whether to continue with next step
#
if(nrow(steerBoot) &gt; 0)
  {	
  #
  # Create empty container object for bootstrap results
  #
  summaryTableX &lt;- NULL
  #
  # Cycle through each enumeration zones
  #
  for(i in unique(indicatorsDF$zone))
    {
    #
    # Subset population data to slum areas
    #
    slum.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 1, ]
    #
    # Subset population data to other areas
    #
    other.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 2, ]
    #
    # Subset survey data to slum areas
    #
    slum.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 1, ]
    #
    # Subset survey data to other areas
    #
    other.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 2, ]  
    #
    # Get population data for all areas in current zone
    #
    all.pop &lt;- popDF[popDF$zone == i, ]
    #
    # Get survey data for all areas in current zone
    #
    all.data &lt;- indicatorsDF[indicatorsDF$zone == i, ]
    #
    # Cycle through indicator codes
    #
    for(j in steerBoot$varList)
      {
      #
      # Concatenate various boot vectors into data.frame
      #
      boot.all &lt;- data.frame(matrix(nrow = 1, ncol = 3))
      names(boot.all) &lt;- c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Total&quot;)
      #
      # Create a row of results and insert quantiles of boot results
      #
      rowResult &lt;- c(unique(country), unique(ccode), unique(month), unique(year),
                     steerBoot$varNames[steerBoot$varList == j], j, paste(&quot;Survey Area &quot;, i, sep = &quot;&quot;))
      for(k in names(boot.all))
        {
	   rowResult &lt;- c(rowResult, rep(NA, 3))
	   }
      #
      # Record results
      #
      summaryTableX &lt;- rbind(summaryTableX, rowResult)
      }
    #
    # Tidy results (row names, column types, column names, and order of rows)
    #
    summaryTableX &lt;- data.frame(summaryTableX, row.names = 1:nrow(summaryTableX))
    #
    # Convert estimate results into numeric
    #
    for(col in 8:ncol(summaryTableX))
      {
      summaryTableX[, col] &lt;- as.numeric(summaryTableX[, col])
      }
    }
  #
  # Rename summaryTable 
  #
  names(summaryTableX) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;, &quot;Month&quot;, &quot;Year&quot;,
	                       &quot;Indicator&quot;, &quot;Indicator Code&quot;, &quot;Survey Area&quot;, 
	                       &quot;Slum Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                       &quot;Other Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                       &quot;Total Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;)
  #
  # Round-off estimates to the nearest 4 decimal places  
  #
  summaryTableX[ , 8:ncol(summaryTableX)] &lt;- round(summaryTableX[  , 8:ncol(summaryTableX)], 4)
  #
  # Combine results data.frame
  #
  summaryTable &lt;- data.frame(rbind(summaryTable, summaryTableX))
  #
  # Keep the rounding off of results for table output
  #
  options(scipen = 10)
  #
  # Save summaryTable as CSV file
  #
  write.csv(x = summaryTable, 
	       file = paste(&quot;outputTables/surveyResultsBoot&quot;, 
	                    unique(ccode), unique(month), unique(year),
	                    &quot;.csv&quot;, sep = &quot;&quot;),
	       row.names = FALSE)
  #
  # Reset scipen back to 0
  #
  options(scipen = 0)
  }
</command>
							<property title="Estimate by wealth" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="117" date="1510899095245" uid="ef0808c68a57e931" x="470" y="540">
							<command>
################################################################################
#                                                                              #
# Step 6: Create charts                                                        #
#                                                                              #
#      This step draws relevant histograms and pareto charts for               #
#      specific indicator sets.                                                #
#                                                                              #
################################################################################</command>
							<property title="Run STEP 6a" shape="STAR">
								<comment state="opened" x="60" y="-10">STEP 6a: Draw charts     </comment>
							</property>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="118" date="1510899093941" uid="808dd32bce484ca4" x="1050" y="150" disabled="true">
							<command>
################################################################################
#
# Specify LQAS classification parameters
#
################################################################################
#
# Set default upper and lower classification standards
#
upper.value &lt;- tclVar(&quot;0.8&quot;)
lower.value &lt;- tclVar(&quot;0.5&quot;)
#
# Create dialog box
#
choice &lt;- tktoplevel()
#
# Add title to dialog box
#
tkwm.title(choice, &quot;LQAS standards&quot;)
#
# Create input boxes
#
upper.entry &lt;- tkentry(choice, textvariable = upper.value)
lower.entry &lt;- tkentry(choice, textvariable = lower.value)
#
# RESET function for RESET button
#
reset &lt;- function()
  {
  #
  # Specify default parameters
  #
  tclvalue(upper.value) &lt;- &quot;0.8&quot;
  tclvalue(lower.value) &lt;- &quot;0.5&quot;
  }
#
# Create reset button
#
reset.button &lt;- tkbutton(choice, text = &quot;Reset&quot;, command = reset)
#
# SUBMIT function for SUBMIT button
#
submit &lt;- function() 
  {
  #
  # Extract values for upper and lower values
  #
  x &lt;- as.numeric(tclvalue(upper.value))
  y &lt;- as.numeric(tclvalue(lower.value))
  #
  # Prompt user with the upper and lower standards chosen and ask whether to continue
  #
  proceed &lt;- tkmessageBox(title = &quot;LQAS standards&quot;,
                          message = paste(&quot;Upper standard: &quot;, x * 100, &quot;%; Lower standard: &quot;, y * 100, &quot;%. Do you wish to use these standards?&quot;, sep = &quot;&quot;),
                          icon = &quot;question&quot;,
                          type = &quot;yesno&quot;)
  #
  # Determine if user responded not to continue with specified standards
  #
  if(tclvalue(proceed) == &quot;no&quot;)
    {
    #
    # Prompt user that no standards have been specified
    #
    tkmessageBox(title = &quot;LQAS standards&quot;,
                 message = &quot;No standards specified. Specify upper and lower standards&quot;,
                 icon = &quot;warning&quot;,
                 type = &quot;ok&quot;)
    }
  #
  # Determine if user accepted the specified standards
  #
  if(tclvalue(proceed) == &quot;yes&quot;)
    {
    #
    # Close dialog box
    #
    tkdestroy(choice)
    }
  }
#
# Create submit button
#
submit.button &lt;- tkbutton(choice, text = &quot;Submit&quot;, command = submit)
#
# Layout the options and buttons on dialog box
# 
tkgrid(tklabel(choice, text = &quot;Specify upper and lower standards&quot;), columnspan = 2, pady = 5)
tkgrid(tklabel(choice, text = &quot;Upper Standard:&quot;), upper.entry, pady = 5, padx = 5)
tkgrid(tklabel(choice, text = &quot;Lower Standard:&quot;), lower.entry, pady = 5, padx = 5)
tkgrid(submit.button, reset.button, pady = 5, padx = 5)

tkwait.window(choice)


 </command>
							<property title="Specify LQAS parameters" shape="INPUT"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="119" date="1510899093940" uid="75b85e8be84af23" x="530" y="360">
							<command>################################################################################
#
# Convert data to long format
#
################################################################################
#
# create temporary data.frames for single results
#
temp1 &lt;- subset(waterCollectDF, select = c(-water9b:-water9h))
names(temp1) &lt;- c(&quot;uniqueID&quot;, &quot;psu&quot;, &quot;country&quot;, &quot;ccode&quot;, &quot;zone&quot;, &quot;type&quot;, &quot;quadrat&quot;, &quot;hhid&quot;, &quot;longitude&quot;, &quot;latitude&quot;, &quot;pQuintile&quot;, &quot;collect&quot;)

temp2 &lt;- subset(waterCollectDF, select = c(-water9a, -water9c:-water9h))
names(temp2) &lt;- c(&quot;uniqueID&quot;, &quot;psu&quot;, &quot;country&quot;, &quot;ccode&quot;, &quot;zone&quot;, &quot;type&quot;, &quot;quadrat&quot;, &quot;hhid&quot;, &quot;longitude&quot;, &quot;latitude&quot;, &quot;pQuintile&quot;, &quot;collect&quot;)

temp3 &lt;- subset(waterCollectDF, select = c(-water9a:-water9b, -water9d:-water9h))
names(temp3) &lt;- c(&quot;uniqueID&quot;, &quot;psu&quot;, &quot;country&quot;, &quot;ccode&quot;, &quot;zone&quot;, &quot;type&quot;, &quot;quadrat&quot;, &quot;hhid&quot;, &quot;longitude&quot;, &quot;latitude&quot;, &quot;pQuintile&quot;, &quot;collect&quot;)

temp4 &lt;- subset(waterCollectDF, select = c(-water9a:-water9c, -water9e:-water9h))
names(temp4) &lt;- c(&quot;uniqueID&quot;, &quot;psu&quot;, &quot;country&quot;, &quot;ccode&quot;, &quot;zone&quot;, &quot;type&quot;, &quot;quadrat&quot;, &quot;hhid&quot;, &quot;longitude&quot;, &quot;latitude&quot;, &quot;pQuintile&quot;, &quot;collect&quot;)

temp5 &lt;- subset(waterCollectDF, select = c(-water9a:-water9c, -water9e:-water9h))
names(temp5) &lt;- c(&quot;uniqueID&quot;, &quot;psu&quot;, &quot;country&quot;, &quot;ccode&quot;, &quot;zone&quot;, &quot;type&quot;, &quot;quadrat&quot;, &quot;hhid&quot;, &quot;longitude&quot;, &quot;latitude&quot;, &quot;pQuintile&quot;, &quot;collect&quot;)

temp6 &lt;- subset(waterCollectDF, select = c(-water9a:-water9d, -water9f:-water9h))
names(temp6) &lt;- c(&quot;uniqueID&quot;, &quot;psu&quot;, &quot;country&quot;, &quot;ccode&quot;, &quot;zone&quot;, &quot;type&quot;, &quot;quadrat&quot;, &quot;hhid&quot;, &quot;longitude&quot;, &quot;latitude&quot;, &quot;pQuintile&quot;, &quot;collect&quot;)

temp7 &lt;- subset(waterCollectDF, select = c(-water9a:-water9e, -water9g:-water9h))
names(temp7) &lt;- c(&quot;uniqueID&quot;, &quot;psu&quot;, &quot;country&quot;, &quot;ccode&quot;, &quot;zone&quot;, &quot;type&quot;, &quot;quadrat&quot;, &quot;hhid&quot;, &quot;longitude&quot;, &quot;latitude&quot;, &quot;pQuintile&quot;, &quot;collect&quot;)

temp8 &lt;- subset(waterCollectDF, select = c(-water9a:-water9f, -water9h))
names(temp8) &lt;- c(&quot;uniqueID&quot;, &quot;psu&quot;, &quot;country&quot;, &quot;ccode&quot;, &quot;zone&quot;, &quot;type&quot;, &quot;quadrat&quot;, &quot;hhid&quot;, &quot;longitude&quot;, &quot;latitude&quot;, &quot;pQuintile&quot;, &quot;collect&quot;)

temp9 &lt;- subset(waterCollectDF, select = -water9a:-water9g)
names(temp9) &lt;- c(&quot;uniqueID&quot;, &quot;psu&quot;, &quot;country&quot;, &quot;ccode&quot;, &quot;zone&quot;, &quot;type&quot;, &quot;quadrat&quot;, &quot;hhid&quot;, &quot;longitude&quot;, &quot;latitude&quot;, &quot;pQuintile&quot;, &quot;collect&quot;)

temp &lt;- data.frame(rbind(temp1, temp2, temp3, temp4, temp5, temp6, temp7, temp8, temp9))
#
# Remove NAs
#
temp &lt;- temp[!is.na(temp$collect), ]
temp &lt;- subset(temp, collect != &quot;Don&apos;t know/no answer/not applicable&quot;)
temp &lt;- subset(temp, collect != &quot;Source inside house&quot;)
#
#
#
temp$zone &lt;- with(temp, ifelse(zone == 1, &quot;Survey Area 1&quot;,
                          ifelse(zone == 2, &quot;Survey Area 2&quot;,
                            ifelse(zone == 3, &quot;Survey Area 3&quot;,
                              ifelse(zone == 4, &quot;Survey Area 4&quot;,
                                ifelse(zone == 5, &quot;Survey Area 5&quot;,
                                  ifelse(zone == 6, &quot;Survey Area 6&quot;,
                                    ifelse(zone == 7, &quot;Survey Area 7&quot;,
                                      ifelse(zone == 8, &quot;Survey Area 8&quot;, &quot;Survey Area 9&quot;)))))))))
#
#
#
temp$type &lt;- with(temp, ifelse(type == 1, &quot;Slum&quot;, &quot;Other&quot;))
#
#
#
temp &lt;- temp[order(temp$collect), ]
#
#
#
temp$collect &lt;- with(temp, factor(x = collect, levels = c(&quot;Adult men&quot;, &quot;Adult women&quot;, 
                                                          &quot;Boys _15&quot;, &quot;Girls _15&quot;, 
                                                          &quot;Whole family&quot;)))
#
#
#
temp$type &lt;- with(temp, factor(x = type, levels = c(&quot;Slum&quot;, &quot;Other&quot;)))                                                          
#
#
#
waterCollectLong &lt;- temp


################################################################################
#
#
#
################################################################################
#
#
#
basePlot &lt;- ggplot(waterCollectLong, mapping = aes(x = type, fill = collect))
#
#
#
barPlot &lt;- geom_bar(position = &quot;stack&quot;, alpha = 0.8)
#
#
#
barFacet &lt;- facet_wrap( ~ zone, ncol = 3)
#
#
#
barFill &lt;- scale_fill_manual(name = &quot;Household Water Collector/s&quot;,
                             labels = c(&quot;Adult Men&quot;, &quot;Adult Women&quot;, &quot;Boys&quot;, &quot;Girls&quot;, &quot;Whole family&quot;),
                             values = collectColour) 

#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Area Type&quot;, y = &quot;&quot;)

################################################################################
#
# Plot water collectors by survey area grouped by type
#
################################################################################
#
# Open graphics device
#
png(filename = paste(&quot;outputFigures/charts/waterCollectorByArea&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 8, height = 4 * ceiling(length(unique(waterCollectLong$zone)) / 3), units = &quot;in&quot;,
    res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFacet + barFill + barLabels + theme_wsup + theme(legend.position = &quot;top&quot;)
#
# Close graphics device
#
dev.off()


################################################################################
#
#
#
################################################################################
#
#
#
basePlot &lt;- ggplot(waterCollectLong, mapping = aes(x = zone, fill = collect))
#
#
#
barPlot &lt;- geom_bar(position = &quot;stack&quot;, alpha = 0.8)
#
#
#
barFacet &lt;- facet_wrap( ~ type, ncol = 3)
#
#
#
barFill &lt;- scale_fill_manual(name = &quot;Household Water Collector/s&quot;,
                             labels = c(&quot;Adult Men&quot;, &quot;Adult Women&quot;, &quot;Boys&quot;, &quot;Girls&quot;, &quot;Whole family&quot;),
                             values = collectColour) 

#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Survey Area&quot;, y = &quot;&quot;)
#
#
#
xLabels &lt;- scale_x_discrete(labels = 1:length(unique(waterCollectLong$zone)))


################################################################################
#
# Plot water collectors by survey area grouped by area
#
################################################################################
#
# Open graphics device
#
png(filename = paste(&quot;outputFigures/charts/waterCollectorByType&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 10, height = 4, units = &quot;in&quot;,
    res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFacet + barFill + barLabels + xLabels + theme_wsup + theme(legend.position = &quot;top&quot;)
#
# Close graphics device
#
dev.off()



################################################################################
#
#
#
################################################################################
#
#
#
basePlot &lt;- ggplot(waterCollectLong, mapping = aes(x = pQuintile, fill = collect))
#
#
#
barPlot &lt;- geom_bar(position = &quot;stack&quot;, alpha = 0.8)
#
#
#
barFacet &lt;- facet_wrap( ~ zone, ncol = 3)
#
#
#
barFill &lt;- scale_fill_manual(name = &quot;Household Water Collector/s&quot;,
                             labels = c(&quot;Adult Men&quot;, &quot;Adult Women&quot;, &quot;Boys&quot;, &quot;Girls&quot;, &quot;Whole family&quot;),
                             values = collectColour) 

#
# Axis labels
#
barLabels &lt;- labs(x = &quot;Wealth Quintile&quot;, y = &quot;&quot;)
#
#
#
#xLabels &lt;- scale_x_discrete(labels = 1:5)


################################################################################
#
# Plot water collectors by survey area grouped by quintiles
#
################################################################################
#
# Open graphics device
#
png(filename = paste(&quot;outputFigures/charts/waterCollectorByQuintile&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
    width = 12, height = 4 * (length(unique(waterCollectLong$zone)) / 3), units = &quot;in&quot;,
    res = 200)
#
# Assemble plotting layers
#
basePlot + barPlot + barFacet + barFill + barLabels + xlim(c(1,5)) + theme_wsup + theme(legend.position = &quot;top&quot;)
#
# Close graphics device
#
dev.off()</command>
							<property title="waterCollect" shape="CHART"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="120" date="1510899093940" uid="1e6776f5cc2e0495" x="470" y="650">
							<command>
################################################################################
#                                                                              #
# Step 6: Map indicators                                                       #
#                                                                              #
#      This step maps the various indicator sets based on the results of the   #
#      analysis in Step 4.                                                     #
#                                                                              #
################################################################################</command>
							<property title="Run STEP 6b" shape="STAR">
								<comment state="opened" x="60" y="-20">STEP 6b: Draw indicator  
         maps - 
         choropleth</comment>
							</property>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="121" date="1510899095244" uid="39fb5e557d3e302d" x="620" y="180">
							<command>
################################################################################
#
# Perform bootstrap
#
################################################################################
#
# Subset steerIndicators to those that can be bootstrapped
#
steerBoot &lt;- subset(steerIndicators, varStatistic == &quot;oneMean&quot;)
#
# Extract number of replicates specified by user
#
REPLICATES &lt;- as.numeric(tclvalue(replicates))


################################################################################
#
# All results in a single output - Bootstrap
#
################################################################################
#
# Create empty container object for bootstrap results
#
summaryTable &lt;- NULL
#
# Cycle through each enumeration zones
#
for(i in unique(indicatorsDF$zone))
  {
  #
  # Subset population data to slum areas
  #
  slum.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 1, ]
  #
  # Subset population data to other areas
  #
  other.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 2, ]
  #
  # Subset survey data to slum areas
  #
  slum.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 1, ]
  #
  # Subset survey data to other areas
  #
  other.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 2, ]  
  #
  # Get population data for all areas in current zone
  #
  all.pop &lt;- popDF[popDF$zone == i, ]
  #
  # Get survey data for all areas in current zone
  #
  all.data &lt;- indicatorsDF[indicatorsDF$zone == i, ]
  #
  # Cycle through indicator codes
  #
  for(j in steerBoot$varList)
    {
    #
    # Select indicator and statistic pair
    #
    INDICATOR &lt;- j
    STATISTIC &lt;- steerBoot$varStatistic[steerBoot$varList == j]
    #
    # Report progress
    #
    cat(&quot;\n\n&quot;, INDICATOR, &quot; : Survey Area &quot;, i, &quot;\n\n&quot;, sep = &quot;&quot;)
    #
    # Boostrap (BBW) for current indicator and statistic pair - slum
    #
    boot.slum &lt;- bootBW(x = slum.data, 
                        w = slum.pop, 
                        statistic = eval(parse(text = STATISTIC)), 
			         params = INDICATOR, 
			         outputColumns = INDICATOR, 
			         replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - other
    #
    boot.other &lt;- bootBW(x = other.data, 
			          w = other.pop, 
			          statistic = eval(parse(text = STATISTIC)), 
			          params = INDICATOR, 
			          outputColumns = INDICATOR, 
			          replicates = REPLICATES)
    #
    # Boostrap (BBW) for current indicator and statistic pair - total
    #
    boot.total &lt;- bootBW(x = all.data, 
			          w = all.pop, 
			          statistic = eval(parse(text = STATISTIC)), 
			          params = INDICATOR, 
			          outputColumns = INDICATOR, 
			          replicates = REPLICATES)     
    #
    # Concatenate various boot vectors into data.frame
    #
    boot.all &lt;- data.frame(boot.slum, boot.other, boot.total)
    names(boot.all) &lt;- c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Total&quot;)
    #
    # Create a row of results and insert quantiles of boot results
    #
    rowResult &lt;- c(unique(country), unique(ccode), steerBoot$varNames[steerBoot$varList == j], j, paste(&quot;Survey Area &quot;, i, sep = &quot;&quot;))
    for(k in names(boot.all))
      {
	 rowResult &lt;- c(rowResult, quantile(boot.all[[k]], probs = c(0.5, 0.025, 0.975), na.rm = TRUE))
      }
    #
    # Record results
    #
    summaryTable &lt;- rbind(summaryTable, rowResult)
    }
  #
  # Tidy results (row names, column types, column names, and order of rows)
  #
  summaryTable &lt;- data.frame(summaryTable, row.names = 1:nrow(summaryTable))
  #
  # Convert estimate results into numeric
  #
  for(col in 6:ncol(summaryTable))
    {
    summaryTable[, col] &lt;- as.numeric(summaryTable[, col])
    }
  }
#
# Rename summaryTable
#
names(summaryTable) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;,
	                    &quot;Indicator&quot;, &quot;Indicator Code&quot;, &quot;Survey Area&quot;, 
           	          &quot;Slum Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Other Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                    &quot;Total Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;)
#
# Round-off estimates to the nearest 4 decimal places
#
summaryTable[ , 6:ncol(summaryTable)] &lt;- round(summaryTable[  , 6:ncol(summaryTable)], 4)
#
# Keep the rounding off of results for table output
#
options(scipen = 10)
#
# Save summaryTable as CSV file
#
write.csv(x = summaryTable, 
  	     file = paste(&quot;outputTables/surveyResultsBoot&quot;, unique(ccode), &quot;.csv&quot;, sep = &quot;&quot;),
	     row.names = FALSE)
#
# Reset scipen back to 0
#
options(scipen = 0)


################################################################################
#
# Perform bootstrap
#
################################################################################
#
# Subset steerIndicators to those that can be bootstrapped
#
steerBoot &lt;- subset(steerIndicators, varStatistic != &quot;oneMean&quot;)

################################################################################
#
# All results in a single output - Bootstrap
#
################################################################################
#
# Create empty container object for bootstrap results
#
summaryTableX &lt;- NULL
#
# Cycle through each enumeration zones
#
for(i in unique(indicatorsDF$zone))
  {
  #
  # Subset population data to slum areas
  #
  slum.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 1, ]
  #
  # Subset population data to other areas
  #
  other.pop &lt;- popDF[popDF$zone == i &amp; popDF$type == 2, ]
  #
  # Subset survey data to slum areas
  #
  slum.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 1, ]
  #
  # Subset survey data to other areas
  #
  other.data &lt;- indicatorsDF[indicatorsDF$zone == i &amp; indicatorsDF$type == 2, ]  
  #
  # Get population data for all areas in current zone
  #
  all.pop &lt;- popDF[popDF$zone == i, ]
  #
  # Get survey data for all areas in current zone
  #
  all.data &lt;- indicatorsDF[indicatorsDF$zone == i, ]
  #
  # Cycle through indicator codes
  #
  for(j in steerBoot$varList)
    {
    #
    # Concatenate various boot vectors into data.frame
    #
    boot.all &lt;- data.frame(matrix(nrow = 1, ncol = 3))
    names(boot.all) &lt;- c(&quot;Slum&quot;, &quot;Other&quot;, &quot;Total&quot;)
    #
    # Create a row of results and insert quantiles of boot results
    #
    rowResult &lt;- c(unique(country), unique(ccode), steerBoot$varNames[steerBoot$varList == j], j, paste(&quot;Survey Area &quot;, i, sep = &quot;&quot;))
    for(k in names(boot.all))
      {
	 rowResult &lt;- c(rowResult, rep(NA, 3))
	 }
    #
    # Record results
    #
    summaryTableX &lt;- rbind(summaryTableX, rowResult)
    }
  #
  # Tidy results (row names, column types, column names, and order of rows)
  #
  summaryTableX &lt;- data.frame(summaryTableX, row.names = 1:nrow(summaryTableX))
  #
  # Convert estimate results into numeric
  #
  for(col in 6:ncol(summaryTableX))
    {
    summaryTableX[, col] &lt;- as.numeric(summaryTableX[, col])
    }
 }
#
# Rename summaryTable
#
names(summaryTableX) &lt;- c(&quot;Country&quot;, &quot;Country Code&quot;,
	                     &quot;Indicator&quot;, &quot;Indicator Code&quot;, &quot;Survey Area&quot;, 
	                     &quot;Slum Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                     &quot;Other Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;, 
	                     &quot;Total Estimate&quot;, &quot;95% LCL&quot;, &quot;95% UCL&quot;)
#
# Round-off estimates to the nearest 4 decimal places
#
summaryTableX[ , 6:ncol(summaryTableX)] &lt;- round(summaryTableX[  , 6:ncol(summaryTableX)], 4)
#
# Combine results data.frame
#
summaryTable &lt;- data.frame(rbind(summaryTable, summaryTableX))
#
# Keep the rounding off of results for table output
#
options(scipen = 10)
#
# Save summaryTable as CSV file
#
write.csv(x = summaryTable, 
	     file = paste(&quot;outputTables/surveyResultsBoot&quot;, unique(ccode), &quot;.csv&quot;, sep = &quot;&quot;),
	     row.names = FALSE)
#
# Reset scipen back to 0
#
options(scipen = 0)

</command>
							<property title="Estimate" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="122" date="1510899093940" uid="2e6f78c1c427d40b" x="1050" y="220" disabled="true">
							<command>
################################################################################
#
# Specify bootstrapping parameters
#
################################################################################
#
# Set default number of replicates
#
replicates &lt;- tclVar(&quot;399&quot;)
#
# Create dialog box
#
choice &lt;- tktoplevel()
#
# Add title to dialog box
#
tkwm.title(choice, &quot;Bootstrap replicates&quot;)
#
# Create input box
#
replicates.entry &lt;- tkentry(choice, textvariable = replicates)
#
# RESET function for RESET button
#
reset &lt;- function()
  {
  #
  # Reset user input back to default
  #
  tclvalue(replicates) &lt;- &quot;399&quot;
  }
#
# Create reset button
#
reset.button &lt;- tkbutton(choice, text = &quot;Reset&quot;, command = reset)
#
# SUBMIT function for SUBMIT button
#
submit &lt;- function() 
  {
  #
  # Extract user input
  #
  x &lt;- as.numeric(tclvalue(replicates))
  #
  # Prompt user with input specified and ask whether to proceed
  #
  proceed &lt;- tkmessageBox(title = &quot;Bootstrap replicates&quot;,
                          message = paste(&quot;You specified &quot;, x, &quot; replicates for bootstrapping. Do you wish to continue?&quot;, sep = &quot;&quot;),
                          icon = &quot;question&quot;,
                          type = &quot;yesno&quot;)
  #
  # Determine if user does not want to continue with specified values
  #
  if(tclvalue(proceed) == &quot;no&quot;)
    {
    #
    # Prompt user that no replicates specified
    #
    tkmessageBox(title = &quot;Bootstrap replicates&quot;,
                 message = &quot;No number of replicates specified. Specify number of replicates&quot;,
                 icon = &quot;warning&quot;,
                 type = &quot;ok&quot;)
    }
  #
  # Determine if user wishes to proceed with specified replicates
  #
  if(tclvalue(proceed) == &quot;yes&quot;)
    {
    #
    # Close dialog box
    #
    tkdestroy(choice)
    }
  }
#
# Create submit button
#
submit.button &lt;- tkbutton(choice, text = &quot;Submit&quot;, command = submit)
#
# Create layout of input boxes and control buttons
# 
tkgrid(tklabel(choice, text = &quot;Specify number of bootstrap replicates&quot;), columnspan = 2, pady = 5)
tkgrid(tklabel(choice, text = &quot;Number of replicates:&quot;), replicates.entry, pady = 5, padx = 5)
tkgrid(submit.button, reset.button, pady = 5, padx = 5)

tkwait.window(choice)


 </command>
							<property title="Specify boot parameters" shape="INPUT"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="123" date="1510899093941" uid="e7cde412352f30b8" x="810" y="370">
							<command>#
# Extract country choice
#
country &lt;- as.character(tclvalue(choice.value))
#
# Determine country code
#
ccode &lt;- ifelse(country == &quot;Bangladesh&quot;, &quot;BGD&quot;,
	      ifelse(country == &quot;Ghana&quot;, &quot;GHA&quot;,
		   ifelse(country == &quot;India&quot;, &quot;IND&quot;,
			ifelse(country == &quot;Kenya&quot;, &quot;KEN&quot;,
			  ifelse(country == &quot;Madagascar&quot;, &quot;MDG&quot;, &quot;ZMB&quot;)))))


################################################################################
#
#  Select and read indicator steering file: Accepts CSV data files
#
################################################################################
#
# Prompt user to supply indicator steering file
#
tkmessageBox(title = &quot;Load file&quot;,
             message = &quot;Select indicators steering file&quot;, 
	        icon = &quot;info&quot;, 
	        type = &quot;ok&quot;)
#
# Cycle through indicator steering file selection prompts
#
repeat
  {
  #
  # Cycle through indicator steering file selection prompts when no file is selected
  #
  repeat
    {
    #
    # Select indicator steering file
    #
    fileName &lt;- tclvalue(tkgetOpenFile())
    #
    # Determine if a indicator steering file has been selected
    #	
    if(!nchar(fileName)) 
      {
      #
      # Prompt user that no file has been selected
      #
      error1 &lt;- tkmessageBox(title = &quot;Error&quot;,
				         message = &quot;No file was selected! Please try again.&quot;,
				         icon = &quot;error&quot;,
				         type = &quot;retrycancel&quot;)
      }
    #
    # Break repeat once any file has been selected
    #	
    if(nchar(fileName) &gt; 0) break
    #
    # Break repeat if user cancels option to select file
    #
    if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
    } 
  #
  # Break repeat if user cancels option to select file
  #
  if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  #
  # Try to read indicator steering file based on filename provided by user
  #	
  steerIndicators &lt;- try(expr = read.csv(file = fileName, header = TRUE, sep = &quot;,&quot;), 
		               silent = TRUE)
  #
  # Check if indicator steering file provided is in correct format (CSV file)
  #
  if(exists(&quot;steerIndicators&quot;) &amp;&amp; class(steerIndicators) == &quot;try-error&quot;)
    {
    #
    # Prompt user that file format is incorrect
    #
    error2 &lt;- tkmessageBox(title = &quot;Error&quot;,
			            message = paste(&quot;Problem reading file &apos;&quot;, basename(fileName), &quot;&apos;. Please try again&quot;, sep = &quot;,&quot;),
			            icon = &quot;error&quot;,
			            type = &quot;retrycancel&quot;)
    }
  #
  # Break repeat once selected indicator steering file is in correct format
  #
  if(exists(&quot;steerIndicators&quot;) &amp;&amp; class(steerIndicators) != &quot;try-error&quot;) break
  #
  # Break repeat if user cancels option to retry providing a new file
  #
  if(exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;) break
  }
#
# Determine if user cancels option to select file or cancels option to retry providing a new file
#
if((exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) | (exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;))
  {
  #
  # Prompt user that no file has been loaded
  #
  tkmessageBox(title = &quot;Warning&quot;,
		     message = &quot;You have not loaded any data file&quot;,
		     icon = &quot;warning&quot;,
		     type = &quot;ok&quot;)
  }
#
# Determine user has successfully selected and loaded an appropriate data file
#
if(exists(&quot;steerIndicators&quot;) &amp;&amp; class(steerIndicators) != &quot;try-error&quot;)
  {
  #
  # Prompt use of the filename of the indicator steering file file selected
  #
  tkmessageBox(title = &quot;Success!&quot;,
     		message = paste(&quot;You have loaded the data file named &apos;&quot;, basename(fileName), &quot;&apos;.&quot;, sep = &quot;&quot;),
		     icon = &quot;info&quot;,
		     type = &quot;ok&quot;)
  }
#
# Clean-up filename
#
rm(fileName)
#
# Clean-up error1 if present
#
if(exists(&quot;error1&quot;))
  {
  rm(error1)
  }
#
# Clean-up error2 if present
#
if(exists(&quot;error2&quot;))
  {
  rm(error2)
  }




################################################################################
#
#  Select and read results data: Accepts CSV data files
#
################################################################################
#
# Prompt user to supply indicator data file
#
tkmessageBox(title = &quot;Load file&quot;,
	        message = &quot;Select results data file&quot;, 
	        icon = &quot;info&quot;, 
	        type = &quot;ok&quot;)
#
# Cycle through results data file selection prompts
#
repeat
  {
  #
  # Cycle through results data file selection prompts when no file is selected
  #
  repeat
    {
    #
    # Select results data file
    #
    fileName &lt;- tclvalue(tkgetOpenFile())
    #
    # Determine if a results data file has been selected
    #	
    if(!nchar(fileName)) 
      {
      #
      # Prompt user that no file has been selected
      #
      error1 &lt;- tkmessageBox(title = &quot;Error&quot;,
				         message = &quot;No file was selected! Please try again.&quot;,
				         icon = &quot;error&quot;,
				         type = &quot;retrycancel&quot;)
      }
    #
    # Break repeat once any file has been selected
    #	
    if(nchar(fileName) &gt; 0) break
    #
    # Break repeat if user cancels option to select file
    #
    if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  }
  #
  # Break repeat if user cancels option to select file
  #
  if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  #
  # Try to read results data file based on filename provided by user
  #
  surveyResults &lt;- try(expr = read.csv(file = fileName, header = TRUE, sep = &quot;,&quot;), 
		             silent = TRUE)
  #
  # Check if results data file provided is in correct format (CSV file)
  #
  if(exists(&quot;surveyResults&quot;) &amp;&amp; class(surveyResults) == &quot;try-error&quot;)
    {
    #
    # Prompt user that file format is incorrect
    #
    error2 &lt;- tkmessageBox(title = &quot;Error&quot;,
			            message = paste(&quot;Problem reading file &apos;&quot;, basename(fileName), &quot;&apos;. Please try again&quot;, sep = &quot;,&quot;),
			            icon = &quot;error&quot;,
			            type = &quot;retrycancel&quot;)
    }
  #
  # Break repeat once selected results data file is in correct format
  #
  if(exists(&quot;surveyResults&quot;) &amp;&amp; class(surveyResults) != &quot;try-error&quot;) break
  #
  # Break repeat if user cancels option to retry providing a new file
  #
  if(exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;) break
  }
#
# Determine if user cancels option to select file or cancels option to retry providing a new file
#
if((exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) | (exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;))
  {
  #
  # Prompt user that no file has been loaded
  #
  tkmessageBox(title = &quot;Warning&quot;,
 		     message = &quot;You have not loaded any data file&quot;,
		     icon = &quot;warning&quot;,
		     type = &quot;ok&quot;)
  }
#
# Determine user has successfully selected and loaded an appropriate data file
#
if(exists(&quot;surveyResults&quot;) &amp;&amp; class(surveyResults) != &quot;try-error&quot;)
  {
  #
  # Prompt use of the filename of the results data file file selected
  #
  tkmessageBox(title = &quot;Success!&quot;,
		     message = paste(&quot;You have loaded the data file named &apos;&quot;, basename(fileName), &quot;&apos;.&quot;, sep = &quot;&quot;),
		     icon = &quot;info&quot;,
		     type = &quot;ok&quot;)
  }
#
# Clean-up filename
#
rm(fileName)
#
# Clean-up error1 if present
#
if(exists(&quot;error1&quot;))
  {
  rm(error1)
  }
#
# Clean-up error2 if present
#
if(exists(&quot;error2&quot;))
  {
  rm(error2)
  }



################################################################################
#
# Create base HTML with frames and menu file 
#
################################################################################
#
# Select country HTML
#
selectCountryHTML(reportTitle = &quot;WSUP Urban Water and Sanitation Survey&quot;)
#
# Create HTML frameset for results
#
newIndexHTML(fileName = unique(ccode), reportTitle = &quot;WSUP Urban Water and Sanitation Survey&quot;, varFile = unique(steerIndicators$varFile)[1])
#
# Create HTML menu file
#
newMenuHTML(fileName = unique(ccode))
#
# Add menu for population pyramid
#
addMenuHTML(varFile = &quot;population&quot;, fileName = unique(ccode), varTitle = &quot;Population&quot;)
#
# Cycle through steering file
#
for(i in 1:length(unique(steerIndicators$varSet)))
  {
  #
  # Add indicator menu
  #
  addMenuHTML(varFile = unique(steerIndicators$varFile)[i], fileName = unique(ccode), varTitle = unique(steerIndicators$varTitle)[i])
  }
#
# Close HTML menu
#
endMenuHTML(unique(ccode))



################################################################################
#
# Create results pages
#
################################################################################
#
# Insert population pyramid plot
#
sink(paste(&quot;report/results/population&quot;, &quot;-&quot;, unique(ccode), &quot;.html&quot;, sep = &quot;&quot;))
#
#
#
startHTML(label = &quot;Population&quot;)
#
#
#
insertFigureHTML(label = &quot;Population pyramid by survey area&quot;,
                 filename = paste(&quot;../../outputFigures/charts/agePyramidSurveyArea&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;))
#
# Close HTML file
#
stopHTML()
#
# Close HTML output stream
#
sink()
#
# Cycle through each variable set
#
for(i in 1:length(unique(steerIndicators$varFile)))
  {
  #
  # Open results file stream
  #
  sink(paste(&quot;report/results/&quot;, unique(steerIndicators$varFile)[i], &quot;-&quot;, unique(ccode), &quot;.html&quot;, sep = &quot;&quot;))
  #
  # Start an HTML file for current variable set
  #  
  startHTML(label = unique(steerIndicators$varTitle)[i])
  #
  # Subset results table to current indicator set
  #    
  temp &lt;- subset(surveyResults, indicatorCode %in% unique(steerIndicators$varList[steerIndicators$varSet == unique(steerIndicators$varSet)[i]]))
  #
  # Subset steerIndicators to match current indicator set
  #
  currentSteer &lt;- subset(steerIndicators, varFile == unique(steerIndicators$varFile)[i])
  #
  # Cycle through variable code list of current indicator set
  #
  for(j in currentSteer$varList)
    {
    #
    # Determine if current indicator requires a pareto or histogram function
    #
    if(currentSteer$varFunction[currentSteer$varList == j] == &quot;pareto&quot; | currentSteer$varFunction[currentSteer$varList == j] == &quot;histogram&quot;)
      {
      #
      # Cylce through survey areas
      #
      for(k in 1:length(unique(temp$surveyArea)))
        {
        #
        # Insert pareto chart or histogram of slum, other and total for each survey area
        #
        insertFigureHTML(label = paste(currentSteer$varNames[currentSteer$varList == j], &quot;-&quot;, &quot;Survey Area&quot;, k, sep = &quot; &quot;),
                         filename = paste(&quot;../../outputFigures/charts/&quot;, j, &quot;SurveyArea&quot;, k, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;))
        }
      }
    #
    # Determine if current indicator requires a histogram (mean)
    #
    if(currentSteer$varFunction[currentSteer$varList == j] == &quot;histogram&quot;)
      {
      #
      # Insert map of mean indicator
      #
      insertFigureHTML(label = steerIndicators$varNames[steerIndicators$varList == j],
                       filename = paste(&quot;../../outputFigures/maps/&quot;, j, &quot;Mean&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;))
      #
      # Start an HTML table for current indicator
      #
      startTableHTML(label = steerIndicators$varNames[steerIndicators$varList == j])
      #
      # Subset results to current indicator
      #
      currentTable &lt;- subset(temp, indicatorCode == j)
      #
      # Cycle through rows of the results for current indicator
      #
      for(l in 1:nrow(currentTable))
        {
        #
        # Create row of results
        #
        rowResults &lt;- currentTable[l, c(&quot;slumTotal&quot;, &quot;slumEst&quot;, &quot;slumLCL&quot;, &quot;slumUCL&quot;, 
                                        &quot;otherTotal&quot;, &quot;otherEst&quot;, &quot;otherLCL&quot;, &quot;otherUCL&quot;,
                                        &quot;total&quot;, &quot;totalEst&quot;, &quot;totalLCL&quot;, &quot;totalUCL&quot;)]
        #
	   # Insert indicator results into the HTML table 
        #
	   tableRowHTMLmean(label = currentTable$surveyArea[l], 
				     x = c(rowResults[,1], rowResults[,2], rowResults[,3], 
					      rowResults[,4], rowResults[,5], rowResults[,6], 
					      rowResults[,7], rowResults[,8], rowResults[,9], 
					      rowResults[,10], rowResults[,11], rowResults[,12]))
        }		          
      #
      # Close table HTML
      #
      stopTableHTML()
      }      
    #
    # Determine if current indicator requires a proportion
    #
    if(currentSteer$varFunction[currentSteer$varList == j] == &quot;proportion&quot;)
      {
      #
      # Insert map of proportion indicator
      #
      insertFigureHTML(label = steerIndicators$varNames[steerIndicators$varList == j],
                       filename = paste(&quot;../../outputFigures/maps/&quot;, j, &quot;Est&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;))
      #
      # Start an HTML table for current indicator
      #
      startTableHTML(label = steerIndicators$varNames[steerIndicators$varList == j])
      #
      # Subset results to current indicator
      #
      currentTable &lt;- subset(temp, indicatorCode == j)
      #
      # Cycle through rows of the results for current indicator
      #
      for(l in 1:nrow(currentTable))
        {
        #
        # Create row of results
        #
        rowResults &lt;- currentTable[l, c(&quot;slumTotal&quot;, &quot;slumEst&quot;, &quot;slumLCL&quot;, &quot;slumUCL&quot;, 
                                        &quot;otherTotal&quot;, &quot;otherEst&quot;, &quot;otherLCL&quot;, &quot;otherUCL&quot;,
                                        &quot;total&quot;, &quot;totalEst&quot;, &quot;totalLCL&quot;, &quot;totalUCL&quot;)]
        #
        # Convert proportions to percentages (x 100)
        #
        rowResults[c(&quot;slumEst&quot;, &quot;slumLCL&quot;, &quot;slumUCL&quot;, 
                     &quot;otherEst&quot;, &quot;otherLCL&quot;, &quot;otherUCL&quot;, 
                     &quot;totalEst&quot;, &quot;totalLCL&quot;, &quot;totalUCL&quot;)] &lt;- rowResults[c(&quot;slumEst&quot;, &quot;slumLCL&quot;, &quot;slumUCL&quot;, 
                                                                          &quot;otherEst&quot;, &quot;otherLCL&quot;, &quot;otherUCL&quot;, 
                                                                          &quot;totalEst&quot;, &quot;totalLCL&quot;, &quot;totalUCL&quot;)] * 100 
        #
        # Insert indicator results into the HTML table 
        #
        tableRowHTMLcoverage(label = currentTable$surveyArea[l], 
                             x = c(rowResults[,1], rowResults[,2], rowResults[,3], 
                                   rowResults[,4], rowResults[,5], rowResults[,6], 
                                   rowResults[,7], rowResults[,8], rowResults[,9], 
                                   rowResults[,10], rowResults[,11], rowResults[,12]))
        }
      #
      # Close HTML file
      #
      stopTableHTML()
      }
    }
  #
  # Close HTML file
  #
  stopHTML()
  #
  # Close HTML output stream
  #
  sink()
  }

</command>
							<property title="Report" shape="OUTPUT"/>
							<option type="com.ef_prime.rflow.node.base.SubflowNodeModel">
								<subflow>
									<graph version="0.8" width="1625" height="513" locationtype="a" offsetx="100" offsety="11">
										<node id="124" date="1510899093941" uid="4c3d64bcd65eeada" x="280" y="110">
											<command></command>
											<property/>
											<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
												<entry key="io">out</entry>
											</option>
										</node>
										<node id="125" date="1510899093941" uid="b4af78ba1c29c004" x="280" y="10">
											<command>
################################################################################
#
# Create results pages
#
################################################################################
#
# Insert population pyramid plot
#
sink(paste(&quot;report/results/population&quot;, &quot;-&quot;, unique(ccode), &quot;.html&quot;, sep = &quot;&quot;))
#
#
#
startHTML(label = &quot;Population&quot;)
#
#
#
insertFigureHTML(label = &quot;Population pyramid by survey area&quot;,
                 filename = paste(&quot;../../outputFigures/charts/agePyramidSurveyArea&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;))
#
# Close HTML file
#
stopHTML()
#
# Close HTML output stream
#
sink()
#
# Cycle through each variable set
#
for(i in 1:length(unique(steerIndicators$varFile)))
  {
  #
  # Open results file stream
  #
  sink(paste(&quot;report/results/&quot;, unique(steerIndicators$varFile)[i], &quot;-&quot;, unique(ccode), &quot;.html&quot;, sep = &quot;&quot;))
  #
  # Start an HTML file for current variable set
  #  
  startHTML(label = unique(steerIndicators$varTitle)[i])
  #
  # Subset results table to current indicator set
  #    
  temp &lt;- subset(surveyResults, indicatorCode %in% unique(steerIndicators$varList[steerIndicators$varSet == unique(steerIndicators$varSet)[i]]))
  #
  # Subset steerIndicators to match current indicator set
  #
  currentSteer &lt;- subset(steerIndicators, varFile == unique(steerIndicators$varFile)[i])
  #
  # Cycle through variable code list of current indicator set
  #
  for(j in currentSteer$varList)
    {
    #
    # Determine if current indicator requires a pareto or histogram function
    #
    if(currentSteer$varFunction[currentSteer$varList == j] == &quot;pareto&quot; | currentSteer$varFunction[currentSteer$varList == j] == &quot;histogram&quot;)
      {
      #
      # Cylce through survey areas
      #
      for(k in 1:length(unique(temp$surveyArea)))
        {
        #
        # Insert pareto chart or histogram of slum, other and total for each survey area
        #
        insertFigureHTML(label = paste(currentSteer$varNames[currentSteer$varList == j], &quot;-&quot;, &quot;Survey Area&quot;, k, sep = &quot; &quot;),
                         filename = paste(&quot;../../outputFigures/charts/&quot;, j, &quot;SurveyArea&quot;, k, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;))
        }
      }
    #
    # Determine if current indicator requires a histogram (mean)
    #
    if(currentSteer$varFunction[currentSteer$varList == j] == &quot;histogram&quot;)
      {
      #
      # Insert map of mean indicator
      #
      insertFigureHTML(label = steerIndicators$varNames[steerIndicators$varList == j],
                       filename = paste(&quot;../../outputFigures/maps/&quot;, j, &quot;Mean&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;))
      #
      # Start an HTML table for current indicator
      #
      startTableHTML(label = steerIndicators$varNames[steerIndicators$varList == j])
      #
      # Subset results to current indicator
      #
      currentTable &lt;- subset(temp, indicatorCode == j)
      #
      # Cycle through rows of the results for current indicator
      #
      for(l in 1:nrow(currentTable))
        {
        #
        # Create row of results
        #
        rowResults &lt;- currentTable[l, c(&quot;slumTotal&quot;, &quot;slumEst&quot;, &quot;slumLCL&quot;, &quot;slumUCL&quot;, 
                                        &quot;otherTotal&quot;, &quot;otherEst&quot;, &quot;otherLCL&quot;, &quot;otherUCL&quot;,
                                        &quot;total&quot;, &quot;totalEst&quot;, &quot;totalLCL&quot;, &quot;totalUCL&quot;)]
        #
	   # Insert indicator results into the HTML table 
        #
	   tableRowHTMLmean(label = currentTable$surveyArea[l], 
				     x = c(rowResults[,1], rowResults[,2], rowResults[,3], 
					      rowResults[,4], rowResults[,5], rowResults[,6], 
					      rowResults[,7], rowResults[,8], rowResults[,9], 
					      rowResults[,10], rowResults[,11], rowResults[,12]))
        }		          
      #
      # Close table HTML
      #
      stopTableHTML()
      }      
    #
    # Determine if current indicator requires a proportion
    #
    if(currentSteer$varFunction[currentSteer$varList == j] == &quot;proportion&quot;)
      {
      #
      # Insert map of proportion indicator
      #
      insertFigureHTML(label = steerIndicators$varNames[steerIndicators$varList == j],
                       filename = paste(&quot;../../outputFigures/maps/&quot;, j, &quot;Est&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;))
      #
      # Start an HTML table for current indicator
      #
      startTableHTML(label = steerIndicators$varNames[steerIndicators$varList == j])
      #
      # Subset results to current indicator
      #
      currentTable &lt;- subset(temp, indicatorCode == j)
      #
      # Cycle through rows of the results for current indicator
      #
      for(l in 1:nrow(currentTable))
        {
        #
        # Create row of results
        #
        rowResults &lt;- currentTable[l, c(&quot;slumTotal&quot;, &quot;slumEst&quot;, &quot;slumLCL&quot;, &quot;slumUCL&quot;, 
                                        &quot;otherTotal&quot;, &quot;otherEst&quot;, &quot;otherLCL&quot;, &quot;otherUCL&quot;,
                                        &quot;total&quot;, &quot;totalEst&quot;, &quot;totalLCL&quot;, &quot;totalUCL&quot;)]
        #
        # Convert proportions to percentages (x 100)
        #
        rowResults[c(&quot;slumEst&quot;, &quot;slumLCL&quot;, &quot;slumUCL&quot;, 
                     &quot;otherEst&quot;, &quot;otherLCL&quot;, &quot;otherUCL&quot;, 
                     &quot;totalEst&quot;, &quot;totalLCL&quot;, &quot;totalUCL&quot;)] &lt;- rowResults[c(&quot;slumEst&quot;, &quot;slumLCL&quot;, &quot;slumUCL&quot;, 
                                                                          &quot;otherEst&quot;, &quot;otherLCL&quot;, &quot;otherUCL&quot;, 
                                                                          &quot;totalEst&quot;, &quot;totalLCL&quot;, &quot;totalUCL&quot;)] * 100 
        #
        # Insert indicator results into the HTML table 
        #
        tableRowHTMLcoverage(label = currentTable$surveyArea[l], 
                             x = c(rowResults[,1], rowResults[,2], rowResults[,3], 
                                   rowResults[,4], rowResults[,5], rowResults[,6], 
                                   rowResults[,7], rowResults[,8], rowResults[,9], 
                                   rowResults[,10], rowResults[,11], rowResults[,12]))
        }
      #
      # Close HTML file
      #
      stopTableHTML()
      }
    }
  #
  # Close HTML file
  #
  stopHTML()
  #
  # Close HTML output stream
  #
  sink()
  }

</command>
											<property title="Create HTML results pages" shape="OUTPUT"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<node id="126" date="1510899093941" uid="6569f1a95a8392ec" x="-10" y="10">
											<command></command>
											<property/>
											<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
												<entry key="io">in</entry>
											</option>
										</node>
										<node id="127" date="1510899093941" uid="4a735463c21f7506" x="80" y="10">
											<command>#
# Extract country choice
#
country &lt;- as.character(tclvalue(choice.value))
#
# Determine country code
#
ccode &lt;- ifelse(country == &quot;Bangladesh&quot;, &quot;BGD&quot;,
	      ifelse(country == &quot;Ghana&quot;, &quot;GHA&quot;,
		   ifelse(country == &quot;India&quot;, &quot;IND&quot;,
			ifelse(country == &quot;Kenya&quot;, &quot;KEN&quot;,
			  ifelse(country == &quot;Madagascar&quot;, &quot;MDG&quot;, &quot;ZMB&quot;)))))
</command>
											<property title="Get country name" shape="INOUT"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<node id="128" date="1510899093941" uid="bc0ef19a607c320d" x="180" y="10">
											<command>
################################################################################
#
# Create base HTML with frames and menu file 
#
################################################################################
#
# Select country HTML
#
selectCountryHTML(reportTitle = &quot;WSUP Urban Water and Sanitation Survey&quot;)
#
# Create HTML frameset for results
#
newIndexHTML(fileName = unique(ccode), reportTitle = &quot;WSUP Urban Water and Sanitation Survey&quot;, varFile = unique(steerIndicators$varFile)[1])
#
# Create HTML menu file
#
newMenuHTML(fileName = unique(ccode))
#
# Add menu for population pyramid
#
addMenuHTML(varFile = &quot;population&quot;, fileName = unique(ccode), varTitle = &quot;Population&quot;)
#
# Cycle through steering file
#
for(i in 1:length(unique(steerIndicators$varSet)))
  {
  #
  # Add indicator menu
  #
  addMenuHTML(varFile = unique(steerIndicators$varFile)[i], fileName = unique(ccode), varTitle = unique(steerIndicators$varTitle)[i])
  }
#
# Close HTML menu
#
endMenuHTML(unique(ccode))

</command>
											<property title="Open HTML report" shape="OUTPUT"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<node id="129" date="1510899093941" uid="88e64208ee55daa0" x="80" y="110">
											<command>
################################################################################
#
#  Select and read indicator steering file: Accepts CSV data files
#
################################################################################
#
# Prompt user to supply indicator steering file
#
tkmessageBox(title = &quot;Load file&quot;,
             message = &quot;Select indicators steering file&quot;, 
	        icon = &quot;info&quot;, 
	        type = &quot;ok&quot;)
#
# Cycle through indicator steering file selection prompts
#
repeat
  {
  #
  # Cycle through indicator steering file selection prompts when no file is selected
  #
  repeat
    {
    #
    # Select indicator steering file
    #
    fileName &lt;- tclvalue(tkgetOpenFile())
    #
    # Determine if a indicator steering file has been selected
    #	
    if(!nchar(fileName)) 
      {
      #
      # Prompt user that no file has been selected
      #
      error1 &lt;- tkmessageBox(title = &quot;Error&quot;,
				         message = &quot;No file was selected! Please try again.&quot;,
				         icon = &quot;error&quot;,
				         type = &quot;retrycancel&quot;)
      }
    #
    # Break repeat once any file has been selected
    #	
    if(nchar(fileName) &gt; 0) break
    #
    # Break repeat if user cancels option to select file
    #
    if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
    } 
  #
  # Break repeat if user cancels option to select file
  #
  if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  #
  # Try to read indicator steering file based on filename provided by user
  #	
  steerIndicators &lt;- try(expr = read.csv(file = fileName, header = TRUE, sep = &quot;,&quot;), 
		               silent = TRUE)
  #
  # Check if indicator steering file provided is in correct format (CSV file)
  #
  if(exists(&quot;steerIndicators&quot;) &amp;&amp; class(steerIndicators) == &quot;try-error&quot;)
    {
    #
    # Prompt user that file format is incorrect
    #
    error2 &lt;- tkmessageBox(title = &quot;Error&quot;,
			            message = paste(&quot;Problem reading file &apos;&quot;, basename(fileName), &quot;&apos;. Please try again&quot;, sep = &quot;,&quot;),
			            icon = &quot;error&quot;,
			            type = &quot;retrycancel&quot;)
    }
  #
  # Break repeat once selected indicator steering file is in correct format
  #
  if(exists(&quot;steerIndicators&quot;) &amp;&amp; class(steerIndicators) != &quot;try-error&quot;) break
  #
  # Break repeat if user cancels option to retry providing a new file
  #
  if(exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;) break
  }
#
# Determine if user cancels option to select file or cancels option to retry providing a new file
#
if((exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) | (exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;))
  {
  #
  # Prompt user that no file has been loaded
  #
  tkmessageBox(title = &quot;Warning&quot;,
		     message = &quot;You have not loaded any data file&quot;,
		     icon = &quot;warning&quot;,
		     type = &quot;ok&quot;)
  }
#
# Determine user has successfully selected and loaded an appropriate data file
#
if(exists(&quot;steerIndicators&quot;) &amp;&amp; class(steerIndicators) != &quot;try-error&quot;)
  {
  #
  # Prompt use of the filename of the indicator steering file file selected
  #
  tkmessageBox(title = &quot;Success!&quot;,
     		message = paste(&quot;You have loaded the data file named &apos;&quot;, basename(fileName), &quot;&apos;.&quot;, sep = &quot;&quot;),
		     icon = &quot;info&quot;,
		     type = &quot;ok&quot;)
  }
#
# Clean-up filename
#
rm(fileName)
#
# Clean-up error1 if present
#
if(exists(&quot;error1&quot;))
  {
  rm(error1)
  }
#
# Clean-up error2 if present
#
if(exists(&quot;error2&quot;))
  {
  rm(error2)
  }

</command>
											<property title="Read steering file" shape="INOUT"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<node id="130" date="1510899093941" uid="38484b0bf8a353a5" x="180" y="110">
											<command>

################################################################################
#
#  Select and read results data: Accepts CSV data files
#
################################################################################
#
# Prompt user to supply indicator data file
#
tkmessageBox(title = &quot;Load file&quot;,
	        message = &quot;Select results data file&quot;, 
	        icon = &quot;info&quot;, 
	        type = &quot;ok&quot;)
#
# Cycle through results data file selection prompts
#
repeat
  {
  #
  # Cycle through results data file selection prompts when no file is selected
  #
  repeat
    {
    #
    # Select results data file
    #
    fileName &lt;- tclvalue(tkgetOpenFile())
    #
    # Determine if a results data file has been selected
    #	
    if(!nchar(fileName)) 
      {
      #
      # Prompt user that no file has been selected
      #
      error1 &lt;- tkmessageBox(title = &quot;Error&quot;,
				         message = &quot;No file was selected! Please try again.&quot;,
				         icon = &quot;error&quot;,
				         type = &quot;retrycancel&quot;)
      }
    #
    # Break repeat once any file has been selected
    #	
    if(nchar(fileName) &gt; 0) break
    #
    # Break repeat if user cancels option to select file
    #
    if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  }
  #
  # Break repeat if user cancels option to select file
  #
  if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  #
  # Try to read results data file based on filename provided by user
  #
  surveyResults &lt;- try(expr = read.csv(file = fileName, header = TRUE, sep = &quot;,&quot;), 
		             silent = TRUE)
  #
  # Check if results data file provided is in correct format (CSV file)
  #
  if(exists(&quot;surveyResults&quot;) &amp;&amp; class(surveyResults) == &quot;try-error&quot;)
    {
    #
    # Prompt user that file format is incorrect
    #
    error2 &lt;- tkmessageBox(title = &quot;Error&quot;,
			            message = paste(&quot;Problem reading file &apos;&quot;, basename(fileName), &quot;&apos;. Please try again&quot;, sep = &quot;,&quot;),
			            icon = &quot;error&quot;,
			            type = &quot;retrycancel&quot;)
    }
  #
  # Break repeat once selected results data file is in correct format
  #
  if(exists(&quot;surveyResults&quot;) &amp;&amp; class(surveyResults) != &quot;try-error&quot;) break
  #
  # Break repeat if user cancels option to retry providing a new file
  #
  if(exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;) break
  }
#
# Determine if user cancels option to select file or cancels option to retry providing a new file
#
if((exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) | (exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;))
  {
  #
  # Prompt user that no file has been loaded
  #
  tkmessageBox(title = &quot;Warning&quot;,
 		     message = &quot;You have not loaded any data file&quot;,
		     icon = &quot;warning&quot;,
		     type = &quot;ok&quot;)
  }
#
# Determine user has successfully selected and loaded an appropriate data file
#
if(exists(&quot;surveyResults&quot;) &amp;&amp; class(surveyResults) != &quot;try-error&quot;)
  {
  #
  # Prompt use of the filename of the results data file file selected
  #
  tkmessageBox(title = &quot;Success!&quot;,
		     message = paste(&quot;You have loaded the data file named &apos;&quot;, basename(fileName), &quot;&apos;.&quot;, sep = &quot;&quot;),
		     icon = &quot;info&quot;,
		     type = &quot;ok&quot;)
  }
#
# Clean-up filename
#
rm(fileName)
#
# Clean-up error1 if present
#
if(exists(&quot;error1&quot;))
  {
  rm(error1)
  }
#
# Clean-up error2 if present
#
if(exists(&quot;error2&quot;))
  {
  rm(error2)
  }

</command>
											<property title="Read results data" shape="INOUT"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<edge from="130" to="128"/>
										<edge from="129" to="130"/>
										<edge from="125" to="124"/>
										<edge from="127" to="129"/>
										<edge from="126" to="127"/>
										<edge from="128" to="125"/>
									</graph>
								</subflow>
							</option>
						</node>
						<node id="131" date="1510899093940" uid="d8d44ca989de25ae" x="260" y="650">
							<command>

################################################################################
#
#  Select and read map data: Accepts shapefiles (SHP)
#
################################################################################
#
# Prompt user to supply indicator data file
#
tkmessageBox(title = &quot;Read shapefile&quot;,
	        message = &quot;Select folder containing shapefile for mapping&quot;, 
	        icon = &quot;info&quot;, 
	        type = &quot;ok&quot;)
#
# Cycle through shapefile selection prompts
#
repeat
  {
  #
  # Cycle through shapefile selection prompts when no file is selected
  #
  repeat
    {
    #
    # Select indicator data file
    #
    fileName &lt;- tk_choose.dir()
    #
    # Determine if a indicator data file has been selected
    #	
    if(!nchar(fileName)) 
      {
      #
      # Prompt user that no file has been selected
      #
      error1 &lt;- tkmessageBox(title = &quot;Error&quot;,
				         message = &quot;No shapefile was selected! Please try again.&quot;,
				         icon = &quot;error&quot;,
				         type = &quot;retrycancel&quot;)
      }
    #
    # Break repeat once any file has been selected
    #	
    if(nchar(fileName) &gt; 0) break
    #
    # Break repeat if user cancels option to select file
    #
    if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  }
  #
  # Break repeat if user cancels option to select file
  #
  if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  #
  # Try to read shapefile based on filename provided by user
  #
  surveyArea &lt;- try(expr = readOGR(dsn = fileName, 
                                   layer = basename(fileName), 
                                   verbose = FALSE), 
		          silent = TRUE)
  #
  # Check if shapefile provided is in correct format (SHP)
  #
  if(exists(&quot;surveyArea&quot;) &amp;&amp; class(surveyArea) == &quot;try-error&quot;)
    {
    #
    # Prompt user that file format is incorrect
    #
    error2 &lt;- tkmessageBox(title = &quot;Error&quot;,
			            message = paste(&quot;Problem reading shapefile &apos;&quot;, basename(fileName), &quot;&apos;. Please try again&quot;, sep = &quot;,&quot;),
			            icon = &quot;error&quot;,
			            type = &quot;retrycancel&quot;)
    }
  #
  # Break repeat once selected shapefile is in correct format
  #
  if(exists(&quot;surveyArea&quot;) &amp;&amp; class(surveyArea) != &quot;try-error&quot;) break
  #
  # Break repeat if user cancels option to retry providing a new file
  #
  if(exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;) break
  }
#
# Determine if user cancels option to select file or cancels option to retry providing a new file
#
if((exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) | (exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;))
  {
  #
  # Prompt user that no file has been loaded
  #
  tkmessageBox(title = &quot;Warning&quot;,
 		     message = &quot;You have not loaded any shapefile&quot;,
		     icon = &quot;warning&quot;,
		     type = &quot;ok&quot;)
  }
#
# Determine user has successfully selected and loaded an appropriate shapefile
#
if(exists(&quot;surveyArea&quot;) &amp;&amp; class(surveyArea) != &quot;try-error&quot;)
  {
  #
  # Prompt use of the filename of the shapefile file selected
  #
  tkmessageBox(title = &quot;Success!&quot;,
		     message = paste(&quot;You have loaded the shapefile named &apos;&quot;, basename(fileName), &quot;&apos;.&quot;, sep = &quot;&quot;),
		     icon = &quot;info&quot;,
		     type = &quot;ok&quot;)
  }
#
# Clean-up filename
#
rm(fileName)
#
# Clean-up error1 if present
#
if(exists(&quot;error1&quot;))
  {
  rm(error1)
  }
#
# Clean-up error2 if present
#
if(exists(&quot;error2&quot;))
  {
  rm(error2)
  }



################################################################################
#
#  Select and read indicator steering file: Accepts CSV data files
#
################################################################################
#
# Prompt user to supply indicator steering file
#
tkmessageBox(title = &quot;Load file&quot;,
             message = &quot;Select indicators steering file&quot;, 
	        icon = &quot;info&quot;, 
	        type = &quot;ok&quot;)
#
# Cycle through indicator steering file selection prompts
#
repeat
  {
  #
  # Cycle through indicator steering file selection prompts when no file is selected
  #
  repeat
    {
    #
    # Select indicator steering file
    #
    fileName &lt;- tclvalue(tkgetOpenFile())
    #
    # Determine if a indicator steering file has been selected
    #	
    if(!nchar(fileName)) 
      {
      #
      # Prompt user that no file has been selected
      #
      error1 &lt;- tkmessageBox(title = &quot;Error&quot;,
				         message = &quot;No file was selected! Please try again.&quot;,
				         icon = &quot;error&quot;,
				         type = &quot;retrycancel&quot;)
      }
    #
    # Break repeat once any file has been selected
    #	
    if(nchar(fileName) &gt; 0) break
    #
    # Break repeat if user cancels option to select file
    #
    if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
    } 
  #
  # Break repeat if user cancels option to select file
  #
  if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  #
  # Try to read indicator steering file based on filename provided by user
  #	
  steerIndicators &lt;- try(expr = read.csv(file = fileName, header = TRUE, sep = &quot;,&quot;), 
		               silent = TRUE)
  #
  # Check if indicator steering file provided is in correct format (CSV file)
  #
  if(exists(&quot;steerIndicators&quot;) &amp;&amp; class(steerIndicators) == &quot;try-error&quot;)
    {
    #
    # Prompt user that file format is incorrect
    #
    error2 &lt;- tkmessageBox(title = &quot;Error&quot;,
			            message = paste(&quot;Problem reading file &apos;&quot;, basename(fileName), &quot;&apos;. Please try again&quot;, sep = &quot;,&quot;),
			            icon = &quot;error&quot;,
			            type = &quot;retrycancel&quot;)
    }
  #
  # Break repeat once selected indicator steering file is in correct format
  #
  if(exists(&quot;steerIndicators&quot;) &amp;&amp; class(steerIndicators) != &quot;try-error&quot;) break
  #
  # Break repeat if user cancels option to retry providing a new file
  #
  if(exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;) break
  }
#
# Determine if user cancels option to select file or cancels option to retry providing a new file
#
if((exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) | (exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;))
  {
  #
  # Prompt user that no file has been loaded
  #
  tkmessageBox(title = &quot;Warning&quot;,
		     message = &quot;You have not loaded any data file&quot;,
		     icon = &quot;warning&quot;,
		     type = &quot;ok&quot;)
  }
#
# Determine user has successfully selected and loaded an appropriate data file
#
if(exists(&quot;steerIndicators&quot;) &amp;&amp; class(steerIndicators) != &quot;try-error&quot;)
  {
  #
  # Prompt use of the filename of the indicator steering file file selected
  #
  tkmessageBox(title = &quot;Success!&quot;,
     		message = paste(&quot;You have loaded the data file named &apos;&quot;, basename(fileName), &quot;&apos;.&quot;, sep = &quot;&quot;),
		     icon = &quot;info&quot;,
		     type = &quot;ok&quot;)
  }
#
# Clean-up filename
#
rm(fileName)
#
# Clean-up error1 if present
#
if(exists(&quot;error1&quot;))
  {
  rm(error1)
  }
#
# Clean-up error2 if present
#
if(exists(&quot;error2&quot;))
  {
  rm(error2)
  }




################################################################################
#
#  Select and read results data: Accepts CSV data files
#
################################################################################
#
# Prompt user to supply indicator data file
#
tkmessageBox(title = &quot;Load file&quot;,
	        message = &quot;Select results data file&quot;, 
	        icon = &quot;info&quot;, 
	        type = &quot;ok&quot;)
#
# Cycle through results data file selection prompts
#
repeat
  {
  #
  # Cycle through results data file selection prompts when no file is selected
  #
  repeat
    {
    #
    # Select results data file
    #
    fileName &lt;- tclvalue(tkgetOpenFile())
    #
    # Determine if a results data file has been selected
    #	
    if(!nchar(fileName)) 
      {
      #
      # Prompt user that no file has been selected
      #
      error1 &lt;- tkmessageBox(title = &quot;Error&quot;,
				         message = &quot;No file was selected! Please try again.&quot;,
				         icon = &quot;error&quot;,
				         type = &quot;retrycancel&quot;)
      }
    #
    # Break repeat once any file has been selected
    #	
    if(nchar(fileName) &gt; 0) break
    #
    # Break repeat if user cancels option to select file
    #
    if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  }
  #
  # Break repeat if user cancels option to select file
  #
  if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  #
  # Try to read results data file based on filename provided by user
  #
  surveyResults &lt;- try(expr = read.csv(file = fileName, header = TRUE, sep = &quot;,&quot;), 
		             silent = TRUE)
  #
  # Check if results data file provided is in correct format (CSV file)
  #
  if(exists(&quot;surveyResults&quot;) &amp;&amp; class(surveyResults) == &quot;try-error&quot;)
    {
    #
    # Prompt user that file format is incorrect
    #
    error2 &lt;- tkmessageBox(title = &quot;Error&quot;,
			            message = paste(&quot;Problem reading file &apos;&quot;, basename(fileName), &quot;&apos;. Please try again&quot;, sep = &quot;,&quot;),
			            icon = &quot;error&quot;,
			            type = &quot;retrycancel&quot;)
    }
  #
  # Break repeat once selected results data file is in correct format
  #
  if(exists(&quot;surveyResults&quot;) &amp;&amp; class(surveyResults) != &quot;try-error&quot;) break
  #
  # Break repeat if user cancels option to retry providing a new file
  #
  if(exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;) break
  }
#
# Determine if user cancels option to select file or cancels option to retry providing a new file
#
if((exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) | (exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;))
  {
  #
  # Prompt user that no file has been loaded
  #
  tkmessageBox(title = &quot;Warning&quot;,
 		     message = &quot;You have not loaded any data file&quot;,
		     icon = &quot;warning&quot;,
		     type = &quot;ok&quot;)
  }
#
# Determine user has successfully selected and loaded an appropriate data file
#
if(exists(&quot;surveyResults&quot;) &amp;&amp; class(surveyResults) != &quot;try-error&quot;)
  {
  #
  # Prompt use of the filename of the results data file file selected
  #
  tkmessageBox(title = &quot;Success!&quot;,
		     message = paste(&quot;You have loaded the data file named &apos;&quot;, basename(fileName), &quot;&apos;.&quot;, sep = &quot;&quot;),
		     icon = &quot;info&quot;,
		     type = &quot;ok&quot;)
  }
#
# Clean-up filename
#
rm(fileName)
#
# Clean-up error1 if present
#
if(exists(&quot;error1&quot;))
  {
  rm(error1)
  }
#
# Clean-up error2 if present
#
if(exists(&quot;error2&quot;))
  {
  rm(error2)
  }

</command>
							<property title="Read data to map" shape="INOUT"/>
							<option type="com.ef_prime.rflow.node.base.SubflowNodeModel">
								<subflow>
									<graph version="0.8" width="793" height="193" locationtype="a" offsetx="100" offsety="71">
										<node id="132" date="1510899093940" uid="fd817cd5c2e39479" x="60" y="0">
											<command>

################################################################################
#
#  Select and read map data: Accepts shapefiles (SHP)
#
################################################################################
#
# Prompt user to supply indicator data file
#
tkmessageBox(title = &quot;Read shapefile&quot;,
	        message = &quot;Select folder containing shapefile for mapping&quot;, 
	        icon = &quot;info&quot;, 
	        type = &quot;ok&quot;)
#
# Cycle through shapefile selection prompts
#
repeat
  {
  #
  # Cycle through shapefile selection prompts when no file is selected
  #
  repeat
    {
    #
    # Select indicator data file
    #
    fileName &lt;- tk_choose.dir()
    #
    # Determine if a indicator data file has been selected
    #	
    if(!nchar(fileName)) 
      {
      #
      # Prompt user that no file has been selected
      #
      error1 &lt;- tkmessageBox(title = &quot;Error&quot;,
				         message = &quot;No shapefile was selected! Please try again.&quot;,
				         icon = &quot;error&quot;,
				         type = &quot;retrycancel&quot;)
      }
    #
    # Break repeat once any file has been selected
    #	
    if(nchar(fileName) &gt; 0) break
    #
    # Break repeat if user cancels option to select file
    #
    if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  }
  #
  # Break repeat if user cancels option to select file
  #
  if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  #
  # Try to read shapefile based on filename provided by user
  #
  surveyArea &lt;- try(expr = readOGR(dsn = fileName, 
                                   layer = basename(fileName), 
                                   verbose = FALSE), 
		          silent = TRUE)
  #
  # Check if shapefile provided is in correct format (SHP)
  #
  if(exists(&quot;surveyArea&quot;) &amp;&amp; class(surveyArea) == &quot;try-error&quot;)
    {
    #
    # Prompt user that file format is incorrect
    #
    error2 &lt;- tkmessageBox(title = &quot;Error&quot;,
			            message = paste(&quot;Problem reading shapefile &apos;&quot;, basename(fileName), &quot;&apos;. Please try again&quot;, sep = &quot;,&quot;),
			            icon = &quot;error&quot;,
			            type = &quot;retrycancel&quot;)
    }
  #
  # Break repeat once selected shapefile is in correct format
  #
  if(exists(&quot;surveyArea&quot;) &amp;&amp; class(surveyArea) != &quot;try-error&quot;) break
  #
  # Break repeat if user cancels option to retry providing a new file
  #
  if(exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;) break
  }
#
# Determine if user cancels option to select file or cancels option to retry providing a new file
#
if((exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) | (exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;))
  {
  #
  # Prompt user that no file has been loaded
  #
  tkmessageBox(title = &quot;Warning&quot;,
 		     message = &quot;You have not loaded any shapefile&quot;,
		     icon = &quot;warning&quot;,
		     type = &quot;ok&quot;)
  }
#
# Determine user has successfully selected and loaded an appropriate shapefile
#
if(exists(&quot;surveyArea&quot;) &amp;&amp; class(surveyArea) != &quot;try-error&quot;)
  {
  #
  # Prompt use of the filename of the shapefile file selected
  #
  tkmessageBox(title = &quot;Success!&quot;,
		     message = paste(&quot;You have loaded the shapefile named &apos;&quot;, basename(fileName), &quot;&apos;.&quot;, sep = &quot;&quot;),
		     icon = &quot;info&quot;,
		     type = &quot;ok&quot;)
  }
#
# Clean-up filename
#
rm(fileName)
#
# Clean-up error1 if present
#
if(exists(&quot;error1&quot;))
  {
  rm(error1)
  }
#
# Clean-up error2 if present
#
if(exists(&quot;error2&quot;))
  {
  rm(error2)
  }

</command>
											<property title="Read map data" shape="INOUT"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<node id="133" date="1510899093940" uid="9ed09247a922c619" x="-30" y="0">
											<command></command>
											<property/>
											<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
												<entry key="io">in</entry>
											</option>
										</node>
										<node id="134" date="1510899093940" uid="125f824c23c70769" x="160" y="70">
											<command>

################################################################################
#
#  Select and read results data: Accepts CSV data files
#
################################################################################
#
# Prompt user to supply indicator data file
#
tkmessageBox(title = &quot;Load file&quot;,
	        message = &quot;Select results data file&quot;, 
	        icon = &quot;info&quot;, 
	        type = &quot;ok&quot;)
#
# Cycle through results data file selection prompts
#
repeat
  {
  #
  # Cycle through results data file selection prompts when no file is selected
  #
  repeat
    {
    #
    # Select results data file
    #
    fileName &lt;- tclvalue(tkgetOpenFile())
    #
    # Determine if a results data file has been selected
    #	
    if(!nchar(fileName)) 
      {
      #
      # Prompt user that no file has been selected
      #
      error1 &lt;- tkmessageBox(title = &quot;Error&quot;,
				         message = &quot;No file was selected! Please try again.&quot;,
				         icon = &quot;error&quot;,
				         type = &quot;retrycancel&quot;)
      }
    #
    # Break repeat once any file has been selected
    #	
    if(nchar(fileName) &gt; 0) break
    #
    # Break repeat if user cancels option to select file
    #
    if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  }
  #
  # Break repeat if user cancels option to select file
  #
  if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  #
  # Try to read results data file based on filename provided by user
  #
  surveyResults &lt;- try(expr = read.csv(file = fileName, header = TRUE, sep = &quot;,&quot;), 
		             silent = TRUE)
  #
  # Check if results data file provided is in correct format (CSV file)
  #
  if(exists(&quot;surveyResults&quot;) &amp;&amp; class(surveyResults) == &quot;try-error&quot;)
    {
    #
    # Prompt user that file format is incorrect
    #
    error2 &lt;- tkmessageBox(title = &quot;Error&quot;,
			            message = paste(&quot;Problem reading file &apos;&quot;, basename(fileName), &quot;&apos;. Please try again&quot;, sep = &quot;,&quot;),
			            icon = &quot;error&quot;,
			            type = &quot;retrycancel&quot;)
    }
  #
  # Break repeat once selected results data file is in correct format
  #
  if(exists(&quot;surveyResults&quot;) &amp;&amp; class(surveyResults) != &quot;try-error&quot;) break
  #
  # Break repeat if user cancels option to retry providing a new file
  #
  if(exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;) break
  }
#
# Determine if user cancels option to select file or cancels option to retry providing a new file
#
if((exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) | (exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;))
  {
  #
  # Prompt user that no file has been loaded
  #
  tkmessageBox(title = &quot;Warning&quot;,
 		     message = &quot;You have not loaded any data file&quot;,
		     icon = &quot;warning&quot;,
		     type = &quot;ok&quot;)
  }
#
# Determine user has successfully selected and loaded an appropriate data file
#
if(exists(&quot;surveyResults&quot;) &amp;&amp; class(surveyResults) != &quot;try-error&quot;)
  {
  #
  # Prompt use of the filename of the results data file file selected
  #
  tkmessageBox(title = &quot;Success!&quot;,
		     message = paste(&quot;You have loaded the data file named &apos;&quot;, basename(fileName), &quot;&apos;.&quot;, sep = &quot;&quot;),
		     icon = &quot;info&quot;,
		     type = &quot;ok&quot;)
  }
#
# Clean-up filename
#
rm(fileName)
#
# Clean-up error1 if present
#
if(exists(&quot;error1&quot;))
  {
  rm(error1)
  }
#
# Clean-up error2 if present
#
if(exists(&quot;error2&quot;))
  {
  rm(error2)
  }

</command>
											<property title="Read results data" shape="INOUT"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<node id="135" date="1510899093940" uid="78c52a83c058f10e" x="60" y="70">
											<command>
################################################################################
#
#  Select and read indicator steering file: Accepts CSV data files
#
################################################################################
#
# Prompt user to supply indicator steering file
#
tkmessageBox(title = &quot;Load file&quot;,
             message = &quot;Select indicators steering file&quot;, 
	        icon = &quot;info&quot;, 
	        type = &quot;ok&quot;)
#
# Cycle through indicator steering file selection prompts
#
repeat
  {
  #
  # Cycle through indicator steering file selection prompts when no file is selected
  #
  repeat
    {
    #
    # Select indicator steering file
    #
    fileName &lt;- tclvalue(tkgetOpenFile())
    #
    # Determine if a indicator steering file has been selected
    #	
    if(!nchar(fileName)) 
      {
      #
      # Prompt user that no file has been selected
      #
      error1 &lt;- tkmessageBox(title = &quot;Error&quot;,
				         message = &quot;No file was selected! Please try again.&quot;,
				         icon = &quot;error&quot;,
				         type = &quot;retrycancel&quot;)
      }
    #
    # Break repeat once any file has been selected
    #	
    if(nchar(fileName) &gt; 0) break
    #
    # Break repeat if user cancels option to select file
    #
    if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
    } 
  #
  # Break repeat if user cancels option to select file
  #
  if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  #
  # Try to read indicator steering file based on filename provided by user
  #	
  steerIndicators &lt;- try(expr = read.csv(file = fileName, header = TRUE, sep = &quot;,&quot;), 
		               silent = TRUE)
  #
  # Check if indicator steering file provided is in correct format (CSV file)
  #
  if(exists(&quot;steerIndicators&quot;) &amp;&amp; class(steerIndicators) == &quot;try-error&quot;)
    {
    #
    # Prompt user that file format is incorrect
    #
    error2 &lt;- tkmessageBox(title = &quot;Error&quot;,
			            message = paste(&quot;Problem reading file &apos;&quot;, basename(fileName), &quot;&apos;. Please try again&quot;, sep = &quot;,&quot;),
			            icon = &quot;error&quot;,
			            type = &quot;retrycancel&quot;)
    }
  #
  # Break repeat once selected indicator steering file is in correct format
  #
  if(exists(&quot;steerIndicators&quot;) &amp;&amp; class(steerIndicators) != &quot;try-error&quot;) break
  #
  # Break repeat if user cancels option to retry providing a new file
  #
  if(exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;) break
  }
#
# Determine if user cancels option to select file or cancels option to retry providing a new file
#
if((exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) | (exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;))
  {
  #
  # Prompt user that no file has been loaded
  #
  tkmessageBox(title = &quot;Warning&quot;,
		     message = &quot;You have not loaded any data file&quot;,
		     icon = &quot;warning&quot;,
		     type = &quot;ok&quot;)
  }
#
# Determine user has successfully selected and loaded an appropriate data file
#
if(exists(&quot;steerIndicators&quot;) &amp;&amp; class(steerIndicators) != &quot;try-error&quot;)
  {
  #
  # Prompt use of the filename of the indicator steering file file selected
  #
  tkmessageBox(title = &quot;Success!&quot;,
     		message = paste(&quot;You have loaded the data file named &apos;&quot;, basename(fileName), &quot;&apos;.&quot;, sep = &quot;&quot;),
		     icon = &quot;info&quot;,
		     type = &quot;ok&quot;)
  }
#
# Clean-up filename
#
rm(fileName)
#
# Clean-up error1 if present
#
if(exists(&quot;error1&quot;))
  {
  rm(error1)
  }
#
# Clean-up error2 if present
#
if(exists(&quot;error2&quot;))
  {
  rm(error2)
  }

</command>
											<property title="Read steering file" shape="INOUT"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<node id="136" date="1510899093940" uid="d8b9ce69f473475a" x="260" y="70">
											<command></command>
											<property/>
											<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
												<entry key="io">out</entry>
											</option>
										</node>
										<edge from="134" to="136"/>
										<edge from="135" to="134"/>
										<edge from="133" to="132"/>
										<edge from="132" to="135"/>
									</graph>
								</subflow>
							</option>
						</node>
						<node id="137" date="1510899093934" uid="dce2336fd748f01a" x="370" y="650">
							<command>
################################################################################
#
# Results mapping for proprtion indicators
#
################################################################################
#
# Create steering vector for slum, other, and total results
#
steerMap &lt;- c(&quot;slumClass&quot;, &quot;otherClass&quot;)
#
# Subset surveyResults to proportions
#
propResults &lt;- subset(surveyResults, indicatorCode %in% steerIndicators$varList[steerIndicators$varFunction == &quot;proportion&quot;])
#
# Cycle through indicators
#
for(i in propResults$indicatorCode)
  {
  #
  # Subset survey results to current indicator
  #
  tempResults &lt;- subset(propResults, indicatorCode == i)
  #
  # Merge survey area map with current indicator results
  #
  tempMap &lt;- merge(surveyArea, tempResults)
  #
  # Determine directionality of indicator
  #
  varDirection  &lt;- rep(steerIndicators$varDir[steerIndicators$varList == i], length(RdYlGn5))
  #
  #
  # Open PNG graphics device - 1 x 3 layout
  #
  png(filename = paste(&quot;outputFigures/maps/&quot;, i, &quot;Class&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
      width = 10, height = 5, units = &quot;in&quot;, res = 100)
  #
  # Set plotting margins
  #
  par(mar = c(0,0,0,0), mfrow = c(1,2))
  #
  # Cycle through slum, other and total results
  #
  for(j in steerMap)
    {
    #
    #
    #
    classes &lt;- ifelse(tempMap[[j]] == &quot;Low&quot;, 1,
                 ifelse(tempMap[[j]] == &quot;Moderate&quot;, 2, 3))
    #
    # Plot current area type map
    #
    plot(surveyArea,
         col = ifelse(varDirection == &quot;lo&quot;, rev(aRdYlGn3)[classes], aRdYlGn3[classes]),
         border = ifelse(varDirection == &quot;lo&quot;, rev(RdYlGn3)[classes], RdYlGn3),
         lwd = 1)
    #
    # Plot survey area outline (survey area 1 to 9)
    #
    #plot(outline, border = &quot;gray50&quot;, lwd = 2, add = TRUE)
    #
    # Add title on top of map identifying slum, other or overall
    #
    title(main = ifelse(j == &quot;slumClass&quot;, &quot;Slum&quot;, &quot;Other&quot;), 
          line = -1)
    #
    # Add inset on rightmost map to show different survey area labels 
    #  
    if(j == &quot;otherClass&quot;)
      {
      #
      # Add inset 
      #
      par(plt = c(0.74, 0.99, 0.74, 0.99), new = TRUE)
      plot(surveyArea, lwd = 1, col = &quot;gray90&quot;, border = &quot;gray50&quot;)
      title(main = &quot;Survey Areas &quot;, line = -1, adj = 1, cex.main = 1)
      text(x = surveyArea, 
           labels = ifelse(surveyArea@data$surveyArea == &quot;Survey Area 1&quot;, 1,
                      ifelse(surveyArea@data$surveyArea == &quot;Survey Area 2&quot;, 2,
                        ifelse(surveyArea@data$surveyArea == &quot;Survey Area 3&quot;, 3,
                          ifelse(surveyArea@data$surveyArea == &quot;Survey Area 4&quot;, 4,
                            ifelse(surveyArea@data$surveyArea == &quot;Survey Area 5&quot;, 5,
                              ifelse(surveyArea@data$surveyArea == &quot;Survey Area 6&quot;, 6,
                                ifelse(surveyArea@data$surveyArea == &quot;Survey Area 7&quot;, 7,
                                  ifelse(surveyArea@data$surveyArea == &quot;Survey Area 8&quot;, 8, 9)))))))), 
           cex = ifelse(surveyArea@data$surveyArea %in% c(&quot;Survey Area 5&quot;, &quot;Survey Area 8&quot;), 0.85, 1), 
           col = &quot;blue&quot;)
      box(which = &quot;plot&quot;, lty = &quot;solid&quot;, lwd = 1)
      }
    #
    # Add legend on leftmost map
    #
    if(j == &quot;slumClass&quot;)
      {
      #
      # Add legend
      #
      legend(x = &quot;bottomleft&quot;, inset = 0.01, y.intersp = 1.2,
             legend = c(&quot;Low&quot;,
                        &quot;Moderate&quot;,
                        &quot;High&quot;),
             pch = 22, pt.cex = 2, 
             col = ifelse(varDirection == &quot;lo&quot;, rev(RdYlGn3), RdYlGn3),
             pt.bg = ifelse(varDirection == &quot;lo&quot;, rev(aRdYlGn3), aRdYlGn3),
             cex = 1)
      }
    }
  #
  # Close graphics device
  #
  dev.off()
  }


################################################################################
#
# Results mapping for proprtion indicators
#
################################################################################
#
# Create steering vector for slum, other, and total results
#
steerMap &lt;- c(&quot;slumEst&quot;, &quot;otherEst&quot;, &quot;totalEst&quot;)
#
# Subset surveyResults to proportions
#
propResults &lt;- subset(surveyResults, indicatorCode %in% steerIndicators$varList[steerIndicators$varFunction == &quot;proportion&quot;])

if(unique(country) == &quot;Bangladesh&quot;)
  {
  #
  # Cycle through indicators
  #
  for(i in propResults$indicatorCode)
    {
    #
    # Subset survey results to current indicator
    #
    tempResults &lt;- subset(propResults, indicatorCode == i)
    #
    # Merge survey area map with current indicator results
    #
    tempMap &lt;- merge(surveyArea, tempResults)
    #
    # Test directionality of indicator
    #
    varDirection &lt;- rep(steerIndicators$varDir[steerIndicators$varList == i], length(RdYlGn5))
    #
    # Open PNG graphics device - 1 x 3 layout
    #
    png(filename = paste(&quot;outputFigures/maps/&quot;, i, &quot;Est&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
        width = 15, height = 5, units = &quot;in&quot;, res = 100)
    #
    # Set plotting margins
    #
    par(mar = c(0,0,0,0), mfrow = c(1,3))
    #
    # Cycle through slum, other and total results
    #
    for(j in steerMap)
      {
      #
      # Categorise results
      #
      classes &lt;- ifelse(tempMap[[j]] &lt;= 0.2, 1,
                   ifelse(tempMap[[j]] &lt;= 0.4 &amp; tempMap[[j]] &gt; 0.2, 2,
                     ifelse(tempMap[[j]] &lt;= 0.6 &amp; tempMap[[j]] &gt; 0.4, 3,
                       ifelse(tempMap[[j]] &lt;= 0.8 &amp; tempMap[[j]] &gt; 0.6, 4, 5))))
      #
      # Plot current area type map
      #
      plot(surveyArea,
           col = ifelse(varDirection == &quot;lo&quot;, rev(aRdYlGn5)[classes], aRdYlGn5[classes]),
           border = ifelse(varDirection == &quot;lo&quot;, rev(RdYlGn5)[classes], RdYlGn5[classes]),
           lwd = 1)
      #
      # Plot survey area outline (survey area 1 to 9)
      #
      #plot(outline, border = &quot;gray50&quot;, lwd = 2, add = TRUE)
      #
      # Add title on top of map identifying slum, other or overall
      #
      title(main = ifelse(j == &quot;slumEst&quot;, &quot;Slum&quot;,
                     ifelse(j == &quot;otherEst&quot;, &quot;Other&quot;, &quot;Overall&quot;)), 
            line = -1)
      #
      # Add inset on rightmost map to show different survey area labels 
      #  
      if(j == &quot;totalEst&quot;)
        {
        #
        # Add inset 
        #
        par(plt = c(0.74, 0.99, 0.74, 0.99), new = TRUE)
        plot(surveyArea, lwd = 1, col = &quot;gray90&quot;, border = &quot;gray50&quot;)
        title(main = &quot;Survey Areas &quot;, line = -1, adj = 1, cex.main = 1)
        text(x = surveyArea, 
             labels = ifelse(surveyArea@data$surveyArea == &quot;Survey Area 1&quot;, 1,
                        ifelse(surveyArea@data$surveyArea == &quot;Survey Area 2&quot;, 2,
                          ifelse(surveyArea@data$surveyArea == &quot;Survey Area 3&quot;, 3,
                            ifelse(surveyArea@data$surveyArea == &quot;Survey Area 4&quot;, 4,
                              ifelse(surveyArea@data$surveyArea == &quot;Survey Area 5&quot;, 5,
                                ifelse(surveyArea@data$surveyArea == &quot;Survey Area 6&quot;, 6,
                                  ifelse(surveyArea@data$surveyArea == &quot;Survey Area 7&quot;, 7,
                                    ifelse(surveyArea@data$surveyArea == &quot;Survey Area 8&quot;, 8, 9)))))))), 
             cex = ifelse(surveyArea@data$surveyArea %in% c(&quot;Survey Area 5&quot;, &quot;Survey Area 8&quot;), 0.85, 1), 
             col = &quot;blue&quot;)
        box(which = &quot;plot&quot;, lty = &quot;solid&quot;, lwd = 1)
        }
      #
      # Add legend on leftmost map
      #
      if(j == &quot;slumEst&quot;)
        {
        #
        # Add legend
        #
        legend(x = &quot;bottomleft&quot;, inset = 0.01, y.intersp = 1.2,
               legend = c(&quot;20% or less&quot;,
                          &quot;21% to 40%&quot;,
                          &quot;41% to 60%&quot;,
                          &quot;61% to 80%&quot;,
                          &quot;81% to 100%&quot;),
               pch = 22, pt.cex = 2, 
               col = ifelse(varDirection == &quot;lo&quot;, rev(RdYlGn5), RdYlGn5),
               pt.bg = ifelse(varDirection == &quot;lo&quot;, rev(aRdYlGn5), aRdYlGn5),
               cex = 1)
        }
      }  
    #
    # Close graphics device
    #
    dev.off()
    }
  }

if(unique(country) != &quot;Bangladesh&quot;)
  {
  #
  # Cycle through indicators
  #
  for(i in propResults$indicatorCode)
    {
    #
    # Subset survey results to current indicator
    #
    tempResults &lt;- subset(propResults, indicatorCode == i)
    #
    # Merge survey area map with current indicator results
    #
    tempMap &lt;- merge(surveyArea, tempResults)
    #
    # Determine directionality of current indicator
    #
    varDirection &lt;- rep(steerIndicators$varDir[steerIndicators$varList == i], length(RdYlGn5))
    #
    # Open PNG graphics device - 1 x 3 layout
    #
    png(filename = paste(&quot;outputFigures/maps/&quot;, i, &quot;Est&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
        width = 15, height = 5, units = &quot;in&quot;, res = 100)
    #
    # Set plotting margins
    #
    par(mar = c(0,0,0,0), mfrow = c(1,3))
    #
    # Cycle through slum, other and total results
    #
    for(j in steerMap)
      {
      #
      # Categorise results
      #
      classes &lt;- ifelse(tempMap[[j]] &lt;= 0.2, 1,
                   ifelse(tempMap[[j]] &lt;= 0.4 &amp; tempMap[[j]] &gt; 0.2, 2,
                     ifelse(tempMap[[j]] &lt;= 0.6 &amp; tempMap[[j]] &gt; 0.4, 3,
                       ifelse(tempMap[[j]] &lt;= 0.8 &amp; tempMap[[j]] &gt; 0.6, 4, 5))))      
      #
      # Plot current area type map
      #
      plot(surveyArea,
           col = ifelse(varDirection == &quot;lo&quot;, rev(aRdYlGn5)[classes], aRdYlGn5[classes]),
           border = ifelse(varDirection == &quot;lo&quot;, rev(RdYlGn5)[classes], RdYlGn5[classes]),
           lwd = 1)
      #
      # Add title on top of map identifying slum, other or overall
      #
      title(main = ifelse(j == &quot;slumEst&quot;, &quot;Slum&quot;,
                     ifelse(j == &quot;otherEst&quot;, &quot;Other&quot;, &quot;Overall&quot;)), 
            line = -1)
      #
      # Add inset on rightmost map to show different survey area labels 
      #  
      if(j == &quot;totalEst&quot;)
        {
        #
        # Add inset 
        #
        par(plt = c(0.74, 0.99, 0.74, 0.99), new = TRUE)
        plot(surveyArea, lwd = 1, col = &quot;gray90&quot;, border = &quot;gray50&quot;)
        title(main = &quot;Survey Areas &quot;, line = -1, adj = 1, cex.main = 1)
        text(x = surveyArea, 
             labels = surveyArea@data$surveyArea, 
             cex = 1, 
             col = &quot;blue&quot;)
        box(which = &quot;plot&quot;, lty = &quot;solid&quot;, lwd = 1)
        }
      #
      # Add legend on leftmost map
      #
      if(j == &quot;slumEst&quot;)
        {
        #
        # Add legend
        #
        legend(x = &quot;bottomleft&quot;, inset = 0.01, y.intersp = 1.2,
               legend = c(&quot;20% or less&quot;,
                          &quot;21% to 40%&quot;,
                          &quot;41% to 60%&quot;,
                          &quot;61% to 80%&quot;,
                          &quot;81% to 100%&quot;),
               pch = 22, pt.cex = 2, 
               col = ifelse(varDirection == &quot;lo&quot;, rev(RdYlGn5), RdYlGn5),
               pt.bg = ifelse(varDirection == &quot;lo&quot;, rev(aRdYlGn5), aRdYlGn5),
               cex = 1)
        }
      }  
    #
    # Close graphics device
    #
    dev.off()
    }
  }

  


################################################################################
#
# Results mapping for mean indicators
#
################################################################################
#
# Create steering vector for slum, other, and total results
#
steerMap &lt;- c(&quot;slumEst&quot;, &quot;otherEst&quot;, &quot;totalEst&quot;)
#
# Subset surveyResults to mean results
#
meanResults &lt;- subset(surveyResults, indicatorCode %in% steerIndicators$varList[steerIndicators$varFunction == &quot;histogram&quot;])
#
#
#
if(unique(country) == &quot;Bangladesh&quot;)
  {
  #
  # Cycle through indicators
  #
  for(i in meanResults$indicatorCode)
    {
    #
    # Subset survey results to current indicator
    #
    tempResults &lt;- subset(meanResults, indicatorCode == i)
    #
    # Merge survey area map to current indicator results
    #
    tempMap &lt;- merge(surveyArea, tempResults)
    #
    # Open PNG graphics device - 1 x 3 layout
    #
    png(filename = paste(&quot;outputFigures/maps/&quot;, i, &quot;Mean&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
        width = 15, height = 5, units = &quot;in&quot;, res = 100)
    #
    # Set plotting margins
    #
    par(mar = c(0,0,0,0), mfrow = c(1,3))
    #
    # Cycle through slum, other, total results
    #
    for(j in steerMap)
      {
      #
      # Scale reuslts for current indicator using quantile function
      #
      tempScale &lt;- scaleValue(tempResults[[j]], n = 5, style = &quot;quantile&quot;)
      #
      # Get corresponding legend labels based on scaling of results
      #
      tempScaleLabel &lt;- classIntervals(tempResults[[j]], n = 5, style = &quot;quantile&quot;)    
      #
      # Plot current indicator map
      #
      plot(surveyArea,
           col = aYlBl5[tempScale],
         border = YlBl5[tempScale],
         lwd = 1)
      #
      # Add title on top of map identifying slum, other or overall
      #
      title(main = ifelse(j == &quot;slumEst&quot;, &quot;Slum&quot;,
                     ifelse(j == &quot;otherEst&quot;, &quot;Other&quot;, &quot;Overall&quot;)), 
            line = -1)
      #
      # Add legend
      #
     legend(x = &quot;bottomleft&quot;, inset = 0.01, y.intersp = 1.2,
            legend = c(names(print(tempScaleLabel, 
                                   cutlabels = FALSE))),
            pch = 22, pt.cex = 2, 
            col = c(YlBl5),
            pt.bg = c(aYlBl5),
            cex = 1)
      #
      # Add inset on rightmost map to show different survey area labels
      #  
      if(j == &quot;totalEst&quot;)
        {
        #
        # Add inset
        #
        par(plt = c(0.74, 0.99, 0.74, 0.99), new = TRUE)
        plot(surveyArea, lwd = 1, col = &quot;gray90&quot;, border = &quot;gray50&quot;)
        title(main = &quot;Survey Areas&quot;, line = -1, adj = 1, cex = 0.85)
        text(x = surveyArea, 
             labels = ifelse(surveyArea@data$surveyArea == &quot;Survey Area 1&quot;, 1,
                        ifelse(surveyArea@data$surveyArea == &quot;Survey Area 2&quot;, 2,
                          ifelse(surveyArea@data$surveyArea == &quot;Survey Area 3&quot;, 3,
                            ifelse(surveyArea@data$surveyArea == &quot;Survey Area 4&quot;, 4,
                              ifelse(surveyArea@data$surveyArea == &quot;Survey Area 5&quot;, 5,
                                ifelse(surveyArea@data$surveyArea == &quot;Survey Area 6&quot;, 6,
                                  ifelse(surveyArea@data$surveyArea == &quot;Survey Area 7&quot;, 7,
                                    ifelse(surveyArea@data$surveyArea == &quot;Survey Area 8&quot;, 8, 9)))))))), 
             cex = ifelse(surveyArea@data$surveyArea %in% c(&quot;Survey Area 5&quot;, &quot;Survey Area 8&quot;), 0.85, 1), 
             col = &quot;blue&quot;)
        box(which = &quot;plot&quot;, lty = &quot;solid&quot;, lwd = 1)
        }
      }
    #
    # Close graphics device
    #
    dev.off()
    }
  }

</command>
							<property title="Choropleth Maps" shape="CHART"/>
							<option type="com.ef_prime.rflow.node.base.SubflowNodeModel">
								<subflow>
									<graph version="0.8" width="1625" height="513" locationtype="a" offsetx="100" offsety="50">
										<node id="138" date="1510899093934" uid="3ab41479a5e085cb" x="-50" y="10">
											<command></command>
											<property/>
											<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
												<entry key="io">in</entry>
											</option>
										</node>
										<node id="139" date="1510899093934" uid="c130e7c4ba129c58" x="250" y="10">
											<command>
################################################################################
#
# Results mapping for mean indicators
#
################################################################################
#
# Create steering vector for slum, other, and total results
#
steerMap &lt;- c(&quot;slumEst&quot;, &quot;otherEst&quot;, &quot;totalEst&quot;)
#
# Subset surveyResults to mean results
#
meanResults &lt;- subset(surveyResults, indicatorCode %in% steerIndicators$varList[steerIndicators$varFunction == &quot;histogram&quot;])
#
#
#
if(unique(country) == &quot;Bangladesh&quot;)
  {
  #
  # Cycle through indicators
  #
  for(i in meanResults$indicatorCode)
    {
    #
    # Subset survey results to current indicator
    #
    tempResults &lt;- subset(meanResults, indicatorCode == i)
    #
    # Merge survey area map to current indicator results
    #
    tempMap &lt;- merge(surveyArea, tempResults)
    #
    # Open PNG graphics device - 1 x 3 layout
    #
    png(filename = paste(&quot;outputFigures/maps/&quot;, i, &quot;Mean&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
        width = 15, height = 5, units = &quot;in&quot;, res = 100)
    #
    # Set plotting margins
    #
    par(mar = c(0,0,0,0), mfrow = c(1,3))
    #
    # Cycle through slum, other, total results
    #
    for(j in steerMap)
      {
      #
      # Scale reuslts for current indicator using quantile function
      #
      tempScale &lt;- scaleValue(tempResults[[j]], n = 5, style = &quot;quantile&quot;)
      #
      # Get corresponding legend labels based on scaling of results
      #
      tempScaleLabel &lt;- classIntervals(tempResults[[j]], n = 5, style = &quot;quantile&quot;)    
      #
      # Plot current indicator map
      #
      plot(surveyArea,
           col = aYlBl5[tempScale],
         border = YlBl5[tempScale],
         lwd = 1)
      #
      # Add title on top of map identifying slum, other or overall
      #
      title(main = ifelse(j == &quot;slumEst&quot;, &quot;Slum&quot;,
                     ifelse(j == &quot;otherEst&quot;, &quot;Other&quot;, &quot;Overall&quot;)), 
            line = -1)
      #
      # Add legend
      #
     legend(x = &quot;bottomleft&quot;, inset = 0.01, y.intersp = 1.2,
            legend = c(names(print(tempScaleLabel, 
                                   cutlabels = FALSE))),
            pch = 22, pt.cex = 2, 
            col = c(YlBl5),
            pt.bg = c(aYlBl5),
            cex = 1)
      #
      # Add inset on rightmost map to show different survey area labels
      #  
      if(j == &quot;totalEst&quot;)
        {
        #
        # Add inset
        #
        par(plt = c(0.74, 0.99, 0.74, 0.99), new = TRUE)
        plot(surveyArea, lwd = 1, col = &quot;gray90&quot;, border = &quot;gray50&quot;)
        title(main = &quot;Survey Areas&quot;, line = -1, adj = 1, cex = 0.85)
        text(x = surveyArea, 
             labels = ifelse(surveyArea@data$surveyArea == &quot;Survey Area 1&quot;, 1,
                        ifelse(surveyArea@data$surveyArea == &quot;Survey Area 2&quot;, 2,
                          ifelse(surveyArea@data$surveyArea == &quot;Survey Area 3&quot;, 3,
                            ifelse(surveyArea@data$surveyArea == &quot;Survey Area 4&quot;, 4,
                              ifelse(surveyArea@data$surveyArea == &quot;Survey Area 5&quot;, 5,
                                ifelse(surveyArea@data$surveyArea == &quot;Survey Area 6&quot;, 6,
                                  ifelse(surveyArea@data$surveyArea == &quot;Survey Area 7&quot;, 7,
                                    ifelse(surveyArea@data$surveyArea == &quot;Survey Area 8&quot;, 8, 9)))))))), 
             cex = ifelse(surveyArea@data$surveyArea %in% c(&quot;Survey Area 5&quot;, &quot;Survey Area 8&quot;), 0.85, 1), 
             col = &quot;blue&quot;)
        box(which = &quot;plot&quot;, lty = &quot;solid&quot;, lwd = 1)
        }
      }
    #
    # Close graphics device
    #
    dev.off()
    }
  }

</command>
											<property title="Map mean" shape="CHART"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<node id="140" date="1510899093934" uid="ac3f8de1f602d7fc" x="30" y="10">
											<command>
################################################################################
#
# Results mapping for proprtion indicators
#
################################################################################
#
# Create steering vector for slum, other, and total results
#
steerMap &lt;- c(&quot;slumClass&quot;, &quot;otherClass&quot;)
#
# Subset surveyResults to proportions
#
propResults &lt;- subset(surveyResults, indicatorCode %in% steerIndicators$varList[steerIndicators$varFunction == &quot;proportion&quot;])
#
# Cycle through indicators
#
for(i in propResults$indicatorCode)
  {
  #
  # Subset survey results to current indicator
  #
  tempResults &lt;- subset(propResults, indicatorCode == i)
  #
  # Merge survey area map with current indicator results
  #
  tempMap &lt;- merge(surveyArea, tempResults)
  #
  # Determine directionality of indicator
  #
  varDirection  &lt;- rep(steerIndicators$varDir[steerIndicators$varList == i], length(RdYlGn5))
  #
  #
  # Open PNG graphics device - 1 x 3 layout
  #
  png(filename = paste(&quot;outputFigures/maps/&quot;, i, &quot;Class&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
      width = 10, height = 5, units = &quot;in&quot;, res = 100)
  #
  # Set plotting margins
  #
  par(mar = c(0,0,0,0), mfrow = c(1,2))
  #
  # Cycle through slum, other and total results
  #
  for(j in steerMap)
    {
    #
    #
    #
    classes &lt;- ifelse(tempMap[[j]] == &quot;Low&quot;, 1,
                 ifelse(tempMap[[j]] == &quot;Moderate&quot;, 2, 3))
    #
    # Plot current area type map
    #
    plot(surveyArea,
         col = ifelse(varDirection == &quot;lo&quot;, rev(aRdYlGn3)[classes], aRdYlGn3[classes]),
         border = ifelse(varDirection == &quot;lo&quot;, rev(RdYlGn3)[classes], RdYlGn3),
         lwd = 1)
    #
    # Plot survey area outline (survey area 1 to 9)
    #
    #plot(outline, border = &quot;gray50&quot;, lwd = 2, add = TRUE)
    #
    # Add title on top of map identifying slum, other or overall
    #
    title(main = ifelse(j == &quot;slumClass&quot;, &quot;Slum&quot;, &quot;Other&quot;), 
          line = -1)
    #
    # Add inset on rightmost map to show different survey area labels 
    #  
    if(j == &quot;otherClass&quot;)
      {
      #
      # Add inset 
      #
      par(plt = c(0.74, 0.99, 0.74, 0.99), new = TRUE)
      plot(surveyArea, lwd = 1, col = &quot;gray90&quot;, border = &quot;gray50&quot;)
      title(main = &quot;Survey Areas &quot;, line = -1, adj = 1, cex.main = 1)
      text(x = surveyArea, 
           labels = ifelse(surveyArea@data$surveyArea == &quot;Survey Area 1&quot;, 1,
                      ifelse(surveyArea@data$surveyArea == &quot;Survey Area 2&quot;, 2,
                        ifelse(surveyArea@data$surveyArea == &quot;Survey Area 3&quot;, 3,
                          ifelse(surveyArea@data$surveyArea == &quot;Survey Area 4&quot;, 4,
                            ifelse(surveyArea@data$surveyArea == &quot;Survey Area 5&quot;, 5,
                              ifelse(surveyArea@data$surveyArea == &quot;Survey Area 6&quot;, 6,
                                ifelse(surveyArea@data$surveyArea == &quot;Survey Area 7&quot;, 7,
                                  ifelse(surveyArea@data$surveyArea == &quot;Survey Area 8&quot;, 8, 9)))))))), 
           cex = ifelse(surveyArea@data$surveyArea %in% c(&quot;Survey Area 5&quot;, &quot;Survey Area 8&quot;), 0.85, 1), 
           col = &quot;blue&quot;)
      box(which = &quot;plot&quot;, lty = &quot;solid&quot;, lwd = 1)
      }
    #
    # Add legend on leftmost map
    #
    if(j == &quot;slumClass&quot;)
      {
      #
      # Add legend
      #
      legend(x = &quot;bottomleft&quot;, inset = 0.01, y.intersp = 1.2,
             legend = c(&quot;Low&quot;,
                        &quot;Moderate&quot;,
                        &quot;High&quot;),
             pch = 22, pt.cex = 2, 
             col = ifelse(varDirection == &quot;lo&quot;, rev(RdYlGn3), RdYlGn3),
             pt.bg = ifelse(varDirection == &quot;lo&quot;, rev(aRdYlGn3), aRdYlGn3),
             cex = 1)
      }
    }
  #
  # Close graphics device
  #
  dev.off()
  }
</command>
											<property title="Map classes" shape="CHART"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<node id="141" date="1510899093934" uid="4534407ea0c5d5e8" x="330" y="10">
											<command></command>
											<property/>
											<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
												<entry key="io">out</entry>
											</option>
										</node>
										<node id="142" date="1510899093934" uid="22cb0d32abc3f88b" x="140" y="10">
											<command>
################################################################################
#
# Results mapping for proprtion indicators
#
################################################################################
#
# Create steering vector for slum, other, and total results
#
steerMap &lt;- c(&quot;slumEst&quot;, &quot;otherEst&quot;, &quot;totalEst&quot;)
#
# Subset surveyResults to proportions
#
propResults &lt;- subset(surveyResults, indicatorCode %in% steerIndicators$varList[steerIndicators$varFunction == &quot;proportion&quot;])

if(unique(country) == &quot;Bangladesh&quot;)
  {
  #
  # Cycle through indicators
  #
  for(i in propResults$indicatorCode)
    {
    #
    # Subset survey results to current indicator
    #
    tempResults &lt;- subset(propResults, indicatorCode == i)
    #
    # Merge survey area map with current indicator results
    #
    tempMap &lt;- merge(surveyArea, tempResults)
    #
    # Test directionality of indicator
    #
    varDirection &lt;- rep(steerIndicators$varDir[steerIndicators$varList == i], length(RdYlGn5))
    #
    # Open PNG graphics device - 1 x 3 layout
    #
    png(filename = paste(&quot;outputFigures/maps/&quot;, i, &quot;Est&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
        width = 15, height = 5, units = &quot;in&quot;, res = 100)
    #
    # Set plotting margins
    #
    par(mar = c(0,0,0,0), mfrow = c(1,3))
    #
    # Cycle through slum, other and total results
    #
    for(j in steerMap)
      {
      #
      # Categorise results
      #
      classes &lt;- ifelse(tempMap[[j]] &lt;= 0.2, 1,
                   ifelse(tempMap[[j]] &lt;= 0.4 &amp; tempMap[[j]] &gt; 0.2, 2,
                     ifelse(tempMap[[j]] &lt;= 0.6 &amp; tempMap[[j]] &gt; 0.4, 3,
                       ifelse(tempMap[[j]] &lt;= 0.8 &amp; tempMap[[j]] &gt; 0.6, 4, 5))))
      #
      # Plot current area type map
      #
      plot(surveyArea,
           col = ifelse(varDirection == &quot;lo&quot;, rev(aRdYlGn5)[classes], aRdYlGn5[classes]),
           border = ifelse(varDirection == &quot;lo&quot;, rev(RdYlGn5)[classes], RdYlGn5[classes]),
           lwd = 1)
      #
      # Plot survey area outline (survey area 1 to 9)
      #
      #plot(outline, border = &quot;gray50&quot;, lwd = 2, add = TRUE)
      #
      # Add title on top of map identifying slum, other or overall
      #
      title(main = ifelse(j == &quot;slumEst&quot;, &quot;Slum&quot;,
                     ifelse(j == &quot;otherEst&quot;, &quot;Other&quot;, &quot;Overall&quot;)), 
            line = -1)
      #
      # Add inset on rightmost map to show different survey area labels 
      #  
      if(j == &quot;totalEst&quot;)
        {
        #
        # Add inset 
        #
        par(plt = c(0.74, 0.99, 0.74, 0.99), new = TRUE)
        plot(surveyArea, lwd = 1, col = &quot;gray90&quot;, border = &quot;gray50&quot;)
        title(main = &quot;Survey Areas &quot;, line = -1, adj = 1, cex.main = 1)
        text(x = surveyArea, 
             labels = ifelse(surveyArea@data$surveyArea == &quot;Survey Area 1&quot;, 1,
                        ifelse(surveyArea@data$surveyArea == &quot;Survey Area 2&quot;, 2,
                          ifelse(surveyArea@data$surveyArea == &quot;Survey Area 3&quot;, 3,
                            ifelse(surveyArea@data$surveyArea == &quot;Survey Area 4&quot;, 4,
                              ifelse(surveyArea@data$surveyArea == &quot;Survey Area 5&quot;, 5,
                                ifelse(surveyArea@data$surveyArea == &quot;Survey Area 6&quot;, 6,
                                  ifelse(surveyArea@data$surveyArea == &quot;Survey Area 7&quot;, 7,
                                    ifelse(surveyArea@data$surveyArea == &quot;Survey Area 8&quot;, 8, 9)))))))), 
             cex = ifelse(surveyArea@data$surveyArea %in% c(&quot;Survey Area 5&quot;, &quot;Survey Area 8&quot;), 0.85, 1), 
             col = &quot;blue&quot;)
        box(which = &quot;plot&quot;, lty = &quot;solid&quot;, lwd = 1)
        }
      #
      # Add legend on leftmost map
      #
      if(j == &quot;slumEst&quot;)
        {
        #
        # Add legend
        #
        legend(x = &quot;bottomleft&quot;, inset = 0.01, y.intersp = 1.2,
               legend = c(&quot;20% or less&quot;,
                          &quot;21% to 40%&quot;,
                          &quot;41% to 60%&quot;,
                          &quot;61% to 80%&quot;,
                          &quot;81% to 100%&quot;),
               pch = 22, pt.cex = 2, 
               col = ifelse(varDirection == &quot;lo&quot;, rev(RdYlGn5), RdYlGn5),
               pt.bg = ifelse(varDirection == &quot;lo&quot;, rev(aRdYlGn5), aRdYlGn5),
               cex = 1)
        }
      }  
    #
    # Close graphics device
    #
    dev.off()
    }
  }

if(unique(country) != &quot;Bangladesh&quot;)
  {
  #
  # Cycle through indicators
  #
  for(i in propResults$indicatorCode)
    {
    #
    # Subset survey results to current indicator
    #
    tempResults &lt;- subset(propResults, indicatorCode == i)
    #
    # Merge survey area map with current indicator results
    #
    tempMap &lt;- merge(surveyArea, tempResults)
    #
    # Determine directionality of current indicator
    #
    varDirection &lt;- rep(steerIndicators$varDir[steerIndicators$varList == i], length(RdYlGn5))
    #
    # Open PNG graphics device - 1 x 3 layout
    #
    png(filename = paste(&quot;outputFigures/maps/&quot;, i, &quot;Est&quot;, unique(ccode), &quot;.png&quot;, sep = &quot;&quot;),
        width = 15, height = 5, units = &quot;in&quot;, res = 100)
    #
    # Set plotting margins
    #
    par(mar = c(0,0,0,0), mfrow = c(1,3))
    #
    # Cycle through slum, other and total results
    #
    for(j in steerMap)
      {
      #
      # Categorise results
      #
      classes &lt;- ifelse(tempMap[[j]] &lt;= 0.2, 1,
                   ifelse(tempMap[[j]] &lt;= 0.4 &amp; tempMap[[j]] &gt; 0.2, 2,
                     ifelse(tempMap[[j]] &lt;= 0.6 &amp; tempMap[[j]] &gt; 0.4, 3,
                       ifelse(tempMap[[j]] &lt;= 0.8 &amp; tempMap[[j]] &gt; 0.6, 4, 5))))      
      #
      # Plot current area type map
      #
      plot(surveyArea,
           col = ifelse(varDirection == &quot;lo&quot;, rev(aRdYlGn5)[classes], aRdYlGn5[classes]),
           border = ifelse(varDirection == &quot;lo&quot;, rev(RdYlGn5)[classes], RdYlGn5[classes]),
           lwd = 1)
      #
      # Add title on top of map identifying slum, other or overall
      #
      title(main = ifelse(j == &quot;slumEst&quot;, &quot;Slum&quot;,
                     ifelse(j == &quot;otherEst&quot;, &quot;Other&quot;, &quot;Overall&quot;)), 
            line = -1)
      #
      # Add inset on rightmost map to show different survey area labels 
      #  
      if(j == &quot;totalEst&quot;)
        {
        #
        # Add inset 
        #
        par(plt = c(0.74, 0.99, 0.74, 0.99), new = TRUE)
        plot(surveyArea, lwd = 1, col = &quot;gray90&quot;, border = &quot;gray50&quot;)
        title(main = &quot;Survey Areas &quot;, line = -1, adj = 1, cex.main = 1)
        text(x = surveyArea, 
             labels = surveyArea@data$surveyArea, 
             cex = 1, 
             col = &quot;blue&quot;)
        box(which = &quot;plot&quot;, lty = &quot;solid&quot;, lwd = 1)
        }
      #
      # Add legend on leftmost map
      #
      if(j == &quot;slumEst&quot;)
        {
        #
        # Add legend
        #
        legend(x = &quot;bottomleft&quot;, inset = 0.01, y.intersp = 1.2,
               legend = c(&quot;20% or less&quot;,
                          &quot;21% to 40%&quot;,
                          &quot;41% to 60%&quot;,
                          &quot;61% to 80%&quot;,
                          &quot;81% to 100%&quot;),
               pch = 22, pt.cex = 2, 
               col = ifelse(varDirection == &quot;lo&quot;, rev(RdYlGn5), RdYlGn5),
               pt.bg = ifelse(varDirection == &quot;lo&quot;, rev(aRdYlGn5), aRdYlGn5),
               cex = 1)
        }
      }  
    #
    # Close graphics device
    #
    dev.off()
    }
  }

  </command>
											<property title="Map proportions" shape="CHART"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<edge from="142" to="139"/>
										<edge from="139" to="141"/>
										<edge from="140" to="142"/>
										<edge from="138" to="140"/>
									</graph>
								</subflow>
							</option>
						</node>
						<node id="143" date="1510899093934" uid="51338a05a2fd4af0" x="1150" y="220" disabled="true">
							<command>
################################################################################
#                                                                              #
# Step 4b: Specify number of bootstrap replicates                              #
#                                                                              #
#      This step asks the user to specify the parameters needed to             #
#      perform bootstrap analysis on the indicators data.                      #
#                                                                              #
#      Specifically, the user is asked to specify the number of bootstrap      #
#      replicates that will be used to estimate the indicator and provide      #
#      a 95% confidence interval.                                              #
#                                                                              #
#     The default (and the minimum recommendeded) replicates for use in        #
#     bootstrapping is 399 replicates. The specified replicates should be no   #
#     less than 399.                                                           #
#                                                                              #
#     A bootstrap estimator using 399 replicates will take about 30-45         #
#     minutes to complete the estimation of the full indicator set per survey  #
#     area. So, the total time for the bootstrap estimator to complete will    #
#     be a factor of the number of survey areas. Replicates greater than 399   #
#     will take longer.                                                        #
#                                                                              #
################################################################################</command>
							<property title="Run STEP 4b" shape="STAR">
								<comment state="opened" x="60" y="-20">STEP 4b: Specify number 
         of bootstrap
         replicates      </comment>
							</property>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<edge from="76" to="74"/>
						<edge from="118" to="115"/>
						<edge from="79" to="75"/>
						<edge from="137" to="120"/>
						<edge from="131" to="137"/>
						<edge from="83" to="81"/>
						<edge from="122" to="143"/>
						<edge from="111" to="79"/>
						<edge from="94" to="117"/>
					</graph>
				</subflow>
			</option>
		</node>
		<node id="144" date="1510899093929" uid="4430abe47360d3aa" x="-90" y="530">
			<command>
################################################################################
#                                                                              #
# Step 3: Recode and calculate indicators                                      #
#                                                                              #
#    This step recodes survey data and calculates the various indicators       #
#    based on the analysis that will be done.                                  #
#                                                                              #
#    Indicator sets produced are:                                              #
#                                                                              #
#    1. Poverty indicator     - based on Progress out of Poverty Index         #
#    2. Water indicators      - based on post-2015 Joint Monitoring Programme  #
#                               indicator set                                  #
#    3. Sanitation indicators - based on post-2015 Joint Monitoring Programme  #
#                               indicator set                                  #
#                                                                              #
#    Indicator sets are merged into a single indicator data.frame and is       #
#    saved as a CSV in the &apos;data&apos; folder in the working directory              #
#                                                                              #
#                                                                              #
################################################################################</command>
			<property title="Run STEP 3" shape="STAR">
				<comment state="opened" x="60" y="-20">STEP 3: Re-code and cal-
        culate indicators</comment>
			</property>
			<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
		</node>
		<node id="145" date="1510899093932" uid="b7fbbc97e7123e92" x="-410" y="640">
			<command></command>
			<property/>
			<option type="com.ef_prime.rflow.node.base.CommentNodeModel">
				<entry key="state">opened</entry>
				<entry key="comment">####################
#                  #
#   D. ANALYSIS    #
#                  #
####################</entry>
			</option>
		</node>
		<node id="146" date="1510899093932" uid="43d0a07f11c9e10a" x="-90" y="110">
			<command>
################################################################################
#                                                                              #
# Install packages                                                             #
#                                                                              #
#      This workflow requires certain libraries of code/functions              #
#      created by various individuals and organisations for different          #
#      purposes. Some libraries are installed into R by default and can be     #
#      called into a current R workspace by using the library() function.      #
#      For others, the required packages need to be installed first into R     #
#      before they can be called into a current R workspace using the          #
#      library() function.                                                     #
#                                                                              #
#      The installation of the packages need to be done only once. Once        #
#      installed, these packages can be called into a current R workspace      #
#      using the library() function.                                           #
#                                                                              #
#      The following packages need to be installed first before continuing     #
#      on with the next steps/nodes for analysis. If these packages are        #
#      already installed in the R in your machine, you can opt to skip this    #
#      step/node. Running this step/node even if you have the packages         #
#      installed in the R in your machine just re-installs these packages      #
#      and does not in any way affect R and its capabilities.                  #
#                                                                              #
#      The following command to install packages will be downloaded from the   #
#      internet and installed locally into your machine. If unable to download #
#      the pacakges, a prompt will be shown to install packages from a local   #
#      source (i.e., package files saved in your computer or on a drive).      #
#                                                                              #
################################################################################


install.packages(c(&quot;stringr&quot;, &quot;maptools&quot;, &quot;rgeos&quot;, &quot;rgdal&quot;, &quot;gstat&quot;, &quot;ggmap&quot;,
                   &quot;raster&quot;, &quot;FNN&quot;, &quot;classInt&quot;, &quot;scales&quot;, &quot;classInt&quot;, &quot;tcltk2&quot;,
                   &quot;ggplot2&quot;, &quot;shiny&quot;, &quot;purrr&quot;, &quot;Hmisc&quot;, &quot;stringr&quot;, &quot;maps&quot;))

</command>
			<property title="Install packages" shape="STAR">
				<comment state="opened" x="60" y="-10">STEP 0: Install Packages </comment>
			</property>
			<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
		</node>
		<node id="147" date="1510899093929" uid="28e29ce5f400a747" x="-410" y="600">
			<command></command>
			<property/>
			<option type="com.ef_prime.rflow.node.base.CommentNodeModel">
				<entry key="state">opened</entry>
				<entry key="comment">################################################################################</entry>
			</option>
		</node>
		<node id="148" date="1510899093931" uid="74f608b20278b13f" x="-190" y="530">
			<command>
################################################################################
#
# Read processed data
#
################################################################################

surveyData &lt;- read.csv(
	           file = paste(&quot;data/workingSurveyData&quot;, unique(ccode), &quot;.csv&quot;, sep = &quot;&quot;),
	           header = TRUE, sep = &quot;,&quot;
	         )

	


################################################################################
#
# Admin data
#
################################################################################
#
# Extract identifier data
#
adminDF &lt;- surveyData[ , c(&quot;country&quot;, &quot;ccode&quot;, &quot;uniqueID&quot;, &quot;psu&quot;,
	                      &quot;zone&quot;, &quot;type&quot;, &quot;quadrat&quot;, &quot;hhid&quot;, &quot;month&quot;, &quot;year&quot;,
	                      &quot;longitude&quot;, &quot;latitude&quot;)]



################################################################################
#
# Demographics data
#
################################################################################
#
# Extract demographic data
#
demoDF &lt;- surveyData[ , c(&quot;uniqueID&quot;, &quot;gender&quot;, &quot;landOwnStatus&quot;,
	                     &quot;nWomen&quot;, &quot;nMen&quot;, &quot;nOldWomen&quot;, &quot;nOldMen&quot;,
	                     &quot;nGirls&quot;, &quot;nBoys&quot;, &quot;nInfants&quot;, &quot;nMobility&quot;)]
#
# Count total number of household members
#
nMembers &lt;- surveyData$nWomen + surveyData$nMen + 
            surveyData$nOldMen + surveyData$nOldWomen + 
            surveyData$nGirls + surveyData$nBoys + 
            surveyData$nInfants
#
# Create demographic data.frame
#
demoDF &lt;- data.frame(demoDF, nMembers)
#
# Clean-up
#
rm(nMembers)



################################################################################
#
# Progress out of Poverty Index (PPI) - Bangladesh
#
################################################################################
#
# Check if country is Bangladesh
#
if(unique(surveyData$country) == &quot;Bangladesh&quot;)
  {
  #
  # ppi1: Number of household members 12-years old or younger 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;None&quot;, 32,
  	       ifelse(surveyData$ppi1 == &quot;One&quot;, 16,
		    ifelse(surveyData$ppi1 == &quot;Two&quot;, 10, 0)))
  #
  # ppi2: Do household members 6-12 years old attend school?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;Yes&quot;, 6, 0)
  #
  # ppi3: In past year, any household member do paid work?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;No&quot;, 8, 0)
  #
  # ppi4: Number of rooms used by household
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Three or more&quot;, 5,
	       ifelse(surveyData$ppi4 == &quot;Two&quot;, 3, 0))
  #
  # ppi5: Main construction material of the walls of the main room
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;Brick/cement&quot;, 9,
	       ifelse(surveyData$ppi5 == &quot;Mud brick, or C.I. sheet/wood&quot;, 2, 0))
  #
  # ppi6: Does the household own television?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Yes&quot;, 7, 0)
  #
  # ppi7: Number of fans the household owns
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;Two or more&quot;, 7,
       	  ifelse(surveyData$ppi7 == &quot;One&quot;, 4, 0))
  #
  # ppi8: Number of mobile phones the household owns
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;Two or more&quot;, 15,
  	       ifelse(surveyData$ppi8 == &quot;One&quot;, 8, 0))
  #
  # ppi9: Does household own bicycles, motorcycles/scooters, cars?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;Yes&quot;, 4, 0)
  #
  # ppi10: Does the household own/rent/sharecrop/mortgage in or out 51 or more
  #        decimals of cultivable agricultural land
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;Yes&quot;, 7, 0)
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: load lookup table
  #
  #ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableBGD.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrixBGD[ppiMatrixBGD[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }




################################################################################
#
# Progress out of Poverty Index (PPI) - Ghana
#
################################################################################
#
# Check if country is Ghana
#
if(unique(surveyData$country) == &quot;Ghana&quot;)
  {
  #
  # ppi1: Number of household members 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;One&quot;, 29,
		  ifelse(surveyData$ppi1 == &quot;Two&quot;, 24,
		    ifelse(surveyData$ppi1 == &quot;Three&quot;, 21,
		      ifelse(surveyData$ppi1 == &quot;Four&quot;, 14,
		        ifelse(surveyData$ppi1 == &quot;Five&quot;, 13,
		          ifelse(surveyData$ppi1 == &quot;Six&quot;, 9,
		            ifelse(surveyData$ppi1 == &quot;Seven&quot;, 4, 0)))))))
  #
  # ppi2: Are all household members ages 5 to 17 currently in school?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;Yes&quot;, 2, 
            ifelse(surveyData$ppi2 == &quot;No one ages 5 to 17&quot;, 3, 0))
  #
  # ppi3: Can the male head/spouse read a phrase/sentence in English?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;No male head/spouse&quot;, 2,
            ifelse(surveyData$ppi3 == &quot;Yes&quot;, 5, 0))
  #
  # ppi4: What is the main construction material used for the outer wall?
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Cement/concrete blocks, landcrete, stone, or burnt bricks&quot;, 5, 0)
  #
  # ppi5: What type of toilet facility is usually used by the household?
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;KVIP, or W.C.&quot;, 6,
		  ifelse(surveyData$ppi5 == &quot;Public toilet (e.g., W.C., KVIP, pitpan)&quot;, 4, 
		    ifelse(surveyData$ppi5 == &quot;Pit latrine, bucket/pan&quot;, 4, 0)))
  #
  # ppi6: What is the main fuel used by the household for cooking?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Gas, or electricity&quot;, 22,
            ifelse(surveyData$ppi6 == &quot;Charcoal, or kerosene&quot;, 13,
              ifelse(surveyData$ppi6 == &quot;Wood, crop residue, sawdust, animal waste, or other&quot;, 6, 0)))
  #
  # ppi7: Does any household member own a working box iron or electric iron?
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;Yes&quot;, 4, 0)
  #
  # ppi8: Does any household member own a working television, video player,
  #       VCD/DVD/MP3/MP4 player/iPod, or satellite dish?
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;No&quot;, 0,
		  ifelse(surveyData$ppi8 == &quot;Only television&quot;, 2, 8))
  #
  # ppi9: How many working mobile phones are owned by members of the household?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;None&quot;, 0,
            ifelse(surveyData$ppi9 == &quot;One&quot;, 4,
              ifelse(surveyData$ppi9 == &quot;Two&quot;, 8, 10)))
  #
  # ppi10: Does any household member own a working bicycle, motor cycle, or car?
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;None&quot;, 0,
             ifelse(surveyData$ppi10 == &quot;Only bicycle&quot;, 3, 8))
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: lookup table
  #
  #ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableGHA.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrixGHA[ppiMatrixGHA[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }




################################################################################
#
# Progress out of Poverty Index (PPI) - Mozambique
#
################################################################################
#
# Check if country is Mozambique
#
if(unique(surveyData$country) == &quot;Mozambique&quot;)
  {
  #
  # ppi1: How many members does the household have 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;One&quot;, 34,
		  ifelse(surveyData$ppi1 == &quot;Two&quot;, 30,
		    ifelse(surveyData$ppi1 == &quot;Three&quot;, 23, 
		      ifelse(surveyData$ppi1 == &quot;Four&quot;, 15,
		        ifelse(surveyData$ppi1 == &quot;Five&quot;, 9,
		          ifelse(surveyData$ppi1 == &quot;Six&quot;, 7,
		            ifelse(surveyData$ppi1 == &quot;Seven&quot;, 2, 0)))))))
  #
  # ppi2: What is the main material of the floor of the residence (excluding
  #       kitchen and bathrooms)?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;Uncovered, or other&quot;, 0, 6)
  #
  # ppi3: What is the main material of the walls of the residence?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;Adobe blocks, wattle and daub, cement blocks, or bricks&quot;, 7, 0)
  #
  # ppi4: What toilet arrangement does the household use in its residence?
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Toilet connected to a septic tank&quot;, 14,
	  	  ifelse(surveyData$ppi4 == &quot;Latrine of any kind&quot;, 6, 0))
  #
  # ppi5: What is the main source of energy for lighting in the residence?
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;Electricity, generator, or solar panel&quot;, 5,
		  ifelse(surveyData$ppi5 == &quot;Other&quot;, 3, 
		    ifelse(surveyData$ppi5 == &quot;LPG, oil/paraffin/kerosene, or candles&quot;, 1, 0)))
  #
  # ppi6: Does the household have a non-electric or electric clothes iron?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Yes&quot;, 3, 0)
  #
  # ppi7: Does the household have a clock (wall, wrist, or pocket)?
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;Yes&quot;, 4, 0)
  #
  # ppi8: Does the household have a radio, stereo system, or cassette player?
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;Stereo system or cassette player (regardless of radio)&quot;, 7,
		  ifelse(surveyData$ppi8 == &quot;Radio only&quot;, 5, 0))
  #
  # ppi9: Does the household have a bicycle, motorcycle, or car?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;No&quot;, 0,
            ifelse(surveyData$ppi9 == &quot;Bicycle only&quot;, 5, 15))
  #
  # ppi10: How many beds does the household have (single, double, 
  #        beds, or for children)?
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;None&quot;, 0,
             ifelse(surveyData$ppi10 == &quot;One&quot;, 2, 5))
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: lookup table
  #
  #ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableMOZ.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrixMOZ[ppiMatrixMOZ[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }




################################################################################
#
# Progress out of Poverty Index (PPI) - Kenya
#
################################################################################
#
# Check if country is Kenya
#
if(unique(surveyData$country) == &quot;Kenya&quot;)
  {
  #
  # ppi1: How many members does the household have 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;One or two&quot;, 32,
		  ifelse(surveyData$ppi1 == &quot;Three&quot;, 22,
		    ifelse(surveyData$ppi1 == &quot;Four&quot;, 18, 
		      ifelse(surveyData$ppi1 == &quot;Five&quot;, 12,
		        ifelse(surveyData$ppi1 == &quot;Six&quot;, 8,
		          ifelse(surveyData$ppi1 == &quot;Seven or eight&quot;, 5, 0))))))
  #
  # ppi2: What is the highest school grade that the female head/spouse has 
  #       completed?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;Secondary form 4 or higher&quot;, 11,
            ifelse(surveyData$ppi2 == &quot;No female head/spouse&quot;, 6,
              ifelse(surveyData$ppi2 == &quot;Primary standard 8, or secondary forms 1 to 3&quot;, 6,
                ifelse(surveyData$ppi2 == &quot;Primary standard 7&quot;, 2,
                  ifelse(surveyData$ppi2 == &quot;Primary standards 1 to 6&quot;, 1, 0)))))
  #
  # ppi3: What kind of business (type of industry) is the main occupation of the
  #       male head/spouse connected with?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;Any other&quot;, 9, 
            ifelse(surveyData$ppi3 == &quot;Agriculture, hunting, forestry, fishing, mining, or quarrying&quot;, 7,
              ifelse(surveyData$ppi3 == &quot;No male head/spouse&quot;, 3,
                ifelse(surveyData$ppi3 == &quot;Sixth grade&quot;, 2, 0))))
  #
  # ppi4: How many habitable rooms does this household occupy in its main
  #       dwelling (do not count bathrooms, toilets, storerooms, or gargage)?
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Four or more&quot;, 8,
            ifelse(surveyData$ppi4 == &quot;Three&quot;, 5,
              ifelse(surveyData$ppi4 == &quot;Two&quot;, 2, 0)))
  #
  # ppi5: The floor of the main dwelling is predominantly made of what material?
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;Cement, or tiles&quot;, 3, 0)
  #
  # ppi6: What is the main source of lighting fuel for the household?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Electricity, solar, or gas&quot;, 12,
            ifelse(surveyData$ppi6 == &quot;Paraffin, candles, biogas, or other&quot;, 6, 0))
  #
  # ppi7: Does your household own any irons (charcoal or electric)?
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;Yes&quot;, 4, 0)
  #
  # ppi8: How many mosquito nets does your household own?
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;Two or more&quot;, 4,
		    ifelse(surveyData$ppi8 == &quot;One&quot;, 2, 0))
  #
  # ppi9: How many towels does your household own?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;Two or more&quot;, 10,
            ifelse(surveyData$ppi9 == &quot;One&quot;, 6, 0))
  #
  # ppi10: How many frying pans does your household own?
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;Two or more&quot;, 7,
             ifelse(surveyData$ppi10 == &quot;One&quot;, 3, 0))
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: lookup table
  #
  #ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableKEN.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrixKEN[ppiMatrixKEN[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }




################################################################################
#
# Progress out of Poverty Index (PPI) - Madagascar
#
################################################################################
#
# Check if country is Madagascar
#
if(unique(surveyData$country) == &quot;Madagascar&quot;)
  {
  #
  # ppi1: How many members does the household have 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;One&quot;, 38,
		  ifelse(surveyData$ppi1 == &quot;Two&quot;, 33,
		    ifelse(surveyData$ppi1 == &quot;Three&quot;, 25, 
		      ifelse(surveyData$ppi1 == &quot;Four&quot;, 19,
		        ifelse(surveyData$ppi1 == &quot;Five&quot;, 13,
		          ifelse(surveyData$ppi1 == &quot;Six&quot;, 9,
		            ifelse(surveyData$ppi1 == &quot;Seven&quot;, 6,
		              ifelse(surveyData$ppi1 == &quot;Eight&quot;, 5, 0))))))))
  #
  # ppi2: Can the (oldest) female head/spouse read a simple message?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;No&quot;, 0,
            ifelse(surveyData$ppi2 == &quot;Yes&quot;, 2, 3))
  #
  # ppi3: What is the main material of the floor of the residence?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;Cement, concrete, or fiberglass&quot;, 11, 
            ifelse(surveyData$ppi3 == &quot;Wood, stone, or brick&quot;, 8,
              ifelse(surveyData$ppi3 == &quot;Dirt (with or without mats)&quot;, 5, 0)))
  #
  # ppi4: What is the main permanent ceiling material?
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Bark, leaves, stems, dirt, or mud&quot;, 0,
            ifelse(surveyData$ppi4 == &quot;No ceiling, or other&quot;, 3, 7))
  #
  # ppi5: How many tables does the household have?
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;Two or more&quot;, 6,
            ifelse(surveyData$ppi5 == &quot;One&quot;, 2, 0))
  #
  # ppi6: How many beds does the household have?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Three or more&quot;, 9,
            ifelse(surveyData$ppi6 == &quot;Two&quot;, 4,
              ifelse(surveyData$ppi6 == &quot;One&quot;, 2, 0)))
  #
  # ppi7: Does the household have a radio, radio/cassette player, or hi-fi
  #       stereo system?
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;Yes&quot;, 5, 0)
  #
  # ppi8: Does the household have a television?
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;Yes&quot;, 14, 0)
  #
  # ppi9: Does the household have a bicycle, motorcycle/scooter, tractor or
  #       car of its own (not counting business vehicles)?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;Yes&quot;, 4, 0)
  #
  # ppi10: Does the household have an agricultural storage shed?
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;Yes&quot;, 3, 0)
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: lookup table
  #
  #ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableMDG.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrixMDG[ppiMatrixMDG[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }




################################################################################
#
# Progress out of Poverty Index (PPI) - Zambia
#
################################################################################
#
# Check if country is Zambia
#
if(unique(surveyData$country) == &quot;Zambia&quot;)
  {
  #
  # ppi1: How many members does the household have 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;One or two&quot;, 29,
		  ifelse(surveyData$ppi1 == &quot;Three&quot;, 21,
		    ifelse(surveyData$ppi1 == &quot;Four&quot;, 15, 
		      ifelse(surveyData$ppi1 == &quot;Five&quot;, 11,
		        ifelse(surveyData$ppi1 == &quot;Six&quot;, 9,
		          ifelse(surveyData$ppi1 == &quot;Seven&quot;, 7, 0))))))
  #
  # ppi2: Are all household members ages 7 to 16 currently attending school?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;No&quot;, 0,
            ifelse(surveyData$ppi2 == &quot;Yes&quot;, 3, 6))
  #
  # ppi3: What is the highest grade that a female head/spouse has attained?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;Tenth grade or higher&quot;, 9, 
            ifelse(surveyData$ppi3 == &quot;No female head/spouse&quot;, 5,
              ifelse(surveyData$ppi3 == &quot;Seventh to ninth grade&quot;, 4,
                ifelse(surveyData$ppi3 == &quot;Sixth grade&quot;, 2, 0))))
  #
  # ppi4: What kind of building material is the floor of this dwelling made of?
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Concrete, or covered concrete&quot;, 2, 0)
  #
  # ppi5: What kind of building material is the roof of this dwelling made of?
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;Concrete, asbestos sheets, or asbestos tiles&quot;, 5,
		  ifelse(surveyData$ppi5 == &quot;Iron sheets, or other non-asbestos tiles&quot;, 3, 0))
  #
  # ppi6: What is the main type of energy that your household uses for cooking?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Gas, electricity, solar, or kerosene/paraffin&quot;, 15,
            ifelse(surveyData$ppi6 == &quot;Charcoal&quot;, 4, 0))
  #
  # ppi7: Does your household own any televisions, DVDs/VCRs or home theatres,
  #       or satellite dish/decoders (free to air, or DSTV) or other pay-TV
  #       arrangements?
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;TV, and something else (DVD, dish, etc.&quot;, 10,
            ifelse(surveyData$ppi7 == &quot;TV, but nothing else&quot;, 6,  0))
  #
  # ppi8: Does your household own any non-electric or electric irons?
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;Electric, or both electric and non-electric&quot;, 11,
		  ifelse(surveyData$ppi8 == &quot;Only non-electric&quot;, 4, 0))
  #
  # ppi9: Does your household own any cellular phones?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;No&quot;, 0, 6)
  #
  # ppi10: How many beds and mattresses does your household own?
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;Two or more mattresses (regardless of beds)&quot;, 7,
             ifelse(surveyData$ppi10 == &quot;One mattress (regardless of beds&quot;, 4,
               ifelse(surveyData$ppi10 == &quot;One or more beds, but no mattresses&quot;, 2, 0)))
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: lookup table
  #
  #ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableZMB.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrixZMB[ppiMatrixZMB[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }



################################################################################
#                                                                              #
# Group population by wealth quintiles                                         #
#                                                                              #
################################################################################
#
# Find the quintile cutoffs for PPI
#
qCutOff &lt;- quantile(ppi, probs = c(0.2, 0.4, 0.6, 0.8, 1))
#
# Classify households by wealth quintile
#
pQuintile &lt;- ifelse(ppi &lt;= qCutOff[1], 1,
	ifelse(ppi &gt; qCutOff[1] &amp; ppi &lt;= qCutOff[2], 2,
		ifelse(ppi &gt; qCutOff[2] &amp; ppi &lt;= qCutOff[3], 3,
			ifelse(ppi &gt; qCutOff[3] &amp; ppi &lt;= qCutOff[4], 4, 5))))
#
# Concatenate PPI indicators into single data.frame
#
povertyDF &lt;- data.frame(&quot;uniqueID&quot; = surveyData[ , &quot;uniqueID&quot;],
                        ppi, pQuintile, pPoverty)



################################################################################
#
# Calculate indicators: Water
#
################################################################################
#
# waterSource: source of drinking water
#
waterSource &lt;- ifelse(surveyData$water1 == &quot;Other (please specify)&quot;, 
                      surveyData$water2, 
                      surveyData$water1)
waterSource &lt;- ifelse(waterSource == &quot;Deep tube well &quot;, 
                      &quot;Deep tube well&quot;, 
                      waterSource)
waterSource &lt;- ifelse(waterSource == &quot;Shallow tubwell&quot;, 
                      &quot;Shallow tube well&quot;, 
                      waterSource)
#
# water1: improved source of drinking water
#
water1 &lt;- ifelse(waterSource %in% c(&quot;Bottled water&quot;, 
                                    &quot;Deep tube well&quot;,
	                               &quot;Piped water into dwelling&quot;, 
	                               &quot;Piped water to yard/plot&quot;,
	                               &quot;Public tap/standpipe/kiosk&quot;, 
	                               &quot;Water lifted by motor&quot;,
							 &quot;Cart with small tank/drum or tanker-truck&quot;,
							 &quot;Rainwater collection&quot;), 1, 0)
#
# water2: formal/informal source of drinking water for Pareto chart
#
water2 &lt;- ifelse(surveyData$water3 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water3)
#
# water2a: formal/informal source of drinking water for estimation
#
water2a &lt;- ifelse(surveyData$water3 == &quot;&quot;, NA,
	         ifelse(surveyData$water3 == &quot;Formal&quot;, 1, 0))
#
# water3: source of water a WSUP-supported facility
#
water3 &lt;- ifelse(surveyData$water5 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water5)
#
# water3a: source of water a WSUP-supported facility estimation
#
water3a &lt;- ifelse(surveyData$water5 == &quot;&quot;, NA,
	         ifelse(surveyData$water5 == &quot;Yes&quot;, 1, 0))
#
# water4: mean number of hours per day water is available
#
water4 &lt;- surveyData$water7
#
# water4a: water available at least 12 hours (half a day)
#
water4a &lt;- ifelse(surveyData$water7 &gt;= 12, 1, 0)
#
# water4b: water available for full day
#
water4b &lt;- ifelse(is.na(surveyData$water7), 0, 
	         ifelse(surveyData$water7 == 24, 1, 0))
#
# water5: mean number of days per week water available
#
water5 &lt;- ifelse(surveyData$water9 == &quot;&quot;, NA,
	       ifelse(surveyData$water9 == &quot;7 day per week&quot;, 7,
	 	    ifelse(surveyData$water9 == &quot;6 day per week&quot;, 6,
			 ifelse(surveyData$water9 == &quot;5 day per week&quot;, 5,
			   ifelse(surveyData$water9 == &quot;4 day per week&quot;, 4,
				ifelse(surveyData$water9 == &quot;3 day per week&quot;, 3,
				  ifelse(surveyData$water9 == &quot;2 day per week&quot;, 2,
				    ifelse(surveyData$water9 == &quot;1 day per week&quot;, 1, 0))))))))
#
# water5a: water available more than 3 days a week
#
water5a &lt;- ifelse(water5 &gt; 3, 1, 0)
#
# water5b: water available the whole week
#
water5b &lt;- ifelse(is.na(water5), 0, 
	         ifelse(water5 == 7, 1, 0))
#
# water6: water available for the whole year
#
water6 &lt;- ifelse(surveyData$water11 == &quot;&quot;, &quot;Don&apos;t know&quot;,
	       ifelse(surveyData$water11 == &quot;Yes&quot;, &quot;Yes&quot;, &quot;No&quot;))
#
# water6a: water available for the whole year (estimation)
#
water6a &lt;- ifelse(surveyData$water11 == &quot;&quot;, 0,
	        ifelse(surveyData$water11 == &quot;Yes&quot;, 1, 0))
#
# water7: mean number of minutes to collect water
#
water7 &lt;- ifelse(is.na(surveyData$water14), 0, surveyData$water14)
#
# water7a: distance to water source is within 30 minutes or less
#
water7a &lt;- ifelse(water7 &lt;= 30, 1, 0)
#
# water7b: satisfied with distance between home and water source
#
water7b &lt;- ifelse(surveyData$water16 == &quot;&quot;, 1,
	        ifelse(surveyData$water16 == &quot;Yes&quot;, 1, 0))
#
# water7c: satisfied with distance between home and water source (estimate)
#
water7c &lt;- ifelse(water7b == 2, NA, water7b)
#
# water8: satisfied with queuing time
#
water8 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water8[surveyData$water18 == &quot;No&quot;] &lt;- 0
water8[surveyData$water18 == &quot;Yes&quot;] &lt;- 1
water8[surveyData$water18 == &quot;&quot; &amp; surveyData$water19 == TRUE] &lt;- 2
water8[surveyData$water18 == &quot;&quot; &amp; surveyData$water20 == TRUE] &lt;- 3
water8[is.na(surveyData$water18) &amp; 
       is.na(surveyData$water19) &amp; 
       is.na(surveyData$water20)] &lt;- 4
#
# water8a: satisfied with queuing time
#
water8a &lt;- ifelse(water8 %in% 2:4, NA, water8)

################################################################################
#
# water9: person who usually collects water
#
################################################################################
#
# waterCollect: person who usually collects water
#
waterCollect &lt;- ifelse(surveyData$water21 == &quot;Other (please specify)&quot;, 
                       surveyData$water22, 
                       surveyData$water21)
waterCollect &lt;- ifelse(waterCollect == &quot;&quot;, 
                       NA, 
                       waterCollect)
waterCollect &lt;- ifelse(waterCollect == &quot;Source inside house&quot;, 
  				   NA, 
				   waterCollect)
waterCollect &lt;- str_split(string = waterCollect, pattern = &quot;, &quot;, simplify = TRUE)
#
# Create temporary container for vector outputs
#
temp &lt;- NULL
#
# Cycle through columns of waterCollect
#
for(i in 1:ncol(waterCollect))
  {
  #
  # Concatenate waterCollect columns into a single vector
  #
  temp &lt;- c(temp, waterCollect[ , i])
  }
#
# Re-assign NA value to &quot;&quot; answers 
#
temp &lt;- ifelse(temp == &quot;&quot;, NA, temp)
#
# Get responses
#
tempNames &lt;- names(table(temp))
#
# Create empty vector container
#
water9 &lt;- NULL
#
# Cycle through responses
#
for(i in 1:length(tempNames))
  {
  #
  # Create empty vector with length of surveyData
  #
  assign(paste(&quot;water9&quot;, letters[i], sep = &quot;&quot;), 
         vector(mode = &quot;numeric&quot;, length = nrow(surveyData)))
  #
  # Cycle through data columns in waterCollect
  #
  for(j in 1:ncol(waterCollect))
    {
    #
    # Assign values
    #
    x &lt;- ifelse(waterCollect[ , j] == tempNames[i], i, 0)
    #
    # Concatenate responses
    #
    assign(paste(&quot;water9&quot;, letters[i], sep = &quot;&quot;), 
           get(paste(&quot;water9&quot;, letters[i], sep = &quot;&quot;)) + x)
    }
  #
  # Rename responses to character strings
  #
  assign(paste(&quot;water9&quot;, letters[i], sep = &quot;&quot;), 
         ifelse(get(paste(&quot;water9&quot;, letters[i], sep = &quot;&quot;)) == i, tempNames[i], NA))
  #
  #
  #
  water9 &lt;- data.frame(cbind(water9, 
                       get(paste(&quot;water9&quot;, letters[i], sep = &quot;&quot;))))
  }
#
# Rename the data.frame
#  
names(water9) &lt;- paste(&quot;water9&quot;, letters[1:length(tempNames)], sep = &quot;&quot;)
#
# Clean-up
#
rm(waterCollect, i, j, x, temp, tempNames)
rm(list = names(water9))


################################################################################
#
# water10: amount of water used by household per day
#
################################################################################
#
# water10: amount of water (litres) used by household per day
#
water10 &lt;- ifelse(surveyData$water23 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water23)
#
# water10a: amount of water sufficient
#
water10a &lt;- ifelse(surveyData$water25 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water25)
#
# water10b: amount of water sufficient (estimate)
#
water10b &lt;- ifelse(water10a == &quot;Don&apos;t know&quot;, NA,
	         ifelse(water10a == &quot;Yes&quot;, 1, 0))


################################################################################
#
# water11: water from other sources
#
################################################################################
#
# Re-code &quot;Don&apos;t know&quot;
#
water11 &lt;- ifelse(surveyData$water27 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water27)
#
# Re-code NAs
#
water11a &lt;- ifelse(water11 == &quot;Don&apos;t know&quot;, NA,
	         ifelse(water11 == &quot;Yes&quot;, 1, 0))
#
# Re-code factors
#
water11b &lt;- ifelse(surveyData$water29 == &quot;&quot;, NA,
	         ifelse(surveyData$water29 == &quot;Other (please specify)&quot;, 
	                surveyData$water30, 
	                surveyData$water29))
#
# Re-code
#
water11b &lt;- ifelse(water11b == &quot;&quot;, NA, water11b)
water11b[water11b == &quot;Mosque&quot;] &lt;- &quot;Mosque, school, etc.&quot;
water11b[water11b %in% c(&quot;Neighbour&apos;s house&quot;, 
                         &quot;Pump point of water&quot;)] &lt;- &quot;Other&apos;s water point&quot;
water11b[water11b == &quot;Deep tube well&quot;] &lt;- &quot;Tube well&quot;
water11b[water11b == &quot;Cann&apos;t arranged&quot;] &lt;- &quot;Can&apos;t arrange&quot;
#
# Re-code
#
water11c &lt;- ifelse(water11b %in% c(&quot;Bottled water&quot;, 
                                   &quot;Piped water into dwelling&quot;,
	                              &quot;Piped water to yard/plot&quot;, 
	                              &quot;Protected well or spring in yard&quot;,
	                              &quot;Public tap/standpipe/kiosk&quot;, 
	                              &quot;Tube well&quot;, 
	                              &quot;Water lifted by motor&quot;), 1,
              ifelse(is.na(water11b), 0, 0))
#
# Re-code
#
water11d &lt;- ifelse(water1 == 1 &amp; water7a == 1 &amp; 
                   water4b == 1 &amp; water5b == 1 &amp; water6a == 1, 1,
	         ifelse(water1 == 1 &amp; water7a == 1 &amp; 
	                ((water4b == 0 | water5b == 0 | water6a == 0) &amp; 
	                water11c == 1), 1, 0))


################################################################################
#
# water12: spend on water
#
################################################################################
#
# mean spend on water
#
water12 &lt;- ifelse(surveyData$water32 == &quot;&quot;, NA, surveyData$water32)
#
# satisfied with price of water
#
water12a &lt;- ifelse(surveyData$water35 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water35)
#
# satisfied with price of water - estimate
#
water12b &lt;- ifelse(water12a == &quot;Don&apos;t know&quot;, NA,
	         ifelse(water12a == &quot;Yes&quot;, 1, 0))


################################################################################
#
# water13: investment in improving water source
#
################################################################################
#
# Recode
#
water13 &lt;- ifelse(surveyData$water37 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water37)
#
# Recode
#
water13a &lt;- ifelse(water13 == &quot;Don&apos;t know&quot;, NA,
	          ifelse(water13 == &quot;Yes&quot;, 1, 0))


################################################################################
#
# water14: water quality
#
################################################################################
#
# Recode
#
water14 &lt;- ifelse(surveyData$water40 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water40)
#
# Recode
#
water14a &lt;- ifelse(water14 == &quot;Don&apos;t know&quot;, NA,
	         ifelse(water14 == &quot;Yes&quot;, 1, 0))


################################################################################
#
# water15: water quality improvement
#
################################################################################
#
# waterImprovement: water quality improvement
#
waterImprovement &lt;- ifelse(surveyData$water42 == &quot;Other improvement (please specify)&quot;, 
                           surveyData$water43, 
                           surveyData$water42)
waterImprovement &lt;- ifelse(waterImprovement == &quot;&quot;, 
                           &quot;Don&apos;t know/no answer/not applicable&quot;, 
                           waterImprovement)
waterImprovement &lt;- str_split(string = waterImprovement, pattern = &quot;, &quot;, simplify = TRUE)
#
# Create temporary container for vector outputs
#
temp &lt;- NULL
#
# Cycle through columns of waterImprovement
#
for(i in 1:ncol(waterImprovement))
  {
  waterImprovement[ , i] &lt;- ifelse(waterImprovement[ , i] == &quot;Other improvement (please specify)&quot;, 
                                   surveyData$water43, 
                                   waterImprovement[ , i])
  }
#
# Cycle through columns of waterImprovement
#
for(i in 1:ncol(waterImprovement))
  {
  #
  # Concatenate waterImprovement columns into a single vector
  #
  temp &lt;- c(temp, waterImprovement[ , i])
  }
#
# Re-assign NA value to &quot;&quot; answers 
#
temp &lt;- ifelse(temp == &quot;&quot;, NA, temp)
#
# Get responses
#
tempNames &lt;- names(table(temp))
#
# Create vector accumulator
#
water15 &lt;- NULL
#
# Cycle through responses
#
for(i in 1:length(tempNames))
  {
  #
  # Create empty vector with length of surveyData
  #
  assign(paste(&quot;water15&quot;, letters[i], sep = &quot;&quot;), 
         vector(mode = &quot;numeric&quot;, length = nrow(surveyData)))
  #
  # Cycle through data columns in waterCollect
  #
  for(j in 1:ncol(waterImprovement))
    {
    #
    # Assign values
    #
    x &lt;- ifelse(waterImprovement[ , j] == tempNames[i], i, 0)
    #
    # Concatenate responses
    #
    assign(paste(&quot;water15&quot;, letters[i], sep = &quot;&quot;), 
           get(paste(&quot;water15&quot;, letters[i], sep = &quot;&quot;)) + x)
    }
  #
  # Rename responses to character strings
  #
  assign(paste(&quot;water15&quot;, letters[i], sep = &quot;&quot;), 
         ifelse(get(paste(&quot;water15&quot;, letters[i], sep = &quot;&quot;)) == i, tempNames[i], NA))
  #
  # Create water quality data.frame
  #
  water15 &lt;- data.frame(cbind(water15, get(paste(&quot;water15&quot;, letters[i], sep = &quot;&quot;))))
  }
#
# Rename the data.frame
#  
names(water15) &lt;- paste(&quot;water15&quot;, letters[1:length(tempNames)], sep = &quot;&quot;)
#
# Create water15 data.frame
#
#water15 &lt;- data.frame(&quot;uniqueID&quot; = surveyData[ , &quot;uniqueID&quot;], 
#                      &quot;psu&quot; = surveyData[ , &quot;psu&quot;], 
#                      water15)
#
# Clean-up
#
rm(waterImprovement, i, j, x, temp, tempNames)
rm(list = names(water15))


################################################################################
#
# water16: water pressure
#
################################################################################
#
# Re-code
#
water16 &lt;- ifelse(surveyData$water45 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water45)
#
# Re-code
#
water16a &lt;- ifelse(water16 == &quot;Don&apos;t know&quot;, NA,
	         ifelse(water16 == &quot;Yes&quot;, 1, 0))


################################################################################
#
# water17: support provider
#
################################################################################
#
# Re-code
#
water17 &lt;- ifelse(surveyData$water47 == &quot;&quot;, &quot;Don&apos;t know/not applicable&quot;,
	        ifelse(surveyData$water47 == &quot;Other (please specify)&quot;, 
	               surveyData$water48, 
	               surveyData$water47))
#
# Re-code
#
water17 &lt;- ifelse(water17 == &quot;&quot;, &quot;Don&apos;t know/not applicable&quot;, water17)
#
# Re-code: these lines of code [473-495] are Dhaka, Bangladesh 2017 specific. 
#
water17 &lt;- ifelse(water17 == &quot;Landlord/House owner &quot;, 
                  &quot;Landlord/House owner&quot;,
	        ifelse(water17 == &quot;Caretaker &quot;, 
	               &quot;Caretaker&quot;,
		     ifelse(water17 %in% c(&quot;Gaurd&quot;, &quot;Gaurd &quot;), 
		            &quot;Guard&quot;,
			  ifelse(water17 %in% c(&quot;No complain arise&quot;, 
			                        &quot;No complain  arise&quot;, 
			                        &quot;Till lemdon&apos;t face any problem&quot;), 
			         &quot;No complaints&quot;,
			    ifelse(water17 == &quot;Water office &quot;, 
			           &quot;Water office&quot;,
			      ifelse(water17 == &quot;Do no&apos;t cpmlain&quot;, 
			             &quot;Do not complain&quot;,
				   ifelse(water17 == &quot;Parlament Member (MP)&quot;, 
				          &quot;Parliament Member (MP)&quot;,
					ifelse(water17 == &quot;Relavent office&quot;, 
					       &quot;Relevant office&quot;,
					  ifelse(water17 == &quot;Messengaer &quot;, 
					         &quot;Messenger&quot;, 
					    ifelse(water17 == &quot;Local Gverenment Engineering office&quot;, 
					           &quot;Local Government Engineering office&quot;, 
					           water17))))))))))
#
# Re-code: these lines of code [499-506] are Dhaka, Bangladesh 2017 specific
#
water17 &lt;- ifelse(water17 %in% c(&quot;Facility operator&quot;, 
                                 &quot;Local Government Engineering office&quot;,
	                            &quot;Power and Water Development office&quot;, 
	                            &quot;Relevant office&quot;,
	                            &quot;Water office&quot;, 
	                            &quot;Water supplier&quot;, 
	                            &quot;Water utility&quot;,
	                            &quot;Women Affair Directory&quot;), 1, 0)


################################################################################
#
# water18: water storage
#
################################################################################
#
# waterStorage
#
waterStorage &lt;- ifelse(surveyData$wash60 == &quot;&quot;, 
                       &quot;Don&apos;t know/not applicable&quot;, 
                       surveyData$wash60)
waterStorage &lt;- str_split(string = waterStorage, pattern = &quot;, &quot;, simplify = TRUE)
#
# water18a: Clean container (with lid)
#
water18a &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water18a[waterStorage[,1] == &quot;Clean container (with lid)&quot; |
	    waterStorage[,2] == &quot;Clean container (with lid)&quot; |
	    waterStorage[,3] == &quot;Clean container (with lid)&quot;] &lt;- 1
#
# water18b: Clean container (without lid)
#
water18b &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water18b[waterStorage[,1] == &quot;Clean container (without lid)&quot; |
	    waterStorage[,2] == &quot;Clean container (without lid)&quot; |
	    waterStorage[,3] == &quot;Clean container (without lid)&quot;] &lt;- 2
#
# water18c: Dirty container
#
water18c &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water18c[waterStorage[,1] == &quot;Dirty container&quot; |
	    waterStorage[,2] == &quot;Dirty container&quot; |
	    waterStorage[,3] == &quot;Dirty container&quot;] &lt;- 3
#
# water18d: Don&apos;t know/not applicable
#
water18d &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water18d[waterStorage[,1] == &quot;Don&apos;t know/not applicable&quot; |
	    waterStorage[,2] == &quot;Don&apos;t know/not applicable&quot; |
	    waterStorage[,3] == &quot;Don&apos;t know/not applicable&quot;] &lt;- 4
#
# water18
#        
water18 &lt;- ifelse(water18d == 4, NA,
	        ifelse(water18a == 1 &amp; water18b != 2 &amp; water18c != 3, 1, 0))


################################################################################
#
# waterQuality: this indicator was not collected in survey. For future
#               surveys, if water quality tests are performed, this indicator
#               will be calculated based on that data.
#
################################################################################
#
# Check whether waterQualityDF has been loaded
#
if(exists(&quot;waterQualityDF&quot;))
  {
  #
  # Add logic here to process water quality data with waterQuality variable as
  # the result to be used for calculating indicators
  #
  } else
  #
  # Assign NULL value to waterQuality variable if waterQualityDF is not available
  #
  waterQuality &lt;- NULL
  

################################################################################
#
# JMP indicators for drinking water - post-2015
#
################################################################################
#
# Surface water: river, dam, lake, pond, stream, canal or irrigation channel
#
jmpWater1 &lt;- ifelse(waterSource == &quot;Surface water&quot;, 1, 0)
#
# Unimproved: unprotected dug wells, unprotected springs
#
jmpWater2 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
jmpWater2[water1 != 1 &amp; waterSource != &quot;Surface water&quot;] &lt;- 1
#
# Limited: Improved but more than 30 minutes collection time
#
jmpWater3 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
jmpWater3[water1 == 1 &amp; water7a == 0] &lt;- 1
#
# Determine if water quality data is available
#
if(is.null(waterQuality))
  {
  #
  # At least basic: improved and no more than 30 minutes collection time
  #
  jmpWater4 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
  jmpWater4[water1 == 1 &amp; water7a == 1] &lt;- 1
  #
  # no safely managed: create jmpWater5 empty vector
  #
  jmpWater5 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
  jmpWater5[jmpWater5 == 0] &lt;- NA
  } else 
  {
  #
  # Basic: Improved and no more than 30 minutes collection time
  #
  jmpWater4 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
  #
  #
  #
  jmpWater4[water1 == 1 &amp; 
		  !waterSource %in% c(&quot;Piped water into dwelling&quot;,
		    &quot;Piped water to yard/plot&quot;,
		    &quot;Protected dug well or spring in yard&quot;) &amp; 
		  water7a == 1] &lt;- 1
  #
  #
  #
  jmpWater4[water1 == 1 &amp; 
		  waterSource %in% c(&quot;Piped water into dwelling&quot;,
		    &quot;Piped water to yard/plot&quot;,
		    &quot;Protected dug well or spring in yard&quot;) &amp;
		  (water4a == 0 | water5b == 0 | water6a == 0) &amp; 
		  water7a == 1] &lt;- 1
  #
  # Self-managed: improved and no more than 30 minutes collection time and available 
  #               when needed and free from priority contamination 
  #
  jmpWater5 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
  #
  #
  #
  jmpWater5[water1 == 1 &amp; 
		  waterSource %in% c(&quot;Piped water into dwelling&quot;, 
		    &quot;Piped water to yard/plot&quot;, 
		    &quot;Protected dug well or spring in yard&quot;) &amp; 
		  water4a == 1 &amp; 
		  water5b == 1 &amp; 
		  water6a == 1 &amp; 
		  waterQuality == 1] &lt;- 1
  }
  

################################################################################
#
# accessWater: Access to sufficient and sustained drinking water
#
################################################################################
#
# Re-code
#
accessWater &lt;- ifelse(water10 %in% c(&quot;61-100 litres per day&quot;, 
                                     &quot;101-150 litres per day&quot;,
	                                &quot;150-200 litres per day&quot;, 
	                                &quot;201-300 literes per day&quot;,
	                                &quot;&gt;301 litres per day&quot;) &amp;
                      water4b == 1 &amp; water5b == 1 &amp; water6a == 1, 1, 0)

################################################################################
#
# Create waterDF
#
################################################################################
#
# Concatenate water indicators
#
waterDF &lt;- data.frame(&quot;uniqueID&quot; = surveyData[ , &quot;uniqueID&quot;],
	                 waterSource, water1, water2, water2a, water3, water3a,
	                 water4, water4a, water4b, water5, water5a, water5b,
	                 water6, water6a, water7, water7a, water7b, water7c, water8, water8a,
	                 water9, water10, water10a, water10b,
	                 water11, water11a, water11b, water11c, water11d,
	                 water12, water12a, water12b,
	                 water13, water13a,
	                 water14, water14a,
	                 water16, water16a,
	                 water17, water18,
	                 jmpWater1, jmpWater2, jmpWater3, jmpWater4, jmpWater5,
                      accessWater)
#
# Clean-up
#
rm(waterSource, water1, water2, water2a, water3, water3a, water4, water4a, water4b,
   water5, water5a, water5b, water6, water6a, water7, water7a, water7b, water7c,
   water8, water8a, water9,
   water10, water10a, water10b, water11, water11a, water11b, water11c, water11d,
   water12, water12a, water12b, water13, water13a, water14, water14a,
   water16, water16a, water17, water18,
   jmpWater1, jmpWater2, jmpWater3, jmpWater4, jmpWater5, accessWater,
   waterQuality)

	


################################################################################
#
# Sanitation indicators 
#
################################################################################

################################################################################
#
# san1: shared sanitation facility - user arrangements
#
################################################################################
#
# Re-code
#
san1 &lt;- ifelse(surveyData$san1 == &quot;&quot;, &quot;Don&apos;t know&quot;,
	     ifelse(surveyData$san1 == &quot;Other (please specify)&quot;, 
	            surveyData$san2, 
	            surveyData$san1))
#
# Clean-up
#
san1 &lt;- ifelse(san1 == &quot;Communal / shared toilet &quot;, &quot;Communal / shared toilet&quot;, san1)
#
# san1a: is toilet facility shared with other households
#
san1a &lt;- ifelse(san1 == &quot;Household toilet&quot;, 0, 1)


################################################################################
#
# san2: Number of people who share toilet facilities 
#
################################################################################
#
# san2: Mean number of people who share toilet facilities
#
san2 &lt;- ifelse(is.na(surveyData$san4), 0, surveyData$san4)
#
# san2a: shared toilet facility 
#
san2a &lt;- ifelse(san2 == 0, 0, 1)


################################################################################
#
# san3: type of facility
#
################################################################################
#
# san3: type  of facility
#
san3 &lt;- ifelse(surveyData$san6 == &quot;Other (please specify)&quot;, 
               surveyData$san7, 
               surveyData$san6)
#
# clean-up
#
san3 &lt;- ifelse(san3 %in% c(&quot;Drain&quot;, &quot;Drain connected with waterbody&quot;, 
	                      &quot;Drain with water body (Jhill)&quot;, &quot;Open drain&quot;), &quot;Drain&quot;,
          ifelse(san3 %in% c(&quot;In water body (Jhill)&quot;, &quot;Water body (Lake)&quot;, &quot;Lake&quot;, &quot;Pond&quot;,
	                        &quot;No facilities or bush or field&quot;), 
	                        &quot;No facilities or bush or field or lake or pond&quot;,
            ifelse(san3 %in% c(&quot;Ditch with ring&quot;, &quot;Ring and slub&quot;, 
                               &quot;Slub and in the bottom drain&quot;), 
                               &quot;Ring and slab without pit latrine&quot;, san3)))


################################################################################
#
# san4: where effluent flushes to
#
################################################################################
#
# san4: where effluent flushes to
#
san4 &lt;- ifelse(surveyData$san9 == &quot;&quot;, &quot;Don&apos;t know&quot;,
	     ifelse(surveyData$san9 == &quot;Other (please specify)&quot;, 
	            surveyData$san10, 
	            surveyData$san9))
#
# clean-up
#
san4 &lt;- ifelse(san4 %in% c(&quot;Open drain&quot;, 
                           &quot;Adjacent to pond&quot;, 
                           &quot;Ditch&quot;, 
                           &quot;Ditch &quot;,
	                      &quot;pond&quot;, 
	                      &quot;River&quot;, 
	                      &quot;Water body (Cannel)&quot;), &quot;Open drain/ditch/water body&quot;, 
          ifelse(san4 == &quot;Tanki&quot;, &quot;Septic tank&quot;, san4))


################################################################################
#
# san5: WSUP-supported facility
#
################################################################################
#
# san5: WSUP-supported facility
#
san5 &lt;- ifelse(surveyData$san12 == &quot;&quot; &amp; surveyData$san13 == &quot;TRUE&quot;, &quot;Not applicable&quot;,
	     ifelse(surveyData$san12 == &quot;&quot; &amp; surveyData$san14 == &quot;TRUE&quot;, 
	            &quot;Don&apos;t know&quot;, 
	            surveyData$san12))
#
# re-code
#
san5 &lt;- ifelse(san5 == &quot;Yes&quot;, 1,
	     ifelse(san5 == &quot;No&quot;, 0, NA))


################################################################################
#
# san6: water in facility
#
#################################################################################
#
# san6: water in facility (Yes / No)
#
san6 &lt;- ifelse(surveyData$san15 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san7: satisfied with handwashing facility
#
################################################################################
#
# san7: satisfied with handwashing facility
#
san7 &lt;- ifelse(surveyData$san17 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san8: what would increase your satisfaction
#
################################################################################
#
# Re-code
#
sanSatisfaction &lt;- ifelse(surveyData$san19 == &quot;Other (please specify)&quot;, 
                          surveyData$san20, 
                          surveyData$san19)
sanSatisfaction &lt;- ifelse(sanSatisfaction == &quot;&quot;, 
                          NA, 
                          sanSatisfaction)
sanSatisfaction &lt;- str_split(string = sanSatisfaction, pattern = &quot;, &quot;, simplify = TRUE)
#
# Cycle through columns of sanSatisfaction
#
for(i in 1:ncol(sanSatisfaction))
  {
  sanSatisfaction[ , i] &lt;- ifelse(sanSatisfaction[ , i] == &quot;Other (please specify)&quot;, 
                                  surveyData$san20, 
                                  sanSatisfaction[ , i])
  sanSatisfaction[ , i] &lt;- ifelse(sanSatisfaction[ , i] == &quot;&quot;, 
						    NA, 
						    sanSatisfaction[ , i])
  }
#
# Create temporary container for vector outputs
#
temp &lt;- NULL
#
# Cycle through columns of sanSatisfaction
#
for(i in 1:ncol(sanSatisfaction))
  {
  #
  # Concatenate sanSatisfaction columns into a single vector
  #
  temp &lt;- c(temp, sanSatisfaction[ , i])
  }
#
# Re-assign NA value to &quot;&quot; answers 
#
temp &lt;- ifelse(temp == &quot;&quot;, NA, temp)
#
# Get responses
#
tempNames &lt;- names(table(temp))
#
# Vector accumulator
#
san8 &lt;- NULL
#
# Cycle through responses
#
for(i in 1:length(tempNames))
  {
  #
  # Create empty vector with length of surveyData
  #
  assign(paste(&quot;san8&quot;, letters[i], sep = &quot;&quot;), 
         vector(mode = &quot;numeric&quot;, length = nrow(surveyData)))
  #
  # Cycle through data columns in waterCollect
  #
  for(j in 1:ncol(sanSatisfaction))
    {
    #
    # Assign values
    #
    x &lt;- ifelse(sanSatisfaction[ , j] == tempNames[i], i, 0)
    #
    # Concatenate responses
    #
    assign(paste(&quot;san8&quot;, letters[i], sep = &quot;&quot;), 
           get(paste(&quot;san8&quot;, letters[i], sep = &quot;&quot;)) + x)
    }
  #
  # Rename responses to character strings
  #
  assign(paste(&quot;san8&quot;, letters[i], sep = &quot;&quot;), 
         ifelse(get(paste(&quot;san8&quot;, letters[i], sep = &quot;&quot;)) == i, tempNames[i], NA))
  #
  # Concatenate into data.frame
  #
  san8 &lt;- data.frame(cbind(san8, get(paste(&quot;san8&quot;, letters[i], sep = &quot;&quot;))))
  }
#
# Rename the data.frame
#  
names(san8) &lt;- paste(&quot;san8&quot;, letters[1:length(tempNames)], sep = &quot;&quot;)
#
# Clean-up
#
rm(sanSatisfaction, i, j, temp, tempNames, x)
rm(list = names(san8))


################################################################################
#
# san9: lights in toilet facility
#
################################################################################
#
# san9: lights in toilet facility
#
san9 &lt;- ifelse(surveyData$san22 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san10: toilet facility with lockable door
#
################################################################################
#
# san10: lockable door
#
san10 &lt;- ifelse(surveyData$san24 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san11: container for menstrual hygiene management
#
################################################################################
#
# san11: container for menstrual hygiene management
#
san11 &lt;- ifelse(surveyData$san26 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san12: Sanitary disposal of child&apos;s faeces
#
################################################################################
#
# san12: sanitary disposal of child&apos;s faeces
#
san12 &lt;- ifelse(surveyData$san28 %in% c(&quot;Child used toilet/latrine&quot;, 
	                                   &quot;Put/rinsed into the toilet&quot;), 1, 0)


################################################################################
#
# san13: Waiting time to use the toilet
#
################################################################################
#
# san13: Waiting time to use the toilet
#
san13 &lt;- ifelse(is.na(surveyData$san31), 0, surveyData$san31)
#
# san13a: adequate physical access to sanitation facility
#
san13a &lt;- ifelse(san13 &lt; 30, 1, 0)

################################################################################
#
# san14: spend on sanitation facility
#
################################################################################
#
# san14: spend on sanitation facility
#
san14 &lt;- ifelse(is.na(surveyData$san33), 0, surveyData$san33)


################################################################################
#
# san15: satisfied with spend
#
################################################################################
#
# san15: satisfied with spend
#
san15 &lt;- ifelse(surveyData$san36 == &quot;&quot;, NA,
	       ifelse(surveyData$san36 == &quot;Yes&quot;, 1, 0))


################################################################################
#
# san16: initial investment in toilet facility
#
################################################################################
#
# san16: initial investment in toilet facility
#
san16 &lt;- ifelse(surveyData$san38 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san17: amount of investment
#
################################################################################
#
# san17: amount of investment
#
san17 &lt;- ifelse(is.na(surveyData$san40), 0, surveyData$san40)


################################################################################
#
# san18: willingness to invest
#
################################################################################
#
# san18: willingness to invest
#
san18 &lt;- ifelse(surveyData$san43 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san19: satisfied with cleanliness
#
################################################################################
#
# san19: satisfied with cleanliness
#
san19 &lt;- ifelse(surveyData$san46 == &quot;Yes&quot;, 1,
	       ifelse(surveyData$san46 == &quot;No&quot;, 0, NA))


################################################################################
#
# san20: increase satisfaction
#
################################################################################
#
# Re-code
#
cleanSatisfaction &lt;- ifelse(surveyData$san48 == &quot;Other (please specify)&quot;, 
                            surveyData$san49, 
                            surveyData$san48)
cleanSatisfaction &lt;- ifelse(cleanSatisfaction == &quot;&quot;, 
                            NA, 
                            cleanSatisfaction)
cleanSatisfaction &lt;- str_split(string = cleanSatisfaction, pattern = &quot;, &quot;, simplify = TRUE)
#
# Create temporary container for vector outputs
#
temp &lt;- NULL
#
# Cycle through columns of cleanSatisfaction
#
for(i in 1:ncol(cleanSatisfaction))
  {
  #
  # Re-code 
  #
  cleanSatisfaction[ , i] &lt;- ifelse(cleanSatisfaction[ , i] == &quot;Other (please specify)&quot;, 
                                    surveyData$san20, cleanSatisfaction[ , i])
  cleanSatisfaction[ , i] &lt;- ifelse(cleanSatisfaction[ , i] == &quot;&quot;, 
							 NA, cleanSatisfaction[ , i])
  }
#
# Create temporary container for vector outputs
#
temp &lt;- NULL
#
# Cycle through columns of cleanSatisfaction
#
for(i in 1:ncol(cleanSatisfaction))
  {
  #
  # Concatenate cleanSatisfaction columns into a single vector
  #
  temp &lt;- c(temp, cleanSatisfaction[ , i])
  }
#
# Re-assign NA value to &quot;&quot; answers 
#
temp &lt;- ifelse(temp == &quot;&quot;, NA, temp)
#
# Get responses
#
tempNames &lt;- names(table(temp))
#
# Empty container
#
san20 &lt;- NULL
#
# Cycle through responses
#
for(i in 1:length(tempNames))
  {
  #
  # Create empty vector with length of surveyData
  #
  assign(paste(&quot;san20&quot;, letters[i], sep = &quot;&quot;), 
         vector(mode = &quot;numeric&quot;, length = nrow(surveyData)))
  #
  # Cycle through data columns in cleanSatisfaction
  #
  for(j in 1:ncol(cleanSatisfaction))
    {
    #
    # Assign values
    #
    x &lt;- ifelse(cleanSatisfaction[ , j] == tempNames[i], i, 0)
    #
    # Concatenate responses
    #
    assign(paste(&quot;san20&quot;, letters[i], sep = &quot;&quot;), 
           get(paste(&quot;san20&quot;, letters[i], sep = &quot;&quot;)) + x)
    }
  #
  # Rename responses to character strings
  #
  assign(paste(&quot;san20&quot;, letters[i], sep = &quot;&quot;), 
         ifelse(get(paste(&quot;san20&quot;, letters[i], sep = &quot;&quot;)) == i, tempNames[i], NA))
  #
  # Concatenate into data.frame
  #
  san20 &lt;- data.frame(cbind(san20, get(paste(&quot;san20&quot;, letters[i], sep = &quot;&quot;))))
  }
#
# Rename the data.frame
#  
names(san20) &lt;- paste(&quot;san20&quot;, letters[1:length(tempNames)], sep = &quot;&quot;)
#
# Clean-up
#
rm(cleanSatisfaction, i, j, x, temp, tempNames)
rm(list = names(san20))


################################################################################
#
# san21: Everyone in household able to get to sanitation facility?
#
################################################################################
#
# san21: everyone in household able to get to sanitation facility
#
san21 &lt;- ifelse(surveyData$san51 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san22: who is not using the sanitation facility?
#
################################################################################
#
# Re-code
#
sanitationUse &lt;- ifelse(surveyData$san53 == &quot;&quot;, NA,
	              ifelse(surveyData$san53 == &quot;Other (please specify)&quot;, 
	                     surveyData$san54, 
	                     surveyData$san53))
sanitationUse &lt;- str_split(string = sanitationUse, pattern = &quot;, &quot;, simplify = TRUE)
#
# Create temporary container for vector outputs
#
temp &lt;- NULL
#
# Cycle through columns of sanitationUse
#
for(i in 1:ncol(sanitationUse))
  {
  sanitationUse[ , i] &lt;- ifelse(sanitationUse[ , i] == &quot;Other (please specify)&quot;, 
                                surveyData$san20, sanitationUse[ , i])
  sanitationUse[ , i] &lt;- ifelse(sanitationUse[ , i] == &quot;&quot;, 
						NA, sanitationUse[ , i])
  }
#
# Create temporary container for vector outputs
#
temp &lt;- NULL
#
# Cycle through columns of sanitationUse
#
for(i in 1:ncol(sanitationUse))
  {
  #
  # Concatenate sanitationUse columns into a single vector
  #
  temp &lt;- c(temp, sanitationUse[ , i])
  }
#
# Re-assign NA value to &quot;&quot; answers 
#
temp &lt;- ifelse(temp == &quot;&quot;, NA, temp)
#
# Get responses
#
tempNames &lt;- names(table(temp))
#
# Vector accumulator
#
san22 &lt;- NULL
#
# Cycle through responses
#
for(i in 1:length(tempNames))
  {
  #
  # Create empty vector with length of surveyData
  #
  assign(paste(&quot;san22&quot;, letters[i], sep = &quot;&quot;), 
         vector(mode = &quot;numeric&quot;, length = nrow(surveyData)))
  #
  # Cycle through data columns in waterCollect
  #
  for(j in 1:ncol(sanitationUse))
    {
    #
    # Assign values
    #
    x &lt;- ifelse(sanitationUse[ , j] == tempNames[i], i, 0)
    #
    # Concatenate responses
    #
    assign(paste(&quot;san22&quot;, letters[i], sep = &quot;&quot;), 
           get(paste(&quot;san22&quot;, letters[i], sep = &quot;&quot;)) + x)
    }
  #
  # Rename responses to character strings
  #
  assign(paste(&quot;san22&quot;, letters[i], sep = &quot;&quot;), 
         ifelse(get(paste(&quot;san22&quot;, letters[i], sep = &quot;&quot;)) == i, tempNames[i], NA))
  #
  # Concatenate into data.frame
  #
  san22 &lt;- data.frame(cbind(san22, get(paste(&quot;san22&quot;, letters[i], sep = &quot;&quot;))))
  }
#
# Rename the data.frame
#  
names(san22) &lt;- paste(&quot;san22&quot;, letters[1:length(tempNames)], sep = &quot;&quot;)
#
# Clean-up
#
rm(sanitationUse, i, j, x, temp, tempNames)
rm(list = names(san22))


################################################################################
#
# san23: do all household members usually use the available sanitation facilities
#
################################################################################
#
# Re-code
#
san23 &lt;- ifelse(surveyData$san59 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$san59)
san23 &lt;- ifelse(san23 == &quot;Yes&quot;, 1,
	      ifelse(san23 == &quot;No&quot;, 0, NA))


################################################################################
#
# san24: who is not using sanitation facilities
#
################################################################################
#
# Re-code
#
sanitationUsage &lt;- ifelse(surveyData$san61 == &quot;&quot;, NA,
	                ifelse(surveyData$san61 == &quot;Other (please specify)&quot;, 
	                       surveyData$san62, surveyData$san61))
sanitationUsage &lt;- str_split(string = sanitationUsage, pattern = &quot;, &quot;, simplify = TRUE)
#
# Create temporary container for vector outputs
#
temp &lt;- NULL
#
# Cycle through columns of sanitationUsage
#
for(i in 1:ncol(sanitationUsage))
  {
  #
  # Assign values
  #
  sanitationUsage[ , i] &lt;- ifelse(sanitationUsage[ , i] == &quot;Other (please specify)&quot;, 
                                  surveyData$san62, 
                                  sanitationUsage[ , i])
  sanitationUsage[ , i] &lt;- ifelse(sanitationUsage[ , i] == &quot;&quot;, 
						NA, 
						sanitationUsage[ , i])
  }
#
# Create temporary container for vector outputs
#
temp &lt;- NULL
#
# Cycle through columns of sanitationUsage
#
for(i in 1:ncol(sanitationUsage))
  {
  #
  # Concatenate sanitationUsage columns into a single vector
  #
  temp &lt;- c(temp, sanitationUsage[ , i])
  }
#
# Re-assign NA value to &quot;&quot; answers 
#
temp &lt;- ifelse(temp == &quot;&quot;, NA, temp)
#
# Get responses
#
tempNames &lt;- names(table(temp))
#
# Vector accumulator
#
san24 &lt;- NULL
#
# Cycle through responses
#
for(i in 1:length(tempNames))
  {
  #
  # Create empty vector with length of surveyData
  #
  assign(paste(&quot;san24&quot;, letters[i], sep = &quot;&quot;), 
         vector(mode = &quot;numeric&quot;, length = nrow(surveyData)))
  #
  # Cycle through data columns in waterCollect
  #
  for(j in 1:ncol(sanitationUsage))
    {
    #
    # Assign values
    #
    x &lt;- ifelse(sanitationUsage[ , j] == tempNames[i], i, 0)
    #
    # Concatenate responses
    #
    assign(paste(&quot;san24&quot;, letters[i], sep = &quot;&quot;), 
           get(paste(&quot;san24&quot;, letters[i], sep = &quot;&quot;)) + x)
    }
  #
  # Rename responses to character strings
  #
  assign(paste(&quot;san24&quot;, letters[i], sep = &quot;&quot;), 
         ifelse(get(paste(&quot;san24&quot;, letters[i], sep = &quot;&quot;)) == i, tempNames[i], NA))
  #
  # Concatenate data.frame
  #
  san24 &lt;- data.frame(cbind(san24, get(paste(&quot;san24&quot;, letters[i], sep = &quot;&quot;))))
  }
#
# Rename the data.frame
#  
names(san24) &lt;- paste(&quot;san24&quot;, letters[1:length(tempNames)], sep = &quot;&quot;)
#
# Clean-up
#
rm(sanitationUsage, i, j, x, temp, tempNames)
rm(list = names(san24))


################################################################################
#
# san25: problem with sanitation facility
#
################################################################################
#
# san25:
#
san25 &lt;- ifelse(surveyData$san66 == &quot;&quot;, &quot;Don&apos;t know&quot;, 
	      ifelse(surveyData$san66 == &quot;Other (please specify)&quot;, 
	             surveyData$san67, 
	             surveyData$san66))
san25 &lt;- ifelse(san25 == &quot;&quot;, &quot;Don&apos;t know&quot;, san25)
#
# Clean-up
#
san25 &lt;- ifelse(san25 %in% c(&quot;Call sweeper by own intiative &quot;, 
                             &quot;Do work by calling sweeper&quot;), 
                             &quot;Call sweeper by own intiative&quot;,
	      ifelse(san25 == &quot;Manager &quot;, &quot;Manager&quot;,
		   ifelse(san25 == &quot;Quarter inside university, so the relevant person of university&quot;, 
		          &quot;Responsible university staff&quot;, 
		          san25)))
#
# Re-code: formal service maintainer
#
san25 &lt;- ifelse(san25 %in% c(&quot;Facility operator&quot;, 
	                        &quot;Quarter inside university, so the relevent person of university&quot;, 
	                        &quot;Water and Sanitation Authority  (WASHA)&quot;), 1, 0)


################################################################################
#
# san31: when should you wash hands?
#
################################################################################
#
# washEvents
#
washEvents &lt;- ifelse(surveyData$san85 == &quot;&quot;, &quot;Don&apos;t know&quot;,
	           ifelse(surveyData$san85 == &quot;Other (please specify)&quot;, 
	                  surveyData$san86, 
	                  surveyData$san85))
washEvents &lt;- str_split(string = washEvents, pattern = &quot;, &quot;, simplify = TRUE)
#
# Create temporary container for vector outputs
#
temp &lt;- NULL
#
# Cycle through columns of washEvents
#
for(i in 1:ncol(washEvents))
  {
  #
  # Assign values
  #
  washEvents[ , i] &lt;- ifelse(washEvents[ , i] == &quot;Other (please specify)&quot;, 
                             surveyData$san86, 
                             washEvents[ , i])
  }
#
# Create temporary container for vector outputs
#
temp &lt;- NULL
#
# Cycle through columns of washEvents
#
for(i in 1:ncol(washEvents))
  {
  #
  # Concatenate washEvents columns into a single vector
  #
  temp &lt;- c(temp, washEvents[ , i])
  }
#
# Re-assign NA value to &quot;&quot; answers 
#
temp &lt;- ifelse(temp == &quot;&quot;, NA, temp)
#
# Get responses
#
tempNames &lt;- names(table(temp))
#
# Vector accumulator
#
san31 &lt;- NULL
#
# Cycle through responses
#
for(i in 1:length(tempNames))
  {
  #
  # Create empty vector with length of surveyData
  #
  assign(paste(&quot;san31&quot;, letters[i], sep = &quot;&quot;), 
         vector(mode = &quot;numeric&quot;, length = nrow(surveyData)))
  #
  # Cycle through data columns in waterCollect
  #
  for(j in 1:ncol(washEvents))
    {
    #
    # Assign values
    #
    x &lt;- ifelse(washEvents[ , j] == tempNames[i], i, 0)
    #
    # Concatenate responses
    #
    assign(paste(&quot;san31&quot;, letters[i], sep = &quot;&quot;), 
           get(paste(&quot;san31&quot;, letters[i], sep = &quot;&quot;)) + x)
    }
  #
  # Rename responses to character strings
  #
  assign(paste(&quot;san31&quot;, letters[i], sep = &quot;&quot;), 
         ifelse(get(paste(&quot;san31&quot;, letters[i], sep = &quot;&quot;)) == i, tempNames[i], NA))
  #
  # Concatenate into data.frame
  #
  san31 &lt;- data.frame(cbind(san31, get(paste(&quot;san31&quot;, letters[i], sep = &quot;&quot;))))
  }
#
# Rename the data.frame
#  
names(san31) &lt;- paste(&quot;san31&quot;, letters[1:length(tempNames)], sep = &quot;&quot;)
#
# Clean-up
#
rm(washEvents, i, j, x, temp, tempNames)
rm(list = names(san31))


################################################################################
#
# san32: households with handwashing facility with soap and water at sanitation facility
#
################################################################################
#
# Re-code
#
san32 &lt;- ifelse(surveyData$san88 == &quot;Handwashing station with clean water and soap available&quot;, 1, 0)


################################################################################
#
# san33: how often is septic tank emptied
#
################################################################################
#
# san33
#
san33 &lt;- ifelse(surveyData$san90 == &quot;Other (please specify)&quot;, surveyData$san91,
	      ifelse(surveyData$san90 == &quot;&quot; &amp; surveyData$san92 == TRUE, NA,
		   ifelse(surveyData$san90 == &quot;&quot; &amp; surveyData$san93 == TRUE, &quot;Don&apos;t know&quot;, surveyData$san90)))
#
# clean-up
#
san33 &lt;- ifelse(!san4 %in% c(&quot;Pit latrine&quot;, &quot;Septic tank&quot;), NA,
           ifelse(san33 %in% c(&quot;new house&quot;, &quot;Did not empty till now&quot;), &quot;Don&apos;t know&quot;,
		   ifelse(san33 %in% c(&quot;Stool go to pond&quot;, 
		                       &quot;Stool go to the cannal&quot;), NA, 
		                                                  san33)))


################################################################################
#
# san34: cost of empyting tank
#
################################################################################
#
# san34
#
san34 &lt;- ifelse(surveyData$san94 == &quot;&quot;, NA, surveyData$san94)


################################################################################
#
# san35: who empties pit
#
################################################################################
#
# san35
#
san35 &lt;- ifelse(surveyData$san98 == &quot;&quot;, &quot;Don&apos;t know/not applicable&quot;,
	      ifelse(surveyData$san98 == &quot;Other (please specify)&quot;, 
	             surveyData$san99, 
	             surveyData$san98))
#
# Clean-up
#
san35a &lt;- ifelse(san35 == &quot;House owner &quot;, &quot;House owner&quot;,
	      ifelse(san35 == &quot;Sweeper &quot;, &quot;Sweeper&quot;,
		   ifelse(san35 == &quot;By own&quot;, &quot;Family member or informal manual emptier&quot;, san35)))
#
# Re-code
#
san35 &lt;- ifelse(san35a %in% c(&quot;Formal larger business&quot;, 
                              &quot;Formal small business using manual or automated tool&quot;,
	                         &quot;Water and Sanitation Authority  (WASHA)&quot;), 1, 0)


################################################################################
#
# san36: who pays for pit to be emptied
#
################################################################################
#
# san36
#
san36 &lt;- ifelse(surveyData$san102 == &quot;&quot;, &quot;Don&apos;t know/not applicable&quot;,
	      ifelse(surveyData$san102 == &quot;Other (please specify)&quot;, 
	             surveyData$san103, 
	             surveyData$san102))
#
# Clean-up
#
san36 &lt;- ifelse(san36 == &quot;Water and Sanitation Authority  (WASHA)&quot;, 
                &quot;Water and Sanitation Authority (WASHA)&quot;,
	      ifelse(san36 == &quot;City corporation &quot;, 
	             &quot;City corporation&quot;,
		   ifelse(san36 == &quot;Owner of house &quot;, 
		          &quot;Owner of house&quot;, san36)))


################################################################################
#
# Re-code san34 to take into account who pays for pit emptying
#
################################################################################
#
# Re-code
#
san34a &lt;- ifelse(san36 != &quot;My household&quot;, NA, san34)

################################################################################
#
# san37: satisfaction with pit emptying service
#
################################################################################
#
# san37
#
san37 &lt;- ifelse(surveyData$san106 == &quot;&quot;, NA,
	      ifelse(surveyData$san106 == &quot;Yes&quot;, 1, 0))


################################################################################
#
# san38: excreta disposal after emptying tank
#
################################################################################
#
# Check if excreta disposal after emtpying data avaiable
#
if(exists(&quot;excretaDisposalDF&quot;))
  {
  #
  # Add re-code logic here using excreta disposal data to create
  # object called san38
  #
  } else
  {
  san38 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
  san38[san38 == 0] &lt;- NA
  }


################################################################################
#
# JMP Post-2015 sanitation indicators
#
################################################################################
#
# jmpSan1: open defecation
#
jmpSan1 &lt;- ifelse(san3 == &quot;No facilities or bush or field or lake or pond&quot;, 1, 0)


#
# jmpSan2: unimproved sanitation facilities
#
jmpSan2 &lt;- ifelse(san3 %in% c(&quot;Hanging toilet/hanging latrine&quot;,
	                         &quot;Pit latrine without slab/open pit&quot;,
	                         &quot;Ring and slab without pit latrine&quot;,
	                         &quot;Drain&quot;), 1, 0)

#
# jmpSan3: limited sanitation facility
#
jmpSan3 &lt;- ifelse(san3 %in% c(&quot;Flush/pour flush&quot;, 
                              &quot;Pit latrine with slab or ventilated improved pit latrine (VIP)&quot;,
						&quot;Portable toilet with emptying service&quot;, 
						&quot;Composting toilet&quot;) &amp;
	             san4 %in% c(&quot;Piped sewer system&quot;, &quot;Pit latrine&quot;, &quot;Septic tank&quot;, &quot;Don&apos;t know&quot;) &amp;
	             san1a == 1, 1, 0)
#
# jmpSan4: at least basic
#
jmpSan4 &lt;- ifelse(san3 %in% c(&quot;Flush/pour flush&quot;, 
			               &quot;Pit latrine with slab or ventilated improved pit latrine (VIP)&quot;,
			               &quot;Portable toilet with emptying service&quot;, 
			               &quot;Composting toilet&quot;) &amp;
		        san4 %in% c(&quot;Piped sewer system&quot;, &quot;Pit latrine&quot;, &quot;Septic tank&quot;, &quot;Don&apos;t know&quot;) &amp;
		        san1a == 0, 1, 0)
#
# jmpSan5: empty
#
jmpSan5 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
jmpSan5[jmpSan5 == 0] &lt;- NA
#
# Check if excretaDisposalDF is available
#
if(exists(&quot;excretaDisposalDF&quot;))
  {
  #
  # jmpSan4: basic sanitation facility
  #
  jmpSan4 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
  #
  # Basic sanitation services - pit latrine system
  #
  jmpSan4[san3 %in% c(&quot;Pit latrine with slab or ventilated improved pit latrine (VIP)&quot;,
			       &quot;Composting toilet&quot;) &amp;
		san4 != &quot;Piped sewer system&quot; &amp;
		san1a == 0 &amp; 
		san33 != &quot;Have never emptied it before&quot; &amp;
		!san38 %in% c(&quot;To a covered and sealed hole (buried)&quot;, 
			         &quot;Taken away through the sewer system to a treatment facility&quot;, 
			         &quot;Taken away by the service provider to a treatment facility&quot;)] &lt;- 1          
  #
  # Basic sanitation services - flush/pour flush/toilet system without piped water system
  #
  jmpSan4[san3 %in% c(&quot;Flush/pour flush&quot;, 
	                 &quot;Portable toilet with emptying service&quot;) &amp;
          san4 != &quot;Piped sewer system&quot; &amp;
          san1a == 0 &amp;
		!san38 %in% c(&quot;To a covered and sealed hole (buried)&quot;, 
			         &quot;Taken away through the sewer system to a treatment facility&quot;, 
			         &quot;Taken away by the service provider to a treatment facility&quot;)] &lt;- 1
  #
  # jmpSan5: safely managed
  #
  jmpSan5 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
  #
  #
  #
  jmpSan5[san3 %in% c(&quot;Flush/pour flush&quot;, 
	                 &quot;Portable toilet with emptying service&quot;) &amp;
          san4 == &quot;Piped sewer system&quot; &amp;
          san1a == 0] &lt;- 1
  #
  #
  #
  jmpSan5[san3 %in% c(&quot;Flush/pour flush&quot;, 
	                 &quot;Portable toilet with emptying service&quot;) &amp;
          san4 %in% c(&quot;Pit latrine&quot;, 
	                 &quot;Septic tank&quot;, 
	                 &quot;Don&apos;t know&quot;) &amp;
          san1a == 0 &amp;
		san38 %in% c(&quot;To a covered and sealed hole (buried)&quot;, 
			        &quot;Taken away through the sewer system to a treatment facility&quot;, 
			        &quot;Taken away by the service provider to a treatment facility&quot;)] &lt;- 1
  #
  #
  #
  jmpSan5[san3 %in% c(&quot;Pit latrine with slab or ventilated improved pit latrine (VIP)&quot;,
	                 &quot;Composting toilet&quot;) &amp;
          san4 != &quot;Piped sewer system&quot; &amp;
          san1a == 0 &amp; 
          (san33 == &quot;Have never emptied it before&quot; |
           san38 %in% c(&quot;To a covered and sealed hole (buried)&quot;, 
	                   &quot;Taken away through the sewer system to a treatment facility&quot;, 
	                   &quot;Taken away by the service provider to a treatment facility&quot;))] &lt;- 1
  }


################################################################################
#
# Adequate sanitaiton facility
#
################################################################################
#
# Re-code
#
adequateSan &lt;- ifelse(san3 %in% c(&quot;Flush/pour flush&quot;, 
                                  &quot;Pit latrine with slab or ventilated improved pit latrine (VIP)&quot;) &amp;
	                 san4 != &quot;Open drain / ditch / water body&quot;, 1, 0)

################################################################################
#
# Accessible sanitation facility
#
################################################################################
#
# Re-code
#
accessSan &lt;- ifelse(san21 == 1 &amp; san23 == 1, 1, 0)


################################################################################
#
# Acceptabl sanitation facility 
#
################################################################################
#
# Re-code for proportion indicator
#
acceptSan &lt;- ifelse(adequateSan == 1 &amp; 
                    san6 == 1 &amp; 
                    san9 == 1 &amp; 
                    san10 == 1 &amp; 
                    san11 == 1, 1, 0)
#
# Re-code for mean indicator
#
acceptDF &lt;- data.frame(adequateSan, san6, san9, san10, san11)
#
# Get acceptable sanitaiton score (0-5)
#
acceptScore &lt;- rowSums(acceptDF, na.rm = TRUE)

################################################################################
#
# Create sanDF
#
################################################################################
#
# Concatenate sanitation indicators
#
sanDF &lt;- data.frame(&quot;uniqueID&quot; = surveyData[ , &quot;uniqueID&quot;],
	                san1, san1a, san2, san2a, san3, san4, san5, san6, san7, san8,
	                san9, san10, san11, san12, san13, san13a, san14, san15, san16, 
	                san17, san18, san19, san20, san21, san22, san23, san24, san25, 
	                san32, san33, san34, san34a, san35, san35a, san36, san37,
	                jmpSan1, jmpSan2, jmpSan3, jmpSan4, jmpSan5,
	                adequateSan, accessSan, acceptSan, acceptScore)
#
# Clean-up
#
rm(san1, san1a, san2, san2a, san3, san4, san5, san6, san7, san9, san10, 
   san11, san12, san13, san13a, san14, san15, san16, san17, san18, san19, san21, 
   san23, san25, san32, san33, san34, san34a, san35, san35a, san36, san37, san22,
   jmpSan1, jmpSan2, jmpSan3, jmpSan4, jmpSan5, adequateSan, accessSan, acceptSan, 
   acceptDF, acceptScore, san20, san24)


################################################################################
#
# Handwashing indicators 
#
################################################################################
#
# Check if handwashing facility at home data is available
#
if(exists(&quot;handwashingFacilityDF&quot;))
  {
  #
  # jmpHand1  
  #
  jmpHand1 &lt;- ifelse(surveyData$san107 == &quot;No handwashing station&quot;, 1, 0)
  #
  # jmpHand2
  #
  jmpHand2 &lt;- ifelse(surveyData$san107 == &quot;Handwashing station with water only&quot;, 1, 0)
  #
  # jmpHand3
  #
  jmpHand3 &lt;- ifelse(surveyData$san107 == &quot;Handwashing station with clean water and soap available&quot;, 1, 0)
  } else
  {
  jmpHand1 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
  jmpHand1[jmpHand1 == 0] &lt;- NA
  jmpHand2 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
  jmpHand2[jmpHand2 == 0] &lt;- NA
  jmpHand3 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
  jmpHand3[jmpHand3 == 0] &lt;- NA
  }
  

################################################################################
#
# Create handDF
#
################################################################################
#
# Concatenate handwashing indicators
#
handDF &lt;- data.frame(&quot;uniqueID&quot; = surveyData[ , &quot;uniqueID&quot;],
	                jmpHand1, jmpHand2, jmpHand3)
#
# Clean-up
#
rm(jmpHand1, jmpHand2, jmpHand3)




################################################################################
#
# Hygiene indicators 
#
################################################################################

################################################################################
#
# san26: feel safe with sanitation facility
#
################################################################################
#
# Re-code
#
san26 &lt;- ifelse(surveyData$san70 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san27: feel safe using facility during menstruation
#
################################################################################
#
# Re-code
#
san27 &lt;- ifelse(surveyData$san74 == &quot;Yes&quot;, 1,
	      ifelse(surveyData$san74 == &quot;No&quot;, 0, NA))


################################################################################
#
# jmpWoman: girls and women comfortable with using facility
#
################################################################################
#
# Re-code
#
jmpWoman &lt;- ifelse(san26 == 1 &amp; san27 == 1, 1, 0)


################################################################################
#
# san28: material used for menstruation - clean menstrual management material
#
################################################################################
#
# Re-code
#
san28 &lt;- ifelse(surveyData$san79 == &quot;&quot;, &quot;Don&apos;t know&quot;,
	      ifelse(surveyData$san79 == &quot;Other (please specify)&quot;, 
	             surveyData$san80, 
	             surveyData$san79))
#
# Re-code
#
san28 &lt;- ifelse(san28 == &quot;&quot;, &quot;Don&apos;t know&quot;, san28)
#
# Clean-up - report as NA those who report not having a period/no need;
#            these lines of code [63-68] are Dhaka, Bangladesh specific
#
san28a &lt;- ifelse(san28 %in% c(&quot;Cycle did not resume after birth&quot;, 
                              &quot;Menstrual cycle stopped&quot;, 
                              &quot;None aged of cycle&quot;, 
                              &quot;Pragnent&quot;, 
                              &quot;Ovary removed&quot;), NA,
	       ifelse(san28 == &quot;Tissu paper&quot;, &quot;Tissue paper&quot;, san28))
#
# Re-code
#
san28 &lt;- ifelse(san28a == &quot;Don&apos;t know&quot;, NA,
	      ifelse(san28a %in% c(&quot;Cloth&quot;, &quot;Napkin/pad&quot;), 1, 0))

################################################################################
#
# san29: Appropriate menstrual cloth cleansing
#
################################################################################
#
# Re-code
#
san29 &lt;- ifelse(surveyData$san81 == &quot;&quot;, NA,
	      ifelse(surveyData$san81 == &quot;Other (please specify)&quot;, 
	             surveyData$san82, 
	             surveyData$san81))
#
# Re-code for estimation
#
san29 &lt;- ifelse(san28a == &quot;Napkin/pad&quot;, NA,
	      ifelse(san28a == &quot;Cloth&quot; &amp; san29 %in% c(&quot;Water and soap&quot;, 
	                                              &quot;Do not use again, disposed&quot;), 1, 0))


################################################################################
#
# san30: Appropriate disposal of sanitary napkin
#
################################################################################
#
# Re-code
#
san30 &lt;- ifelse(surveyData$san83 == &quot;&quot;, NA,
	      ifelse(surveyData$san83 == &quot;Other (please specify)&quot;, 
	             surveyData$san84, 
	             surveyData$san83))
#
# Clean-up: these lines of code [109-114] is Dhaka, Bangladesh 2017 specific
#
san30 &lt;- ifelse(san30 %in% c(&quot;Garbage  basket&quot;, 
                             &quot;Garbage basket in the sanitation facility&quot;, 
                             &quot;Garbage disposal&quot;, 
                             &quot;Under the soil by making ditch&quot;), &quot;Garbage disposal&quot;,
	      ifelse(san30 == &quot;Water body (Khal/Jhill)&quot;, &quot;Water body (lake/river/pond)&quot;,
		   ifelse(san30 %in% c(&quot;Menstrual cycle stopped&quot;, &quot;Pragnent&quot;), NA, san30)))
#
# Re-code for estimation
#
san30 &lt;- ifelse(san28a == &quot;Cloth&quot;, NA,
	      ifelse(san28a == &quot;Napkin/pad&quot; &amp; san30 == &quot;Garbage disposal&quot;, 1, 0))


################################################################################
#
# jmpWomenHygiene: Good menstrual hygiene practice
#
################################################################################
#
# Re-code
#
jmpWomenHygiene &lt;- ifelse(san29 == 1 | san30 == 1, 1, 0)


################################################################################
#
# Create hygieneDF
#
################################################################################
#
# Concatenate sanitation indicators
#
hygieneDF &lt;- data.frame(&quot;uniqueID&quot; = surveyData[ , &quot;uniqueID&quot;],
	                   san26, san27, san28, san28a, san29, san30, jmpWoman, jmpWomenHygiene)
#
# Clean-up
#
rm(san26, san27, san28, san28a, san29, san30, jmpWoman, jmpWomenHygiene)



################################################################################
#
# Overall indicators
#
################################################################################
#
# overall1: not adequate water and not adequate sanitaiton services
#
overall1 &lt;- ifelse(waterDF$accessWater == 0 &amp; sanDF$adequateSan == 0, 1, 0)
#
# overall2: adequate water only
#
overall2 &lt;- ifelse(waterDF$accessWater == 1 &amp; sanDF$adequateSan == 0, 1, 0)
#
# overall3: adequate sanitation only
#
overall3 &lt;- ifelse(waterDF$accessWater == 0 &amp; sanDF$adequateSan == 1, 1, 0)
#
# overall4: adequate water and adequate sanitation services
#
overall4 &lt;- ifelse(waterDF$accessWater == 1 &amp; sanDF$adequateSan == 1, 1, 0)
#
# Overall spend
#
overallSpend &lt;- rowSums(data.frame(waterDF$water12, sanDF$san14, sanDF$san34a), na.rm = TRUE)

################################################################################
#
# Create overallDF
#
################################################################################
#
# Concatenate overall indicators
#
overallDF &lt;- data.frame(&quot;uniqueID&quot; = surveyData[ , &quot;uniqueID&quot;],
	                   overall1, overall2, overall3, overall4, overallSpend)
#
# Clean-up
#

rm(overall1, overall2, overall3, overall4)



################################################################################
#
# Create master data
#
################################################################################
#
# Merge all data.frames from current survey data
#
temp &lt;- merge(adminDF, demoDF, by = &quot;uniqueID&quot;)
temp &lt;- merge(temp, povertyDF, by = &quot;uniqueID&quot;)
temp &lt;- merge(temp, waterDF, by = &quot;uniqueID&quot;)
temp &lt;- merge(temp, sanDF, by = &quot;uniqueID&quot;)
temp &lt;- merge(temp, handDF, by = &quot;uniqueID&quot;)
temp &lt;- merge(temp, hygieneDF, by = &quot;uniqueID&quot;)
indicatorsDF &lt;- merge(temp, overallDF, by = &quot;uniqueID&quot;)


################################################################################
#
# Add identifier for city corporation - Bangladesh only
#
################################################################################

if(unique(country) == &quot;Bangladesh&quot;)
  {
  #
  #
  #
  xx &lt;- readOGR(dsn = &quot;dhakaCorporations&quot;,
  	           layer = &quot;dhakaCorporations&quot;,
	           verbose = FALSE)
  #
  #
  #
  long.lat.crs &lt;- &quot;+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0&quot;
  #
  #
  #
  xx &lt;- spTransform(x = xx, CRSobj = CRS(long.lat.crs))                          
  #
  #
  #
  yy &lt;- SpatialPointsDataFrame(coords = indicatorsDF[ , c(&quot;longitude&quot;, &quot;latitude&quot;)],
	                          data = indicatorsDF,
	                          proj4string = CRS(long.lat.crs))
  #
  #
  #
  north &lt;- subset(xx, corprtn == &quot;north&quot;)
  south &lt;- subset(xx, corprtn == &quot;south&quot;)
  #
  #
  #
  zz &lt;- ifelse(indicatorsDF$psu %in% intersect(yy, north)@data$psu, &quot;North City Corporation&quot;,
	     ifelse(indicatorsDF$psu %in% intersect(yy, south)@data$psu, &quot;South City Corporation&quot;, &quot;Outside&quot;))
  #
  #
  #
  indicatorsDF$corporation &lt;- zz
  #
  #
  #
  rm(xx, yy, north, south, zz)
  }

if(unique(country) != &quot;Bangladesh&quot;)
  {
  #
  #
  #
  indicatorsDF$corporation &lt;- NA
  }

#
# Save indicators dataset 
#
write.csv(x = indicatorsDF,
	     file = paste(&quot;data/indicatorsData&quot;, 
		             unique(ccode), 
		             unique(month), 
		             unique(year), &quot;.csv&quot;, sep = &quot;&quot;),
	     row.names = FALSE)


################################################################################
#
# Merge all data.frames from all surveys
#
################################################################################
#
# Get range of survey years based on current year
#
survey.date.range &lt;- 2017:str_split(Sys.Date(), pattern = &quot;-&quot;, simplify = TRUE)[ , 1]
#
# Get list of months
#
survey.month.range &lt;- substr(format(ISOdate(2004,1:12,1),&quot;%B&quot;), start = 1, stop = 3)
#
# Get list of countries
#
survey.country.code &lt;- c(&quot;BGD&quot;, &quot;GHA&quot;, &quot;KEN&quot;, &quot;MDG&quot;, &quot;MOZ&quot;, &quot;ZMB&quot;)
#
#
#
indicatorsDataAll &lt;- NULL
#
#
#
for(i in survey.country.code)
  {
  #
  #
  #
  for(j in survey.month.range)
    {
    #
    #
    #
    for(k in survey.date.range)
      {
      #
      #
      #
	 temp &lt;- try(read.csv(file = paste(&quot;data/indicatorsData&quot;, i, j, k, &quot;.csv&quot;, sep = &quot;&quot;),
				       header = TRUE, sep = &quot;,&quot;),
			   silent = TRUE)
	 #
	 #
	 #
	 if(class(temp) == &quot;try-error&quot;) { temp &lt;- NULL }
	 #
      #
      #
	 indicatorsDataAll &lt;- data.frame(rbind(indicatorsDataAll, temp))
	 }
    }
  }
#
# Save indicatorsAll dataset 
#
write.csv(x = indicatorsDataAll,
	     file = &quot;data/indicatorsDataAll.csv&quot;,
	     row.names = FALSE)
#
# Clean-up
#
rm(survey.date.range, survey.month.range, survey.country.code, temp)

</command>
			<property title="Indicators" shape="TRANSFORM"/>
			<option type="com.ef_prime.rflow.node.base.SubflowNodeModel">
				<subflow>
					<graph version="0.8" width="1073" height="392" locationtype="a" offsetx="106" offsety="161">
						<node id="149" date="1510899093930" uid="c43f0dfeaf951e3" x="380" y="120">
							<command>

################################################################################
#
# Hygiene indicators 
#
################################################################################

################################################################################
#
# san26: feel safe with sanitation facility
#
################################################################################
#
# Re-code
#
san26 &lt;- ifelse(surveyData$san70 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san27: feel safe using facility during menstruation
#
################################################################################
#
# Re-code
#
san27 &lt;- ifelse(surveyData$san74 == &quot;Yes&quot;, 1,
	      ifelse(surveyData$san74 == &quot;No&quot;, 0, NA))


################################################################################
#
# jmpWoman: girls and women comfortable with using facility
#
################################################################################
#
# Re-code
#
jmpWoman &lt;- ifelse(san26 == 1 &amp; san27 == 1, 1, 0)


################################################################################
#
# san28: material used for menstruation - clean menstrual management material
#
################################################################################
#
# Re-code
#
san28 &lt;- ifelse(surveyData$san79 == &quot;&quot;, &quot;Don&apos;t know&quot;,
	      ifelse(surveyData$san79 == &quot;Other (please specify)&quot;, 
	             surveyData$san80, 
	             surveyData$san79))
#
# Re-code
#
san28 &lt;- ifelse(san28 == &quot;&quot;, &quot;Don&apos;t know&quot;, san28)
#
# Clean-up - report as NA those who report not having a period/no need;
#            these lines of code [63-68] are Dhaka, Bangladesh specific
#
san28a &lt;- ifelse(san28 %in% c(&quot;Cycle did not resume after birth&quot;, 
                              &quot;Menstrual cycle stopped&quot;, 
                              &quot;None aged of cycle&quot;, 
                              &quot;Pragnent&quot;, 
                              &quot;Ovary removed&quot;), NA,
	       ifelse(san28 == &quot;Tissu paper&quot;, &quot;Tissue paper&quot;, san28))
#
# Re-code
#
san28 &lt;- ifelse(san28a == &quot;Don&apos;t know&quot;, NA,
	      ifelse(san28a %in% c(&quot;Cloth&quot;, &quot;Napkin/pad&quot;), 1, 0))

################################################################################
#
# san29: Appropriate menstrual cloth cleansing
#
################################################################################
#
# Re-code
#
san29 &lt;- ifelse(surveyData$san81 == &quot;&quot;, NA,
	      ifelse(surveyData$san81 == &quot;Other (please specify)&quot;, 
	             surveyData$san82, 
	             surveyData$san81))
#
# Re-code for estimation
#
san29 &lt;- ifelse(san28a == &quot;Napkin/pad&quot;, NA,
	      ifelse(san28a == &quot;Cloth&quot; &amp; san29 %in% c(&quot;Water and soap&quot;, 
	                                              &quot;Do not use again, disposed&quot;), 1, 0))


################################################################################
#
# san30: Appropriate disposal of sanitary napkin
#
################################################################################
#
# Re-code
#
san30 &lt;- ifelse(surveyData$san83 == &quot;&quot;, NA,
	      ifelse(surveyData$san83 == &quot;Other (please specify)&quot;, 
	             surveyData$san84, 
	             surveyData$san83))
#
# Clean-up: these lines of code [109-114] is Dhaka, Bangladesh 2017 specific
#
san30 &lt;- ifelse(san30 %in% c(&quot;Garbage  basket&quot;, 
                             &quot;Garbage basket in the sanitation facility&quot;, 
                             &quot;Garbage disposal&quot;, 
                             &quot;Under the soil by making ditch&quot;), &quot;Garbage disposal&quot;,
	      ifelse(san30 == &quot;Water body (Khal/Jhill)&quot;, &quot;Water body (lake/river/pond)&quot;,
		   ifelse(san30 %in% c(&quot;Menstrual cycle stopped&quot;, &quot;Pragnent&quot;), NA, san30)))
#
# Re-code for estimation
#
san30 &lt;- ifelse(san28a == &quot;Cloth&quot;, NA,
	      ifelse(san28a == &quot;Napkin/pad&quot; &amp; san30 == &quot;Garbage disposal&quot;, 1, 0))


################################################################################
#
# jmpWomenHygiene: Good menstrual hygiene practice
#
################################################################################
#
# Re-code
#
jmpWomenHygiene &lt;- ifelse(san29 == 1 | san30 == 1, 1, 0)


################################################################################
#
# Create hygieneDF
#
################################################################################
#
# Concatenate sanitation indicators
#
hygieneDF &lt;- data.frame(&quot;uniqueID&quot; = surveyData[ , &quot;uniqueID&quot;],
	                   san26, san27, san28, san28a, san29, san30, jmpWoman, jmpWomenHygiene)
#
# Clean-up
#
rm(san26, san27, san28, san28a, san29, san30, jmpWoman, jmpWomenHygiene)

</command>
							<property title="Hygiene" shape="TRANSFORM"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="150" date="1510899093931" uid="a81a1335ae91105a" x="220" y="40">
							<command>
################################################################################
#
# Calculate indicators: Water
#
################################################################################
#
# waterSource: source of drinking water
#
waterSource &lt;- ifelse(surveyData$water1 == &quot;Other (please specify)&quot;, 
                      surveyData$water2, 
                      surveyData$water1)
waterSource &lt;- ifelse(waterSource == &quot;Deep tube well &quot;, 
                      &quot;Deep tube well&quot;, 
                      waterSource)
waterSource &lt;- ifelse(waterSource == &quot;Shallow tubwell&quot;, 
                      &quot;Shallow tube well&quot;, 
                      waterSource)
#
# water1: improved source of drinking water
#
water1 &lt;- ifelse(waterSource %in% c(&quot;Bottled water&quot;, 
                                    &quot;Deep tube well&quot;,
	                               &quot;Piped water into dwelling&quot;, 
	                               &quot;Piped water to yard/plot&quot;,
	                               &quot;Public tap/standpipe/kiosk&quot;, 
	                               &quot;Water lifted by motor&quot;,
							 &quot;Cart with small tank/drum or tanker-truck&quot;,
							 &quot;Rainwater collection&quot;), 1, 0)
#
# water2: formal/informal source of drinking water for Pareto chart
#
water2 &lt;- ifelse(surveyData$water3 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water3)
#
# water2a: formal/informal source of drinking water for estimation
#
water2a &lt;- ifelse(surveyData$water3 == &quot;&quot;, NA,
	         ifelse(surveyData$water3 == &quot;Formal&quot;, 1, 0))
#
# water3: source of water a WSUP-supported facility
#
water3 &lt;- ifelse(surveyData$water5 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water5)
#
# water3a: source of water a WSUP-supported facility estimation
#
water3a &lt;- ifelse(surveyData$water5 == &quot;&quot;, NA,
	         ifelse(surveyData$water5 == &quot;Yes&quot;, 1, 0))
#
# water4: mean number of hours per day water is available
#
water4 &lt;- surveyData$water7
#
# water4a: water available at least 12 hours (half a day)
#
water4a &lt;- ifelse(surveyData$water7 &gt;= 12, 1, 0)
#
# water4b: water available for full day
#
water4b &lt;- ifelse(is.na(surveyData$water7), 0, 
	         ifelse(surveyData$water7 == 24, 1, 0))
#
# water5: mean number of days per week water available
#
water5 &lt;- ifelse(surveyData$water9 == &quot;&quot;, NA,
	       ifelse(surveyData$water9 == &quot;7 day per week&quot;, 7,
	 	    ifelse(surveyData$water9 == &quot;6 day per week&quot;, 6,
			 ifelse(surveyData$water9 == &quot;5 day per week&quot;, 5,
			   ifelse(surveyData$water9 == &quot;4 day per week&quot;, 4,
				ifelse(surveyData$water9 == &quot;3 day per week&quot;, 3,
				  ifelse(surveyData$water9 == &quot;2 day per week&quot;, 2,
				    ifelse(surveyData$water9 == &quot;1 day per week&quot;, 1, 0))))))))
#
# water5a: water available more than 3 days a week
#
water5a &lt;- ifelse(water5 &gt; 3, 1, 0)
#
# water5b: water available the whole week
#
water5b &lt;- ifelse(is.na(water5), 0, 
	         ifelse(water5 == 7, 1, 0))
#
# water6: water available for the whole year
#
water6 &lt;- ifelse(surveyData$water11 == &quot;&quot;, &quot;Don&apos;t know&quot;,
	       ifelse(surveyData$water11 == &quot;Yes&quot;, &quot;Yes&quot;, &quot;No&quot;))
#
# water6a: water available for the whole year (estimation)
#
water6a &lt;- ifelse(surveyData$water11 == &quot;&quot;, 0,
	        ifelse(surveyData$water11 == &quot;Yes&quot;, 1, 0))
#
# water7: mean number of minutes to collect water
#
water7 &lt;- ifelse(is.na(surveyData$water14), 0, surveyData$water14)
#
# water7a: distance to water source is within 30 minutes or less
#
water7a &lt;- ifelse(water7 &lt;= 30, 1, 0)
#
# water7b: satisfied with distance between home and water source
#
water7b &lt;- ifelse(surveyData$water16 == &quot;&quot;, 1,
	        ifelse(surveyData$water16 == &quot;Yes&quot;, 1, 0))
#
# water7c: satisfied with distance between home and water source (estimate)
#
water7c &lt;- ifelse(water7b == 2, NA, water7b)
#
# water8: satisfied with queuing time
#
water8 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water8[surveyData$water18 == &quot;No&quot;] &lt;- 0
water8[surveyData$water18 == &quot;Yes&quot;] &lt;- 1
water8[surveyData$water18 == &quot;&quot; &amp; surveyData$water19 == TRUE] &lt;- 2
water8[surveyData$water18 == &quot;&quot; &amp; surveyData$water20 == TRUE] &lt;- 3
water8[is.na(surveyData$water18) &amp; 
       is.na(surveyData$water19) &amp; 
       is.na(surveyData$water20)] &lt;- 4
#
# water8a: satisfied with queuing time
#
water8a &lt;- ifelse(water8 %in% 2:4, NA, water8)

################################################################################
#
# water9: person who usually collects water
#
################################################################################
#
# waterCollect: person who usually collects water
#
waterCollect &lt;- ifelse(surveyData$water21 == &quot;Other (please specify)&quot;, 
                       surveyData$water22, 
                       surveyData$water21)
waterCollect &lt;- ifelse(waterCollect == &quot;&quot;, 
                       NA, 
                       waterCollect)
waterCollect &lt;- ifelse(waterCollect == &quot;Source inside house&quot;, 
  				   NA, 
				   waterCollect)
waterCollect &lt;- str_split(string = waterCollect, pattern = &quot;, &quot;, simplify = TRUE)
#
# Create temporary container for vector outputs
#
temp &lt;- NULL
#
# Cycle through columns of waterCollect
#
for(i in 1:ncol(waterCollect))
  {
  #
  # Concatenate waterCollect columns into a single vector
  #
  temp &lt;- c(temp, waterCollect[ , i])
  }
#
# Re-assign NA value to &quot;&quot; answers 
#
temp &lt;- ifelse(temp == &quot;&quot;, NA, temp)
#
# Get responses
#
tempNames &lt;- names(table(temp))
#
# Create empty vector container
#
water9 &lt;- NULL
#
# Cycle through responses
#
for(i in 1:length(tempNames))
  {
  #
  # Create empty vector with length of surveyData
  #
  assign(paste(&quot;water9&quot;, letters[i], sep = &quot;&quot;), 
         vector(mode = &quot;numeric&quot;, length = nrow(surveyData)))
  #
  # Cycle through data columns in waterCollect
  #
  for(j in 1:ncol(waterCollect))
    {
    #
    # Assign values
    #
    x &lt;- ifelse(waterCollect[ , j] == tempNames[i], i, 0)
    #
    # Concatenate responses
    #
    assign(paste(&quot;water9&quot;, letters[i], sep = &quot;&quot;), 
           get(paste(&quot;water9&quot;, letters[i], sep = &quot;&quot;)) + x)
    }
  #
  # Rename responses to character strings
  #
  assign(paste(&quot;water9&quot;, letters[i], sep = &quot;&quot;), 
         ifelse(get(paste(&quot;water9&quot;, letters[i], sep = &quot;&quot;)) == i, tempNames[i], NA))
  #
  #
  #
  water9 &lt;- data.frame(cbind(water9, 
                       get(paste(&quot;water9&quot;, letters[i], sep = &quot;&quot;))))
  }
#
# Rename the data.frame
#  
names(water9) &lt;- paste(&quot;water9&quot;, letters[1:length(tempNames)], sep = &quot;&quot;)
#
# Clean-up
#
rm(waterCollect, i, j, x, temp, tempNames)
rm(list = names(water9))


################################################################################
#
# water10: amount of water used by household per day
#
################################################################################
#
# water10: amount of water (litres) used by household per day
#
water10 &lt;- ifelse(surveyData$water23 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water23)
#
# water10a: amount of water sufficient
#
water10a &lt;- ifelse(surveyData$water25 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water25)
#
# water10b: amount of water sufficient (estimate)
#
water10b &lt;- ifelse(water10a == &quot;Don&apos;t know&quot;, NA,
	         ifelse(water10a == &quot;Yes&quot;, 1, 0))


################################################################################
#
# water11: water from other sources
#
################################################################################
#
# Re-code &quot;Don&apos;t know&quot;
#
water11 &lt;- ifelse(surveyData$water27 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water27)
#
# Re-code NAs
#
water11a &lt;- ifelse(water11 == &quot;Don&apos;t know&quot;, NA,
	         ifelse(water11 == &quot;Yes&quot;, 1, 0))
#
# Re-code factors
#
water11b &lt;- ifelse(surveyData$water29 == &quot;&quot;, NA,
	         ifelse(surveyData$water29 == &quot;Other (please specify)&quot;, 
	                surveyData$water30, 
	                surveyData$water29))
#
# Re-code
#
water11b &lt;- ifelse(water11b == &quot;&quot;, NA, water11b)
water11b[water11b == &quot;Mosque&quot;] &lt;- &quot;Mosque, school, etc.&quot;
water11b[water11b %in% c(&quot;Neighbour&apos;s house&quot;, 
                         &quot;Pump point of water&quot;)] &lt;- &quot;Other&apos;s water point&quot;
water11b[water11b == &quot;Deep tube well&quot;] &lt;- &quot;Tube well&quot;
water11b[water11b == &quot;Cann&apos;t arranged&quot;] &lt;- &quot;Can&apos;t arrange&quot;
#
# Re-code
#
water11c &lt;- ifelse(water11b %in% c(&quot;Bottled water&quot;, 
                                   &quot;Piped water into dwelling&quot;,
	                              &quot;Piped water to yard/plot&quot;, 
	                              &quot;Protected well or spring in yard&quot;,
	                              &quot;Public tap/standpipe/kiosk&quot;, 
	                              &quot;Tube well&quot;, 
	                              &quot;Water lifted by motor&quot;), 1,
              ifelse(is.na(water11b), 0, 0))
#
# Re-code
#
water11d &lt;- ifelse(water1 == 1 &amp; water7a == 1 &amp; 
                   water4b == 1 &amp; water5b == 1 &amp; water6a == 1, 1,
	         ifelse(water1 == 1 &amp; water7a == 1 &amp; 
	                ((water4b == 0 | water5b == 0 | water6a == 0) &amp; 
	                water11c == 1), 1, 0))


################################################################################
#
# water12: spend on water
#
################################################################################
#
# mean spend on water
#
water12 &lt;- ifelse(surveyData$water32 == &quot;&quot;, NA, surveyData$water32)
#
# satisfied with price of water
#
water12a &lt;- ifelse(surveyData$water35 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water35)
#
# satisfied with price of water - estimate
#
water12b &lt;- ifelse(water12a == &quot;Don&apos;t know&quot;, NA,
	         ifelse(water12a == &quot;Yes&quot;, 1, 0))


################################################################################
#
# water13: investment in improving water source
#
################################################################################
#
# Recode
#
water13 &lt;- ifelse(surveyData$water37 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water37)
#
# Recode
#
water13a &lt;- ifelse(water13 == &quot;Don&apos;t know&quot;, NA,
	          ifelse(water13 == &quot;Yes&quot;, 1, 0))


################################################################################
#
# water14: water quality
#
################################################################################
#
# Recode
#
water14 &lt;- ifelse(surveyData$water40 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water40)
#
# Recode
#
water14a &lt;- ifelse(water14 == &quot;Don&apos;t know&quot;, NA,
	         ifelse(water14 == &quot;Yes&quot;, 1, 0))


################################################################################
#
# water15: water quality improvement
#
################################################################################
#
# waterImprovement: water quality improvement
#
waterImprovement &lt;- ifelse(surveyData$water42 == &quot;Other improvement (please specify)&quot;, 
                           surveyData$water43, 
                           surveyData$water42)
waterImprovement &lt;- ifelse(waterImprovement == &quot;&quot;, 
                           &quot;Don&apos;t know/no answer/not applicable&quot;, 
                           waterImprovement)
waterImprovement &lt;- str_split(string = waterImprovement, pattern = &quot;, &quot;, simplify = TRUE)
#
# Create temporary container for vector outputs
#
temp &lt;- NULL
#
# Cycle through columns of waterImprovement
#
for(i in 1:ncol(waterImprovement))
  {
  waterImprovement[ , i] &lt;- ifelse(waterImprovement[ , i] == &quot;Other improvement (please specify)&quot;, 
                                   surveyData$water43, 
                                   waterImprovement[ , i])
  }
#
# Cycle through columns of waterImprovement
#
for(i in 1:ncol(waterImprovement))
  {
  #
  # Concatenate waterImprovement columns into a single vector
  #
  temp &lt;- c(temp, waterImprovement[ , i])
  }
#
# Re-assign NA value to &quot;&quot; answers 
#
temp &lt;- ifelse(temp == &quot;&quot;, NA, temp)
#
# Get responses
#
tempNames &lt;- names(table(temp))
#
# Create vector accumulator
#
water15 &lt;- NULL
#
# Cycle through responses
#
for(i in 1:length(tempNames))
  {
  #
  # Create empty vector with length of surveyData
  #
  assign(paste(&quot;water15&quot;, letters[i], sep = &quot;&quot;), 
         vector(mode = &quot;numeric&quot;, length = nrow(surveyData)))
  #
  # Cycle through data columns in waterCollect
  #
  for(j in 1:ncol(waterImprovement))
    {
    #
    # Assign values
    #
    x &lt;- ifelse(waterImprovement[ , j] == tempNames[i], i, 0)
    #
    # Concatenate responses
    #
    assign(paste(&quot;water15&quot;, letters[i], sep = &quot;&quot;), 
           get(paste(&quot;water15&quot;, letters[i], sep = &quot;&quot;)) + x)
    }
  #
  # Rename responses to character strings
  #
  assign(paste(&quot;water15&quot;, letters[i], sep = &quot;&quot;), 
         ifelse(get(paste(&quot;water15&quot;, letters[i], sep = &quot;&quot;)) == i, tempNames[i], NA))
  #
  # Create water quality data.frame
  #
  water15 &lt;- data.frame(cbind(water15, get(paste(&quot;water15&quot;, letters[i], sep = &quot;&quot;))))
  }
#
# Rename the data.frame
#  
names(water15) &lt;- paste(&quot;water15&quot;, letters[1:length(tempNames)], sep = &quot;&quot;)
#
# Create water15 data.frame
#
#water15 &lt;- data.frame(&quot;uniqueID&quot; = surveyData[ , &quot;uniqueID&quot;], 
#                      &quot;psu&quot; = surveyData[ , &quot;psu&quot;], 
#                      water15)
#
# Clean-up
#
rm(waterImprovement, i, j, x, temp, tempNames)
rm(list = names(water15))


################################################################################
#
# water16: water pressure
#
################################################################################
#
# Re-code
#
water16 &lt;- ifelse(surveyData$water45 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$water45)
#
# Re-code
#
water16a &lt;- ifelse(water16 == &quot;Don&apos;t know&quot;, NA,
	         ifelse(water16 == &quot;Yes&quot;, 1, 0))


################################################################################
#
# water17: support provider
#
################################################################################
#
# Re-code
#
water17 &lt;- ifelse(surveyData$water47 == &quot;&quot;, &quot;Don&apos;t know/not applicable&quot;,
	        ifelse(surveyData$water47 == &quot;Other (please specify)&quot;, 
	               surveyData$water48, 
	               surveyData$water47))
#
# Re-code
#
water17 &lt;- ifelse(water17 == &quot;&quot;, &quot;Don&apos;t know/not applicable&quot;, water17)
#
# Re-code: these lines of code [473-495] are Dhaka, Bangladesh 2017 specific. 
#
water17 &lt;- ifelse(water17 == &quot;Landlord/House owner &quot;, 
                  &quot;Landlord/House owner&quot;,
	        ifelse(water17 == &quot;Caretaker &quot;, 
	               &quot;Caretaker&quot;,
		     ifelse(water17 %in% c(&quot;Gaurd&quot;, &quot;Gaurd &quot;), 
		            &quot;Guard&quot;,
			  ifelse(water17 %in% c(&quot;No complain arise&quot;, 
			                        &quot;No complain  arise&quot;, 
			                        &quot;Till lemdon&apos;t face any problem&quot;), 
			         &quot;No complaints&quot;,
			    ifelse(water17 == &quot;Water office &quot;, 
			           &quot;Water office&quot;,
			      ifelse(water17 == &quot;Do no&apos;t cpmlain&quot;, 
			             &quot;Do not complain&quot;,
				   ifelse(water17 == &quot;Parlament Member (MP)&quot;, 
				          &quot;Parliament Member (MP)&quot;,
					ifelse(water17 == &quot;Relavent office&quot;, 
					       &quot;Relevant office&quot;,
					  ifelse(water17 == &quot;Messengaer &quot;, 
					         &quot;Messenger&quot;, 
					    ifelse(water17 == &quot;Local Gverenment Engineering office&quot;, 
					           &quot;Local Government Engineering office&quot;, 
					           water17))))))))))
#
# Re-code: these lines of code [499-506] are Dhaka, Bangladesh 2017 specific
#
water17 &lt;- ifelse(water17 %in% c(&quot;Facility operator&quot;, 
                                 &quot;Local Government Engineering office&quot;,
	                            &quot;Power and Water Development office&quot;, 
	                            &quot;Relevant office&quot;,
	                            &quot;Water office&quot;, 
	                            &quot;Water supplier&quot;, 
	                            &quot;Water utility&quot;,
	                            &quot;Women Affair Directory&quot;), 1, 0)


################################################################################
#
# water18: water storage
#
################################################################################
#
# waterStorage
#
waterStorage &lt;- ifelse(surveyData$wash60 == &quot;&quot;, 
                       &quot;Don&apos;t know/not applicable&quot;, 
                       surveyData$wash60)
waterStorage &lt;- str_split(string = waterStorage, pattern = &quot;, &quot;, simplify = TRUE)
#
# water18a: Clean container (with lid)
#
water18a &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water18a[waterStorage[,1] == &quot;Clean container (with lid)&quot; |
	    waterStorage[,2] == &quot;Clean container (with lid)&quot; |
	    waterStorage[,3] == &quot;Clean container (with lid)&quot;] &lt;- 1
#
# water18b: Clean container (without lid)
#
water18b &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water18b[waterStorage[,1] == &quot;Clean container (without lid)&quot; |
	    waterStorage[,2] == &quot;Clean container (without lid)&quot; |
	    waterStorage[,3] == &quot;Clean container (without lid)&quot;] &lt;- 2
#
# water18c: Dirty container
#
water18c &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water18c[waterStorage[,1] == &quot;Dirty container&quot; |
	    waterStorage[,2] == &quot;Dirty container&quot; |
	    waterStorage[,3] == &quot;Dirty container&quot;] &lt;- 3
#
# water18d: Don&apos;t know/not applicable
#
water18d &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
water18d[waterStorage[,1] == &quot;Don&apos;t know/not applicable&quot; |
	    waterStorage[,2] == &quot;Don&apos;t know/not applicable&quot; |
	    waterStorage[,3] == &quot;Don&apos;t know/not applicable&quot;] &lt;- 4
#
# water18
#        
water18 &lt;- ifelse(water18d == 4, NA,
	        ifelse(water18a == 1 &amp; water18b != 2 &amp; water18c != 3, 1, 0))


################################################################################
#
# waterQuality: this indicator was not collected in survey. For future
#               surveys, if water quality tests are performed, this indicator
#               will be calculated based on that data.
#
################################################################################
#
# Check whether waterQualityDF has been loaded
#
if(exists(&quot;waterQualityDF&quot;))
  {
  #
  # Add logic here to process water quality data with waterQuality variable as
  # the result to be used for calculating indicators
  #
  } else
  #
  # Assign NULL value to waterQuality variable if waterQualityDF is not available
  #
  waterQuality &lt;- NULL
  

################################################################################
#
# JMP indicators for drinking water - post-2015
#
################################################################################
#
# Surface water: river, dam, lake, pond, stream, canal or irrigation channel
#
jmpWater1 &lt;- ifelse(waterSource == &quot;Surface water&quot;, 1, 0)
#
# Unimproved: unprotected dug wells, unprotected springs
#
jmpWater2 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
jmpWater2[water1 != 1 &amp; waterSource != &quot;Surface water&quot;] &lt;- 1
#
# Limited: Improved but more than 30 minutes collection time
#
jmpWater3 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
jmpWater3[water1 == 1 &amp; water7a == 0] &lt;- 1
#
# Determine if water quality data is available
#
if(is.null(waterQuality))
  {
  #
  # At least basic: improved and no more than 30 minutes collection time
  #
  jmpWater4 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
  jmpWater4[water1 == 1 &amp; water7a == 1] &lt;- 1
  #
  # no safely managed: create jmpWater5 empty vector
  #
  jmpWater5 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
  jmpWater5[jmpWater5 == 0] &lt;- NA
  } else 
  {
  #
  # Basic: Improved and no more than 30 minutes collection time
  #
  jmpWater4 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
  #
  #
  #
  jmpWater4[water1 == 1 &amp; 
		  !waterSource %in% c(&quot;Piped water into dwelling&quot;,
		    &quot;Piped water to yard/plot&quot;,
		    &quot;Protected dug well or spring in yard&quot;) &amp; 
		  water7a == 1] &lt;- 1
  #
  #
  #
  jmpWater4[water1 == 1 &amp; 
		  waterSource %in% c(&quot;Piped water into dwelling&quot;,
		    &quot;Piped water to yard/plot&quot;,
		    &quot;Protected dug well or spring in yard&quot;) &amp;
		  (water4a == 0 | water5b == 0 | water6a == 0) &amp; 
		  water7a == 1] &lt;- 1
  #
  # Self-managed: improved and no more than 30 minutes collection time and available 
  #               when needed and free from priority contamination 
  #
  jmpWater5 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
  #
  #
  #
  jmpWater5[water1 == 1 &amp; 
		  waterSource %in% c(&quot;Piped water into dwelling&quot;, 
		    &quot;Piped water to yard/plot&quot;, 
		    &quot;Protected dug well or spring in yard&quot;) &amp; 
		  water4a == 1 &amp; 
		  water5b == 1 &amp; 
		  water6a == 1 &amp; 
		  waterQuality == 1] &lt;- 1
  }
  

################################################################################
#
# accessWater: Access to sufficient and sustained drinking water
#
################################################################################
#
# Re-code
#
accessWater &lt;- ifelse(water10 %in% c(&quot;61-100 litres per day&quot;, 
                                     &quot;101-150 litres per day&quot;,
	                                &quot;150-200 litres per day&quot;, 
	                                &quot;201-300 literes per day&quot;,
	                                &quot;&gt;301 litres per day&quot;) &amp;
                      water4b == 1 &amp; water5b == 1 &amp; water6a == 1, 1, 0)

################################################################################
#
# Create waterDF
#
################################################################################
#
# Concatenate water indicators
#
waterDF &lt;- data.frame(&quot;uniqueID&quot; = surveyData[ , &quot;uniqueID&quot;],
	                 waterSource, water1, water2, water2a, water3, water3a,
	                 water4, water4a, water4b, water5, water5a, water5b,
	                 water6, water6a, water7, water7a, water7b, water7c, water8, water8a,
	                 water9, water10, water10a, water10b,
	                 water11, water11a, water11b, water11c, water11d,
	                 water12, water12a, water12b,
	                 water13, water13a,
	                 water14, water14a,
	                 water16, water16a,
	                 water17, water18,
	                 jmpWater1, jmpWater2, jmpWater3, jmpWater4, jmpWater5,
                      accessWater)
#
# Clean-up
#
rm(waterSource, water1, water2, water2a, water3, water3a, water4, water4a, water4b,
   water5, water5a, water5b, water6, water6a, water7, water7a, water7b, water7c,
   water8, water8a, water9,
   water10, water10a, water10b, water11, water11a, water11b, water11c, water11d,
   water12, water12a, water12b, water13, water13a, water14, water14a,
   water16, water16a, water17, water18,
   jmpWater1, jmpWater2, jmpWater3, jmpWater4, jmpWater5, accessWater,
   waterQuality)

	
</command>
							<property title="Water" shape="TRANSFORM"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="151" date="1510899093930" uid="b0675873411fe7e" x="60" y="40">
							<command>
################################################################################
#
# Read processed data
#
################################################################################

surveyData &lt;- read.csv(
	           file = paste(&quot;data/workingSurveyData&quot;, unique(ccode), &quot;.csv&quot;, sep = &quot;&quot;),
	           header = TRUE, sep = &quot;,&quot;
	         )

	</command>
							<property title="Read processed data" shape="INOUT"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="152" date="1510899093931" uid="f01b7003ccf4a363" x="140" y="120">
							<command>
################################################################################
#
# Demographics data
#
################################################################################
#
# Extract demographic data
#
demoDF &lt;- surveyData[ , c(&quot;uniqueID&quot;, &quot;gender&quot;, &quot;landOwnStatus&quot;,
	                     &quot;nWomen&quot;, &quot;nMen&quot;, &quot;nOldWomen&quot;, &quot;nOldMen&quot;,
	                     &quot;nGirls&quot;, &quot;nBoys&quot;, &quot;nInfants&quot;, &quot;nMobility&quot;)]
#
# Count total number of household members
#
nMembers &lt;- surveyData$nWomen + surveyData$nMen + 
            surveyData$nOldMen + surveyData$nOldWomen + 
            surveyData$nGirls + surveyData$nBoys + 
            surveyData$nInfants
#
# Create demographic data.frame
#
demoDF &lt;- data.frame(demoDF, nMembers)
#
# Clean-up
#
rm(nMembers)

</command>
							<property title="Demographic" shape="TRANSFORM"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="153" date="1510899093930" uid="64a81a2eedcd0ed4" x="140" y="40">
							<command>
################################################################################
#
# Admin data
#
################################################################################
#
# Extract identifier data
#
adminDF &lt;- surveyData[ , c(&quot;country&quot;, &quot;ccode&quot;, &quot;uniqueID&quot;, &quot;psu&quot;,
	                      &quot;zone&quot;, &quot;type&quot;, &quot;quadrat&quot;, &quot;hhid&quot;, &quot;month&quot;, &quot;year&quot;,
	                      &quot;longitude&quot;, &quot;latitude&quot;)]

</command>
							<property title="Admin" shape="TRANSFORM"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="154" date="1510899093930" uid="fb9c561dea02e5af" x="300" y="120">
							<command>################################################################################
#
# Handwashing indicators 
#
################################################################################
#
# Check if handwashing facility at home data is available
#
if(exists(&quot;handwashingFacilityDF&quot;))
  {
  #
  # jmpHand1  
  #
  jmpHand1 &lt;- ifelse(surveyData$san107 == &quot;No handwashing station&quot;, 1, 0)
  #
  # jmpHand2
  #
  jmpHand2 &lt;- ifelse(surveyData$san107 == &quot;Handwashing station with water only&quot;, 1, 0)
  #
  # jmpHand3
  #
  jmpHand3 &lt;- ifelse(surveyData$san107 == &quot;Handwashing station with clean water and soap available&quot;, 1, 0)
  } else
  {
  jmpHand1 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
  jmpHand1[jmpHand1 == 0] &lt;- NA
  jmpHand2 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
  jmpHand2[jmpHand2 == 0] &lt;- NA
  jmpHand3 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
  jmpHand3[jmpHand3 == 0] &lt;- NA
  }
  

################################################################################
#
# Create handDF
#
################################################################################
#
# Concatenate handwashing indicators
#
handDF &lt;- data.frame(&quot;uniqueID&quot; = surveyData[ , &quot;uniqueID&quot;],
	                jmpHand1, jmpHand2, jmpHand3)
#
# Clean-up
#
rm(jmpHand1, jmpHand2, jmpHand3)

</command>
							<property title="Handwashing" shape="TRANSFORM"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="155" date="1510899093931" uid="44546ecb0a674162" x="-20" y="40">
							<command></command>
							<property/>
							<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
								<entry key="io">in</entry>
							</option>
						</node>
						<node id="156" date="1510899093930" uid="a5cfe6d85ed4da51" x="300" y="40">
							<command>
################################################################################
#
# Sanitation indicators 
#
################################################################################

################################################################################
#
# san1: shared sanitation facility - user arrangements
#
################################################################################
#
# Re-code
#
san1 &lt;- ifelse(surveyData$san1 == &quot;&quot;, &quot;Don&apos;t know&quot;,
	     ifelse(surveyData$san1 == &quot;Other (please specify)&quot;, 
	            surveyData$san2, 
	            surveyData$san1))
#
# Clean-up
#
san1 &lt;- ifelse(san1 == &quot;Communal / shared toilet &quot;, &quot;Communal / shared toilet&quot;, san1)
#
# san1a: is toilet facility shared with other households
#
san1a &lt;- ifelse(san1 == &quot;Household toilet&quot;, 0, 1)


################################################################################
#
# san2: Number of people who share toilet facilities 
#
################################################################################
#
# san2: Mean number of people who share toilet facilities
#
san2 &lt;- ifelse(is.na(surveyData$san4), 0, surveyData$san4)
#
# san2a: shared toilet facility 
#
san2a &lt;- ifelse(san2 == 0, 0, 1)


################################################################################
#
# san3: type of facility
#
################################################################################
#
# san3: type  of facility
#
san3 &lt;- ifelse(surveyData$san6 == &quot;Other (please specify)&quot;, 
               surveyData$san7, 
               surveyData$san6)
#
# clean-up
#
san3 &lt;- ifelse(san3 %in% c(&quot;Drain&quot;, &quot;Drain connected with waterbody&quot;, 
	                      &quot;Drain with water body (Jhill)&quot;, &quot;Open drain&quot;), &quot;Drain&quot;,
          ifelse(san3 %in% c(&quot;In water body (Jhill)&quot;, &quot;Water body (Lake)&quot;, &quot;Lake&quot;, &quot;Pond&quot;,
	                        &quot;No facilities or bush or field&quot;), 
	                        &quot;No facilities or bush or field or lake or pond&quot;,
            ifelse(san3 %in% c(&quot;Ditch with ring&quot;, &quot;Ring and slub&quot;, 
                               &quot;Slub and in the bottom drain&quot;), 
                               &quot;Ring and slab without pit latrine&quot;, san3)))


################################################################################
#
# san4: where effluent flushes to
#
################################################################################
#
# san4: where effluent flushes to
#
san4 &lt;- ifelse(surveyData$san9 == &quot;&quot;, &quot;Don&apos;t know&quot;,
	     ifelse(surveyData$san9 == &quot;Other (please specify)&quot;, 
	            surveyData$san10, 
	            surveyData$san9))
#
# clean-up
#
san4 &lt;- ifelse(san4 %in% c(&quot;Open drain&quot;, 
                           &quot;Adjacent to pond&quot;, 
                           &quot;Ditch&quot;, 
                           &quot;Ditch &quot;,
	                      &quot;pond&quot;, 
	                      &quot;River&quot;, 
	                      &quot;Water body (Cannel)&quot;), &quot;Open drain/ditch/water body&quot;, 
          ifelse(san4 == &quot;Tanki&quot;, &quot;Septic tank&quot;, san4))


################################################################################
#
# san5: WSUP-supported facility
#
################################################################################
#
# san5: WSUP-supported facility
#
san5 &lt;- ifelse(surveyData$san12 == &quot;&quot; &amp; surveyData$san13 == &quot;TRUE&quot;, &quot;Not applicable&quot;,
	     ifelse(surveyData$san12 == &quot;&quot; &amp; surveyData$san14 == &quot;TRUE&quot;, 
	            &quot;Don&apos;t know&quot;, 
	            surveyData$san12))
#
# re-code
#
san5 &lt;- ifelse(san5 == &quot;Yes&quot;, 1,
	     ifelse(san5 == &quot;No&quot;, 0, NA))


################################################################################
#
# san6: water in facility
#
#################################################################################
#
# san6: water in facility (Yes / No)
#
san6 &lt;- ifelse(surveyData$san15 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san7: satisfied with handwashing facility
#
################################################################################
#
# san7: satisfied with handwashing facility
#
san7 &lt;- ifelse(surveyData$san17 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san8: what would increase your satisfaction
#
################################################################################
#
# Re-code
#
sanSatisfaction &lt;- ifelse(surveyData$san19 == &quot;Other (please specify)&quot;, 
                          surveyData$san20, 
                          surveyData$san19)
sanSatisfaction &lt;- ifelse(sanSatisfaction == &quot;&quot;, 
                          NA, 
                          sanSatisfaction)
sanSatisfaction &lt;- str_split(string = sanSatisfaction, pattern = &quot;, &quot;, simplify = TRUE)
#
# Cycle through columns of sanSatisfaction
#
for(i in 1:ncol(sanSatisfaction))
  {
  sanSatisfaction[ , i] &lt;- ifelse(sanSatisfaction[ , i] == &quot;Other (please specify)&quot;, 
                                  surveyData$san20, 
                                  sanSatisfaction[ , i])
  sanSatisfaction[ , i] &lt;- ifelse(sanSatisfaction[ , i] == &quot;&quot;, 
						    NA, 
						    sanSatisfaction[ , i])
  }
#
# Create temporary container for vector outputs
#
temp &lt;- NULL
#
# Cycle through columns of sanSatisfaction
#
for(i in 1:ncol(sanSatisfaction))
  {
  #
  # Concatenate sanSatisfaction columns into a single vector
  #
  temp &lt;- c(temp, sanSatisfaction[ , i])
  }
#
# Re-assign NA value to &quot;&quot; answers 
#
temp &lt;- ifelse(temp == &quot;&quot;, NA, temp)
#
# Get responses
#
tempNames &lt;- names(table(temp))
#
# Vector accumulator
#
san8 &lt;- NULL
#
# Cycle through responses
#
for(i in 1:length(tempNames))
  {
  #
  # Create empty vector with length of surveyData
  #
  assign(paste(&quot;san8&quot;, letters[i], sep = &quot;&quot;), 
         vector(mode = &quot;numeric&quot;, length = nrow(surveyData)))
  #
  # Cycle through data columns in waterCollect
  #
  for(j in 1:ncol(sanSatisfaction))
    {
    #
    # Assign values
    #
    x &lt;- ifelse(sanSatisfaction[ , j] == tempNames[i], i, 0)
    #
    # Concatenate responses
    #
    assign(paste(&quot;san8&quot;, letters[i], sep = &quot;&quot;), 
           get(paste(&quot;san8&quot;, letters[i], sep = &quot;&quot;)) + x)
    }
  #
  # Rename responses to character strings
  #
  assign(paste(&quot;san8&quot;, letters[i], sep = &quot;&quot;), 
         ifelse(get(paste(&quot;san8&quot;, letters[i], sep = &quot;&quot;)) == i, tempNames[i], NA))
  #
  # Concatenate into data.frame
  #
  san8 &lt;- data.frame(cbind(san8, get(paste(&quot;san8&quot;, letters[i], sep = &quot;&quot;))))
  }
#
# Rename the data.frame
#  
names(san8) &lt;- paste(&quot;san8&quot;, letters[1:length(tempNames)], sep = &quot;&quot;)
#
# Clean-up
#
rm(sanSatisfaction, i, j, temp, tempNames, x)
rm(list = names(san8))


################################################################################
#
# san9: lights in toilet facility
#
################################################################################
#
# san9: lights in toilet facility
#
san9 &lt;- ifelse(surveyData$san22 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san10: toilet facility with lockable door
#
################################################################################
#
# san10: lockable door
#
san10 &lt;- ifelse(surveyData$san24 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san11: container for menstrual hygiene management
#
################################################################################
#
# san11: container for menstrual hygiene management
#
san11 &lt;- ifelse(surveyData$san26 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san12: Sanitary disposal of child&apos;s faeces
#
################################################################################
#
# san12: sanitary disposal of child&apos;s faeces
#
san12 &lt;- ifelse(surveyData$san28 %in% c(&quot;Child used toilet/latrine&quot;, 
	                                   &quot;Put/rinsed into the toilet&quot;), 1, 0)


################################################################################
#
# san13: Waiting time to use the toilet
#
################################################################################
#
# san13: Waiting time to use the toilet
#
san13 &lt;- ifelse(is.na(surveyData$san31), 0, surveyData$san31)
#
# san13a: adequate physical access to sanitation facility
#
san13a &lt;- ifelse(san13 &lt; 30, 1, 0)

################################################################################
#
# san14: spend on sanitation facility
#
################################################################################
#
# san14: spend on sanitation facility
#
san14 &lt;- ifelse(is.na(surveyData$san33), 0, surveyData$san33)


################################################################################
#
# san15: satisfied with spend
#
################################################################################
#
# san15: satisfied with spend
#
san15 &lt;- ifelse(surveyData$san36 == &quot;&quot;, NA,
	       ifelse(surveyData$san36 == &quot;Yes&quot;, 1, 0))


################################################################################
#
# san16: initial investment in toilet facility
#
################################################################################
#
# san16: initial investment in toilet facility
#
san16 &lt;- ifelse(surveyData$san38 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san17: amount of investment
#
################################################################################
#
# san17: amount of investment
#
san17 &lt;- ifelse(is.na(surveyData$san40), 0, surveyData$san40)


################################################################################
#
# san18: willingness to invest
#
################################################################################
#
# san18: willingness to invest
#
san18 &lt;- ifelse(surveyData$san43 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san19: satisfied with cleanliness
#
################################################################################
#
# san19: satisfied with cleanliness
#
san19 &lt;- ifelse(surveyData$san46 == &quot;Yes&quot;, 1,
	       ifelse(surveyData$san46 == &quot;No&quot;, 0, NA))


################################################################################
#
# san20: increase satisfaction
#
################################################################################
#
# Re-code
#
cleanSatisfaction &lt;- ifelse(surveyData$san48 == &quot;Other (please specify)&quot;, 
                            surveyData$san49, 
                            surveyData$san48)
cleanSatisfaction &lt;- ifelse(cleanSatisfaction == &quot;&quot;, 
                            NA, 
                            cleanSatisfaction)
cleanSatisfaction &lt;- str_split(string = cleanSatisfaction, pattern = &quot;, &quot;, simplify = TRUE)
#
# Create temporary container for vector outputs
#
temp &lt;- NULL
#
# Cycle through columns of cleanSatisfaction
#
for(i in 1:ncol(cleanSatisfaction))
  {
  #
  # Re-code 
  #
  cleanSatisfaction[ , i] &lt;- ifelse(cleanSatisfaction[ , i] == &quot;Other (please specify)&quot;, 
                                    surveyData$san20, cleanSatisfaction[ , i])
  cleanSatisfaction[ , i] &lt;- ifelse(cleanSatisfaction[ , i] == &quot;&quot;, 
							 NA, cleanSatisfaction[ , i])
  }
#
# Create temporary container for vector outputs
#
temp &lt;- NULL
#
# Cycle through columns of cleanSatisfaction
#
for(i in 1:ncol(cleanSatisfaction))
  {
  #
  # Concatenate cleanSatisfaction columns into a single vector
  #
  temp &lt;- c(temp, cleanSatisfaction[ , i])
  }
#
# Re-assign NA value to &quot;&quot; answers 
#
temp &lt;- ifelse(temp == &quot;&quot;, NA, temp)
#
# Get responses
#
tempNames &lt;- names(table(temp))
#
# Empty container
#
san20 &lt;- NULL
#
# Cycle through responses
#
for(i in 1:length(tempNames))
  {
  #
  # Create empty vector with length of surveyData
  #
  assign(paste(&quot;san20&quot;, letters[i], sep = &quot;&quot;), 
         vector(mode = &quot;numeric&quot;, length = nrow(surveyData)))
  #
  # Cycle through data columns in cleanSatisfaction
  #
  for(j in 1:ncol(cleanSatisfaction))
    {
    #
    # Assign values
    #
    x &lt;- ifelse(cleanSatisfaction[ , j] == tempNames[i], i, 0)
    #
    # Concatenate responses
    #
    assign(paste(&quot;san20&quot;, letters[i], sep = &quot;&quot;), 
           get(paste(&quot;san20&quot;, letters[i], sep = &quot;&quot;)) + x)
    }
  #
  # Rename responses to character strings
  #
  assign(paste(&quot;san20&quot;, letters[i], sep = &quot;&quot;), 
         ifelse(get(paste(&quot;san20&quot;, letters[i], sep = &quot;&quot;)) == i, tempNames[i], NA))
  #
  # Concatenate into data.frame
  #
  san20 &lt;- data.frame(cbind(san20, get(paste(&quot;san20&quot;, letters[i], sep = &quot;&quot;))))
  }
#
# Rename the data.frame
#  
names(san20) &lt;- paste(&quot;san20&quot;, letters[1:length(tempNames)], sep = &quot;&quot;)
#
# Clean-up
#
rm(cleanSatisfaction, i, j, x, temp, tempNames)
rm(list = names(san20))


################################################################################
#
# san21: Everyone in household able to get to sanitation facility?
#
################################################################################
#
# san21: everyone in household able to get to sanitation facility
#
san21 &lt;- ifelse(surveyData$san51 == &quot;Yes&quot;, 1, 0)


################################################################################
#
# san22: who is not using the sanitation facility?
#
################################################################################
#
# Re-code
#
sanitationUse &lt;- ifelse(surveyData$san53 == &quot;&quot;, NA,
	              ifelse(surveyData$san53 == &quot;Other (please specify)&quot;, 
	                     surveyData$san54, 
	                     surveyData$san53))
sanitationUse &lt;- str_split(string = sanitationUse, pattern = &quot;, &quot;, simplify = TRUE)
#
# Create temporary container for vector outputs
#
temp &lt;- NULL
#
# Cycle through columns of sanitationUse
#
for(i in 1:ncol(sanitationUse))
  {
  sanitationUse[ , i] &lt;- ifelse(sanitationUse[ , i] == &quot;Other (please specify)&quot;, 
                                surveyData$san20, sanitationUse[ , i])
  sanitationUse[ , i] &lt;- ifelse(sanitationUse[ , i] == &quot;&quot;, 
						NA, sanitationUse[ , i])
  }
#
# Create temporary container for vector outputs
#
temp &lt;- NULL
#
# Cycle through columns of sanitationUse
#
for(i in 1:ncol(sanitationUse))
  {
  #
  # Concatenate sanitationUse columns into a single vector
  #
  temp &lt;- c(temp, sanitationUse[ , i])
  }
#
# Re-assign NA value to &quot;&quot; answers 
#
temp &lt;- ifelse(temp == &quot;&quot;, NA, temp)
#
# Get responses
#
tempNames &lt;- names(table(temp))
#
# Vector accumulator
#
san22 &lt;- NULL
#
# Cycle through responses
#
for(i in 1:length(tempNames))
  {
  #
  # Create empty vector with length of surveyData
  #
  assign(paste(&quot;san22&quot;, letters[i], sep = &quot;&quot;), 
         vector(mode = &quot;numeric&quot;, length = nrow(surveyData)))
  #
  # Cycle through data columns in waterCollect
  #
  for(j in 1:ncol(sanitationUse))
    {
    #
    # Assign values
    #
    x &lt;- ifelse(sanitationUse[ , j] == tempNames[i], i, 0)
    #
    # Concatenate responses
    #
    assign(paste(&quot;san22&quot;, letters[i], sep = &quot;&quot;), 
           get(paste(&quot;san22&quot;, letters[i], sep = &quot;&quot;)) + x)
    }
  #
  # Rename responses to character strings
  #
  assign(paste(&quot;san22&quot;, letters[i], sep = &quot;&quot;), 
         ifelse(get(paste(&quot;san22&quot;, letters[i], sep = &quot;&quot;)) == i, tempNames[i], NA))
  #
  # Concatenate into data.frame
  #
  san22 &lt;- data.frame(cbind(san22, get(paste(&quot;san22&quot;, letters[i], sep = &quot;&quot;))))
  }
#
# Rename the data.frame
#  
names(san22) &lt;- paste(&quot;san22&quot;, letters[1:length(tempNames)], sep = &quot;&quot;)
#
# Clean-up
#
rm(sanitationUse, i, j, x, temp, tempNames)
rm(list = names(san22))


################################################################################
#
# san23: do all household members usually use the available sanitation facilities
#
################################################################################
#
# Re-code
#
san23 &lt;- ifelse(surveyData$san59 == &quot;&quot;, &quot;Don&apos;t know&quot;, surveyData$san59)
san23 &lt;- ifelse(san23 == &quot;Yes&quot;, 1,
	      ifelse(san23 == &quot;No&quot;, 0, NA))


################################################################################
#
# san24: who is not using sanitation facilities
#
################################################################################
#
# Re-code
#
sanitationUsage &lt;- ifelse(surveyData$san61 == &quot;&quot;, NA,
	                ifelse(surveyData$san61 == &quot;Other (please specify)&quot;, 
	                       surveyData$san62, surveyData$san61))
sanitationUsage &lt;- str_split(string = sanitationUsage, pattern = &quot;, &quot;, simplify = TRUE)
#
# Create temporary container for vector outputs
#
temp &lt;- NULL
#
# Cycle through columns of sanitationUsage
#
for(i in 1:ncol(sanitationUsage))
  {
  #
  # Assign values
  #
  sanitationUsage[ , i] &lt;- ifelse(sanitationUsage[ , i] == &quot;Other (please specify)&quot;, 
                                  surveyData$san62, 
                                  sanitationUsage[ , i])
  sanitationUsage[ , i] &lt;- ifelse(sanitationUsage[ , i] == &quot;&quot;, 
						NA, 
						sanitationUsage[ , i])
  }
#
# Create temporary container for vector outputs
#
temp &lt;- NULL
#
# Cycle through columns of sanitationUsage
#
for(i in 1:ncol(sanitationUsage))
  {
  #
  # Concatenate sanitationUsage columns into a single vector
  #
  temp &lt;- c(temp, sanitationUsage[ , i])
  }
#
# Re-assign NA value to &quot;&quot; answers 
#
temp &lt;- ifelse(temp == &quot;&quot;, NA, temp)
#
# Get responses
#
tempNames &lt;- names(table(temp))
#
# Vector accumulator
#
san24 &lt;- NULL
#
# Cycle through responses
#
for(i in 1:length(tempNames))
  {
  #
  # Create empty vector with length of surveyData
  #
  assign(paste(&quot;san24&quot;, letters[i], sep = &quot;&quot;), 
         vector(mode = &quot;numeric&quot;, length = nrow(surveyData)))
  #
  # Cycle through data columns in waterCollect
  #
  for(j in 1:ncol(sanitationUsage))
    {
    #
    # Assign values
    #
    x &lt;- ifelse(sanitationUsage[ , j] == tempNames[i], i, 0)
    #
    # Concatenate responses
    #
    assign(paste(&quot;san24&quot;, letters[i], sep = &quot;&quot;), 
           get(paste(&quot;san24&quot;, letters[i], sep = &quot;&quot;)) + x)
    }
  #
  # Rename responses to character strings
  #
  assign(paste(&quot;san24&quot;, letters[i], sep = &quot;&quot;), 
         ifelse(get(paste(&quot;san24&quot;, letters[i], sep = &quot;&quot;)) == i, tempNames[i], NA))
  #
  # Concatenate data.frame
  #
  san24 &lt;- data.frame(cbind(san24, get(paste(&quot;san24&quot;, letters[i], sep = &quot;&quot;))))
  }
#
# Rename the data.frame
#  
names(san24) &lt;- paste(&quot;san24&quot;, letters[1:length(tempNames)], sep = &quot;&quot;)
#
# Clean-up
#
rm(sanitationUsage, i, j, x, temp, tempNames)
rm(list = names(san24))


################################################################################
#
# san25: problem with sanitation facility
#
################################################################################
#
# san25:
#
san25 &lt;- ifelse(surveyData$san66 == &quot;&quot;, &quot;Don&apos;t know&quot;, 
	      ifelse(surveyData$san66 == &quot;Other (please specify)&quot;, 
	             surveyData$san67, 
	             surveyData$san66))
san25 &lt;- ifelse(san25 == &quot;&quot;, &quot;Don&apos;t know&quot;, san25)
#
# Clean-up
#
san25 &lt;- ifelse(san25 %in% c(&quot;Call sweeper by own intiative &quot;, 
                             &quot;Do work by calling sweeper&quot;), 
                             &quot;Call sweeper by own intiative&quot;,
	      ifelse(san25 == &quot;Manager &quot;, &quot;Manager&quot;,
		   ifelse(san25 == &quot;Quarter inside university, so the relevant person of university&quot;, 
		          &quot;Responsible university staff&quot;, 
		          san25)))
#
# Re-code: formal service maintainer
#
san25 &lt;- ifelse(san25 %in% c(&quot;Facility operator&quot;, 
	                        &quot;Quarter inside university, so the relevent person of university&quot;, 
	                        &quot;Water and Sanitation Authority  (WASHA)&quot;), 1, 0)


################################################################################
#
# san31: when should you wash hands?
#
################################################################################
#
# washEvents
#
washEvents &lt;- ifelse(surveyData$san85 == &quot;&quot;, &quot;Don&apos;t know&quot;,
	           ifelse(surveyData$san85 == &quot;Other (please specify)&quot;, 
	                  surveyData$san86, 
	                  surveyData$san85))
washEvents &lt;- str_split(string = washEvents, pattern = &quot;, &quot;, simplify = TRUE)
#
# Create temporary container for vector outputs
#
temp &lt;- NULL
#
# Cycle through columns of washEvents
#
for(i in 1:ncol(washEvents))
  {
  #
  # Assign values
  #
  washEvents[ , i] &lt;- ifelse(washEvents[ , i] == &quot;Other (please specify)&quot;, 
                             surveyData$san86, 
                             washEvents[ , i])
  }
#
# Create temporary container for vector outputs
#
temp &lt;- NULL
#
# Cycle through columns of washEvents
#
for(i in 1:ncol(washEvents))
  {
  #
  # Concatenate washEvents columns into a single vector
  #
  temp &lt;- c(temp, washEvents[ , i])
  }
#
# Re-assign NA value to &quot;&quot; answers 
#
temp &lt;- ifelse(temp == &quot;&quot;, NA, temp)
#
# Get responses
#
tempNames &lt;- names(table(temp))
#
# Vector accumulator
#
san31 &lt;- NULL
#
# Cycle through responses
#
for(i in 1:length(tempNames))
  {
  #
  # Create empty vector with length of surveyData
  #
  assign(paste(&quot;san31&quot;, letters[i], sep = &quot;&quot;), 
         vector(mode = &quot;numeric&quot;, length = nrow(surveyData)))
  #
  # Cycle through data columns in waterCollect
  #
  for(j in 1:ncol(washEvents))
    {
    #
    # Assign values
    #
    x &lt;- ifelse(washEvents[ , j] == tempNames[i], i, 0)
    #
    # Concatenate responses
    #
    assign(paste(&quot;san31&quot;, letters[i], sep = &quot;&quot;), 
           get(paste(&quot;san31&quot;, letters[i], sep = &quot;&quot;)) + x)
    }
  #
  # Rename responses to character strings
  #
  assign(paste(&quot;san31&quot;, letters[i], sep = &quot;&quot;), 
         ifelse(get(paste(&quot;san31&quot;, letters[i], sep = &quot;&quot;)) == i, tempNames[i], NA))
  #
  # Concatenate into data.frame
  #
  san31 &lt;- data.frame(cbind(san31, get(paste(&quot;san31&quot;, letters[i], sep = &quot;&quot;))))
  }
#
# Rename the data.frame
#  
names(san31) &lt;- paste(&quot;san31&quot;, letters[1:length(tempNames)], sep = &quot;&quot;)
#
# Clean-up
#
rm(washEvents, i, j, x, temp, tempNames)
rm(list = names(san31))


################################################################################
#
# san32: households with handwashing facility with soap and water at sanitation facility
#
################################################################################
#
# Re-code
#
san32 &lt;- ifelse(surveyData$san88 == &quot;Handwashing station with clean water and soap available&quot;, 1, 0)


################################################################################
#
# san33: how often is septic tank emptied
#
################################################################################
#
# san33
#
san33 &lt;- ifelse(surveyData$san90 == &quot;Other (please specify)&quot;, surveyData$san91,
	      ifelse(surveyData$san90 == &quot;&quot; &amp; surveyData$san92 == TRUE, NA,
		   ifelse(surveyData$san90 == &quot;&quot; &amp; surveyData$san93 == TRUE, &quot;Don&apos;t know&quot;, surveyData$san90)))
#
# clean-up
#
san33 &lt;- ifelse(!san4 %in% c(&quot;Pit latrine&quot;, &quot;Septic tank&quot;), NA,
           ifelse(san33 %in% c(&quot;new house&quot;, &quot;Did not empty till now&quot;), &quot;Don&apos;t know&quot;,
		   ifelse(san33 %in% c(&quot;Stool go to pond&quot;, 
		                       &quot;Stool go to the cannal&quot;), NA, 
		                                                  san33)))


################################################################################
#
# san34: cost of empyting tank
#
################################################################################
#
# san34
#
san34 &lt;- ifelse(surveyData$san94 == &quot;&quot;, NA, surveyData$san94)


################################################################################
#
# san35: who empties pit
#
################################################################################
#
# san35
#
san35 &lt;- ifelse(surveyData$san98 == &quot;&quot;, &quot;Don&apos;t know/not applicable&quot;,
	      ifelse(surveyData$san98 == &quot;Other (please specify)&quot;, 
	             surveyData$san99, 
	             surveyData$san98))
#
# Clean-up
#
san35a &lt;- ifelse(san35 == &quot;House owner &quot;, &quot;House owner&quot;,
	      ifelse(san35 == &quot;Sweeper &quot;, &quot;Sweeper&quot;,
		   ifelse(san35 == &quot;By own&quot;, &quot;Family member or informal manual emptier&quot;, san35)))
#
# Re-code
#
san35 &lt;- ifelse(san35a %in% c(&quot;Formal larger business&quot;, 
                              &quot;Formal small business using manual or automated tool&quot;,
	                         &quot;Water and Sanitation Authority  (WASHA)&quot;), 1, 0)


################################################################################
#
# san36: who pays for pit to be emptied
#
################################################################################
#
# san36
#
san36 &lt;- ifelse(surveyData$san102 == &quot;&quot;, &quot;Don&apos;t know/not applicable&quot;,
	      ifelse(surveyData$san102 == &quot;Other (please specify)&quot;, 
	             surveyData$san103, 
	             surveyData$san102))
#
# Clean-up
#
san36 &lt;- ifelse(san36 == &quot;Water and Sanitation Authority  (WASHA)&quot;, 
                &quot;Water and Sanitation Authority (WASHA)&quot;,
	      ifelse(san36 == &quot;City corporation &quot;, 
	             &quot;City corporation&quot;,
		   ifelse(san36 == &quot;Owner of house &quot;, 
		          &quot;Owner of house&quot;, san36)))


################################################################################
#
# Re-code san34 to take into account who pays for pit emptying
#
################################################################################
#
# Re-code
#
san34a &lt;- ifelse(san36 != &quot;My household&quot;, NA, san34)

################################################################################
#
# san37: satisfaction with pit emptying service
#
################################################################################
#
# san37
#
san37 &lt;- ifelse(surveyData$san106 == &quot;&quot;, NA,
	      ifelse(surveyData$san106 == &quot;Yes&quot;, 1, 0))


################################################################################
#
# san38: excreta disposal after emptying tank
#
################################################################################
#
# Check if excreta disposal after emtpying data avaiable
#
if(exists(&quot;excretaDisposalDF&quot;))
  {
  #
  # Add re-code logic here using excreta disposal data to create
  # object called san38
  #
  } else
  {
  san38 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
  san38[san38 == 0] &lt;- NA
  }


################################################################################
#
# JMP Post-2015 sanitation indicators
#
################################################################################
#
# jmpSan1: open defecation
#
jmpSan1 &lt;- ifelse(san3 == &quot;No facilities or bush or field or lake or pond&quot;, 1, 0)


#
# jmpSan2: unimproved sanitation facilities
#
jmpSan2 &lt;- ifelse(san3 %in% c(&quot;Hanging toilet/hanging latrine&quot;,
	                         &quot;Pit latrine without slab/open pit&quot;,
	                         &quot;Ring and slab without pit latrine&quot;,
	                         &quot;Drain&quot;), 1, 0)

#
# jmpSan3: limited sanitation facility
#
jmpSan3 &lt;- ifelse(san3 %in% c(&quot;Flush/pour flush&quot;, 
                              &quot;Pit latrine with slab or ventilated improved pit latrine (VIP)&quot;,
						&quot;Portable toilet with emptying service&quot;, 
						&quot;Composting toilet&quot;) &amp;
	             san4 %in% c(&quot;Piped sewer system&quot;, &quot;Pit latrine&quot;, &quot;Septic tank&quot;, &quot;Don&apos;t know&quot;) &amp;
	             san1a == 1, 1, 0)
#
# jmpSan4: at least basic
#
jmpSan4 &lt;- ifelse(san3 %in% c(&quot;Flush/pour flush&quot;, 
			               &quot;Pit latrine with slab or ventilated improved pit latrine (VIP)&quot;,
			               &quot;Portable toilet with emptying service&quot;, 
			               &quot;Composting toilet&quot;) &amp;
		        san4 %in% c(&quot;Piped sewer system&quot;, &quot;Pit latrine&quot;, &quot;Septic tank&quot;, &quot;Don&apos;t know&quot;) &amp;
		        san1a == 0, 1, 0)
#
# jmpSan5: empty
#
jmpSan5 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
jmpSan5[jmpSan5 == 0] &lt;- NA
#
# Check if excretaDisposalDF is available
#
if(exists(&quot;excretaDisposalDF&quot;))
  {
  #
  # jmpSan4: basic sanitation facility
  #
  jmpSan4 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
  #
  # Basic sanitation services - pit latrine system
  #
  jmpSan4[san3 %in% c(&quot;Pit latrine with slab or ventilated improved pit latrine (VIP)&quot;,
			       &quot;Composting toilet&quot;) &amp;
		san4 != &quot;Piped sewer system&quot; &amp;
		san1a == 0 &amp; 
		san33 != &quot;Have never emptied it before&quot; &amp;
		!san38 %in% c(&quot;To a covered and sealed hole (buried)&quot;, 
			         &quot;Taken away through the sewer system to a treatment facility&quot;, 
			         &quot;Taken away by the service provider to a treatment facility&quot;)] &lt;- 1          
  #
  # Basic sanitation services - flush/pour flush/toilet system without piped water system
  #
  jmpSan4[san3 %in% c(&quot;Flush/pour flush&quot;, 
	                 &quot;Portable toilet with emptying service&quot;) &amp;
          san4 != &quot;Piped sewer system&quot; &amp;
          san1a == 0 &amp;
		!san38 %in% c(&quot;To a covered and sealed hole (buried)&quot;, 
			         &quot;Taken away through the sewer system to a treatment facility&quot;, 
			         &quot;Taken away by the service provider to a treatment facility&quot;)] &lt;- 1
  #
  # jmpSan5: safely managed
  #
  jmpSan5 &lt;- vector(mode = &quot;numeric&quot;, length = nrow(surveyData))
  #
  #
  #
  jmpSan5[san3 %in% c(&quot;Flush/pour flush&quot;, 
	                 &quot;Portable toilet with emptying service&quot;) &amp;
          san4 == &quot;Piped sewer system&quot; &amp;
          san1a == 0] &lt;- 1
  #
  #
  #
  jmpSan5[san3 %in% c(&quot;Flush/pour flush&quot;, 
	                 &quot;Portable toilet with emptying service&quot;) &amp;
          san4 %in% c(&quot;Pit latrine&quot;, 
	                 &quot;Septic tank&quot;, 
	                 &quot;Don&apos;t know&quot;) &amp;
          san1a == 0 &amp;
		san38 %in% c(&quot;To a covered and sealed hole (buried)&quot;, 
			        &quot;Taken away through the sewer system to a treatment facility&quot;, 
			        &quot;Taken away by the service provider to a treatment facility&quot;)] &lt;- 1
  #
  #
  #
  jmpSan5[san3 %in% c(&quot;Pit latrine with slab or ventilated improved pit latrine (VIP)&quot;,
	                 &quot;Composting toilet&quot;) &amp;
          san4 != &quot;Piped sewer system&quot; &amp;
          san1a == 0 &amp; 
          (san33 == &quot;Have never emptied it before&quot; |
           san38 %in% c(&quot;To a covered and sealed hole (buried)&quot;, 
	                   &quot;Taken away through the sewer system to a treatment facility&quot;, 
	                   &quot;Taken away by the service provider to a treatment facility&quot;))] &lt;- 1
  }


################################################################################
#
# Adequate sanitaiton facility
#
################################################################################
#
# Re-code
#
adequateSan &lt;- ifelse(san3 %in% c(&quot;Flush/pour flush&quot;, 
                                  &quot;Pit latrine with slab or ventilated improved pit latrine (VIP)&quot;) &amp;
	                 san4 != &quot;Open drain / ditch / water body&quot;, 1, 0)

################################################################################
#
# Accessible sanitation facility
#
################################################################################
#
# Re-code
#
accessSan &lt;- ifelse(san21 == 1 &amp; san23 == 1, 1, 0)


################################################################################
#
# Acceptabl sanitation facility 
#
################################################################################
#
# Re-code for proportion indicator
#
acceptSan &lt;- ifelse(adequateSan == 1 &amp; 
                    san6 == 1 &amp; 
                    san9 == 1 &amp; 
                    san10 == 1 &amp; 
                    san11 == 1, 1, 0)
#
# Re-code for mean indicator
#
acceptDF &lt;- data.frame(adequateSan, san6, san9, san10, san11)
#
# Get acceptable sanitaiton score (0-5)
#
acceptScore &lt;- rowSums(acceptDF, na.rm = TRUE)

################################################################################
#
# Create sanDF
#
################################################################################
#
# Concatenate sanitation indicators
#
sanDF &lt;- data.frame(&quot;uniqueID&quot; = surveyData[ , &quot;uniqueID&quot;],
	                san1, san1a, san2, san2a, san3, san4, san5, san6, san7, san8,
	                san9, san10, san11, san12, san13, san13a, san14, san15, san16, 
	                san17, san18, san19, san20, san21, san22, san23, san24, san25, 
	                san32, san33, san34, san34a, san35, san35a, san36, san37,
	                jmpSan1, jmpSan2, jmpSan3, jmpSan4, jmpSan5,
	                adequateSan, accessSan, acceptSan, acceptScore)
#
# Clean-up
#
rm(san1, san1a, san2, san2a, san3, san4, san5, san6, san7, san9, san10, 
   san11, san12, san13, san13a, san14, san15, san16, san17, san18, san19, san21, 
   san23, san25, san32, san33, san34, san34a, san35, san35a, san36, san37, san22,
   jmpSan1, jmpSan2, jmpSan3, jmpSan4, jmpSan5, adequateSan, accessSan, acceptSan, 
   acceptDF, acceptScore, san20, san24)

</command>
							<property title="Sanitation" shape="TRANSFORM"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="157" date="1510899093931" uid="2da20b4d15684686" x="540" y="40">
							<command></command>
							<property/>
							<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
								<entry key="io">out</entry>
							</option>
						</node>
						<node id="158" date="1510899093931" uid="54102e144e262346" x="380" y="40">
							<command>
################################################################################
#
# Overall indicators
#
################################################################################
#
# overall1: not adequate water and not adequate sanitaiton services
#
overall1 &lt;- ifelse(waterDF$accessWater == 0 &amp; sanDF$adequateSan == 0, 1, 0)
#
# overall2: adequate water only
#
overall2 &lt;- ifelse(waterDF$accessWater == 1 &amp; sanDF$adequateSan == 0, 1, 0)
#
# overall3: adequate sanitation only
#
overall3 &lt;- ifelse(waterDF$accessWater == 0 &amp; sanDF$adequateSan == 1, 1, 0)
#
# overall4: adequate water and adequate sanitation services
#
overall4 &lt;- ifelse(waterDF$accessWater == 1 &amp; sanDF$adequateSan == 1, 1, 0)
#
# Overall spend
#
overallSpend &lt;- rowSums(data.frame(waterDF$water12, sanDF$san14, sanDF$san34a), na.rm = TRUE)

################################################################################
#
# Create overallDF
#
################################################################################
#
# Concatenate overall indicators
#
overallDF &lt;- data.frame(&quot;uniqueID&quot; = surveyData[ , &quot;uniqueID&quot;],
	                   overall1, overall2, overall3, overall4, overallSpend)
#
# Clean-up
#

rm(overall1, overall2, overall3, overall4)

</command>
							<property title="Overall" shape="TRANSFORM"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="159" date="1510899093930" uid="44ce224a8ef3b16b" x="460" y="40">
							<command>
################################################################################
#
# Create master data
#
################################################################################
#
# Merge all data.frames from current survey data
#
temp &lt;- merge(adminDF, demoDF, by = &quot;uniqueID&quot;)
temp &lt;- merge(temp, povertyDF, by = &quot;uniqueID&quot;)
temp &lt;- merge(temp, waterDF, by = &quot;uniqueID&quot;)
temp &lt;- merge(temp, sanDF, by = &quot;uniqueID&quot;)
temp &lt;- merge(temp, handDF, by = &quot;uniqueID&quot;)
temp &lt;- merge(temp, hygieneDF, by = &quot;uniqueID&quot;)
indicatorsDF &lt;- merge(temp, overallDF, by = &quot;uniqueID&quot;)


################################################################################
#
# Add identifier for city corporation - Bangladesh only
#
################################################################################

if(unique(country) == &quot;Bangladesh&quot;)
  {
  #
  #
  #
  xx &lt;- readOGR(dsn = &quot;dhakaCorporations&quot;,
  	           layer = &quot;dhakaCorporations&quot;,
	           verbose = FALSE)
  #
  #
  #
  long.lat.crs &lt;- &quot;+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0&quot;
  #
  #
  #
  xx &lt;- spTransform(x = xx, CRSobj = CRS(long.lat.crs))                          
  #
  #
  #
  yy &lt;- SpatialPointsDataFrame(coords = indicatorsDF[ , c(&quot;longitude&quot;, &quot;latitude&quot;)],
	                          data = indicatorsDF,
	                          proj4string = CRS(long.lat.crs))
  #
  #
  #
  north &lt;- subset(xx, corprtn == &quot;north&quot;)
  south &lt;- subset(xx, corprtn == &quot;south&quot;)
  #
  #
  #
  zz &lt;- ifelse(indicatorsDF$psu %in% intersect(yy, north)@data$psu, &quot;North City Corporation&quot;,
	     ifelse(indicatorsDF$psu %in% intersect(yy, south)@data$psu, &quot;South City Corporation&quot;, &quot;Outside&quot;))
  #
  #
  #
  indicatorsDF$corporation &lt;- zz
  #
  #
  #
  rm(xx, yy, north, south, zz)
  }

if(unique(country) != &quot;Bangladesh&quot;)
  {
  #
  #
  #
  indicatorsDF$corporation &lt;- NA
  }

#
# Save indicators dataset 
#
write.csv(x = indicatorsDF,
	     file = paste(&quot;data/indicatorsData&quot;, 
		             unique(ccode), 
		             unique(month), 
		             unique(year), &quot;.csv&quot;, sep = &quot;&quot;),
	     row.names = FALSE)


################################################################################
#
# Merge all data.frames from all surveys
#
################################################################################
#
# Get range of survey years based on current year
#
survey.date.range &lt;- 2017:str_split(Sys.Date(), pattern = &quot;-&quot;, simplify = TRUE)[ , 1]
#
# Get list of months
#
survey.month.range &lt;- substr(format(ISOdate(2004,1:12,1),&quot;%B&quot;), start = 1, stop = 3)
#
# Get list of countries
#
survey.country.code &lt;- c(&quot;BGD&quot;, &quot;GHA&quot;, &quot;KEN&quot;, &quot;MDG&quot;, &quot;MOZ&quot;, &quot;ZMB&quot;)
#
#
#
indicatorsDataAll &lt;- NULL
#
#
#
for(i in survey.country.code)
  {
  #
  #
  #
  for(j in survey.month.range)
    {
    #
    #
    #
    for(k in survey.date.range)
      {
      #
      #
      #
	 temp &lt;- try(read.csv(file = paste(&quot;data/indicatorsData&quot;, i, j, k, &quot;.csv&quot;, sep = &quot;&quot;),
				       header = TRUE, sep = &quot;,&quot;),
			   silent = TRUE)
	 #
	 #
	 #
	 if(class(temp) == &quot;try-error&quot;) { temp &lt;- NULL }
	 #
      #
      #
	 indicatorsDataAll &lt;- data.frame(rbind(indicatorsDataAll, temp))
	 }
    }
  }
#
# Save indicatorsAll dataset 
#
write.csv(x = indicatorsDataAll,
	     file = &quot;data/indicatorsDataAll.csv&quot;,
	     row.names = FALSE)
#
# Clean-up
#
rm(survey.date.range, survey.month.range, survey.country.code, temp)

</command>
							<property title="Concatenate" shape="SUMMARY"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="160" date="1510899093930" uid="b9f1a5d41081b403" x="220" y="120">
							<command>
################################################################################
#
# Progress out of Poverty Index (PPI) - Bangladesh
#
################################################################################
#
# Check if country is Bangladesh
#
if(unique(surveyData$country) == &quot;Bangladesh&quot;)
  {
  #
  # ppi1: Number of household members 12-years old or younger 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;None&quot;, 32,
  	       ifelse(surveyData$ppi1 == &quot;One&quot;, 16,
		    ifelse(surveyData$ppi1 == &quot;Two&quot;, 10, 0)))
  #
  # ppi2: Do household members 6-12 years old attend school?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;Yes&quot;, 6, 0)
  #
  # ppi3: In past year, any household member do paid work?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;No&quot;, 8, 0)
  #
  # ppi4: Number of rooms used by household
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Three or more&quot;, 5,
	       ifelse(surveyData$ppi4 == &quot;Two&quot;, 3, 0))
  #
  # ppi5: Main construction material of the walls of the main room
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;Brick/cement&quot;, 9,
	       ifelse(surveyData$ppi5 == &quot;Mud brick, or C.I. sheet/wood&quot;, 2, 0))
  #
  # ppi6: Does the household own television?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Yes&quot;, 7, 0)
  #
  # ppi7: Number of fans the household owns
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;Two or more&quot;, 7,
       	  ifelse(surveyData$ppi7 == &quot;One&quot;, 4, 0))
  #
  # ppi8: Number of mobile phones the household owns
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;Two or more&quot;, 15,
  	       ifelse(surveyData$ppi8 == &quot;One&quot;, 8, 0))
  #
  # ppi9: Does household own bicycles, motorcycles/scooters, cars?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;Yes&quot;, 4, 0)
  #
  # ppi10: Does the household own/rent/sharecrop/mortgage in or out 51 or more
  #        decimals of cultivable agricultural land
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;Yes&quot;, 7, 0)
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: load lookup table
  #
  #ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableBGD.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrixBGD[ppiMatrixBGD[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }




################################################################################
#
# Progress out of Poverty Index (PPI) - Ghana
#
################################################################################
#
# Check if country is Ghana
#
if(unique(surveyData$country) == &quot;Ghana&quot;)
  {
  #
  # ppi1: Number of household members 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;One&quot;, 29,
		  ifelse(surveyData$ppi1 == &quot;Two&quot;, 24,
		    ifelse(surveyData$ppi1 == &quot;Three&quot;, 21,
		      ifelse(surveyData$ppi1 == &quot;Four&quot;, 14,
		        ifelse(surveyData$ppi1 == &quot;Five&quot;, 13,
		          ifelse(surveyData$ppi1 == &quot;Six&quot;, 9,
		            ifelse(surveyData$ppi1 == &quot;Seven&quot;, 4, 0)))))))
  #
  # ppi2: Are all household members ages 5 to 17 currently in school?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;Yes&quot;, 2, 
            ifelse(surveyData$ppi2 == &quot;No one ages 5 to 17&quot;, 3, 0))
  #
  # ppi3: Can the male head/spouse read a phrase/sentence in English?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;No male head/spouse&quot;, 2,
            ifelse(surveyData$ppi3 == &quot;Yes&quot;, 5, 0))
  #
  # ppi4: What is the main construction material used for the outer wall?
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Cement/concrete blocks, landcrete, stone, or burnt bricks&quot;, 5, 0)
  #
  # ppi5: What type of toilet facility is usually used by the household?
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;KVIP, or W.C.&quot;, 6,
		  ifelse(surveyData$ppi5 == &quot;Public toilet (e.g., W.C., KVIP, pitpan)&quot;, 4, 
		    ifelse(surveyData$ppi5 == &quot;Pit latrine, bucket/pan&quot;, 4, 0)))
  #
  # ppi6: What is the main fuel used by the household for cooking?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Gas, or electricity&quot;, 22,
            ifelse(surveyData$ppi6 == &quot;Charcoal, or kerosene&quot;, 13,
              ifelse(surveyData$ppi6 == &quot;Wood, crop residue, sawdust, animal waste, or other&quot;, 6, 0)))
  #
  # ppi7: Does any household member own a working box iron or electric iron?
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;Yes&quot;, 4, 0)
  #
  # ppi8: Does any household member own a working television, video player,
  #       VCD/DVD/MP3/MP4 player/iPod, or satellite dish?
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;No&quot;, 0,
		  ifelse(surveyData$ppi8 == &quot;Only television&quot;, 2, 8))
  #
  # ppi9: How many working mobile phones are owned by members of the household?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;None&quot;, 0,
            ifelse(surveyData$ppi9 == &quot;One&quot;, 4,
              ifelse(surveyData$ppi9 == &quot;Two&quot;, 8, 10)))
  #
  # ppi10: Does any household member own a working bicycle, motor cycle, or car?
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;None&quot;, 0,
             ifelse(surveyData$ppi10 == &quot;Only bicycle&quot;, 3, 8))
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: lookup table
  #
  #ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableGHA.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrixGHA[ppiMatrixGHA[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }




################################################################################
#
# Progress out of Poverty Index (PPI) - Mozambique
#
################################################################################
#
# Check if country is Mozambique
#
if(unique(surveyData$country) == &quot;Mozambique&quot;)
  {
  #
  # ppi1: How many members does the household have 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;One&quot;, 34,
		  ifelse(surveyData$ppi1 == &quot;Two&quot;, 30,
		    ifelse(surveyData$ppi1 == &quot;Three&quot;, 23, 
		      ifelse(surveyData$ppi1 == &quot;Four&quot;, 15,
		        ifelse(surveyData$ppi1 == &quot;Five&quot;, 9,
		          ifelse(surveyData$ppi1 == &quot;Six&quot;, 7,
		            ifelse(surveyData$ppi1 == &quot;Seven&quot;, 2, 0)))))))
  #
  # ppi2: What is the main material of the floor of the residence (excluding
  #       kitchen and bathrooms)?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;Uncovered, or other&quot;, 0, 6)
  #
  # ppi3: What is the main material of the walls of the residence?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;Adobe blocks, wattle and daub, cement blocks, or bricks&quot;, 7, 0)
  #
  # ppi4: What toilet arrangement does the household use in its residence?
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Toilet connected to a septic tank&quot;, 14,
	  	  ifelse(surveyData$ppi4 == &quot;Latrine of any kind&quot;, 6, 0))
  #
  # ppi5: What is the main source of energy for lighting in the residence?
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;Electricity, generator, or solar panel&quot;, 5,
		  ifelse(surveyData$ppi5 == &quot;Other&quot;, 3, 
		    ifelse(surveyData$ppi5 == &quot;LPG, oil/paraffin/kerosene, or candles&quot;, 1, 0)))
  #
  # ppi6: Does the household have a non-electric or electric clothes iron?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Yes&quot;, 3, 0)
  #
  # ppi7: Does the household have a clock (wall, wrist, or pocket)?
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;Yes&quot;, 4, 0)
  #
  # ppi8: Does the household have a radio, stereo system, or cassette player?
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;Stereo system or cassette player (regardless of radio)&quot;, 7,
		  ifelse(surveyData$ppi8 == &quot;Radio only&quot;, 5, 0))
  #
  # ppi9: Does the household have a bicycle, motorcycle, or car?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;No&quot;, 0,
            ifelse(surveyData$ppi9 == &quot;Bicycle only&quot;, 5, 15))
  #
  # ppi10: How many beds does the household have (single, double, 
  #        beds, or for children)?
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;None&quot;, 0,
             ifelse(surveyData$ppi10 == &quot;One&quot;, 2, 5))
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: lookup table
  #
  #ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableMOZ.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrixMOZ[ppiMatrixMOZ[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }




################################################################################
#
# Progress out of Poverty Index (PPI) - Kenya
#
################################################################################
#
# Check if country is Kenya
#
if(unique(surveyData$country) == &quot;Kenya&quot;)
  {
  #
  # ppi1: How many members does the household have 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;One or two&quot;, 32,
		  ifelse(surveyData$ppi1 == &quot;Three&quot;, 22,
		    ifelse(surveyData$ppi1 == &quot;Four&quot;, 18, 
		      ifelse(surveyData$ppi1 == &quot;Five&quot;, 12,
		        ifelse(surveyData$ppi1 == &quot;Six&quot;, 8,
		          ifelse(surveyData$ppi1 == &quot;Seven or eight&quot;, 5, 0))))))
  #
  # ppi2: What is the highest school grade that the female head/spouse has 
  #       completed?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;Secondary form 4 or higher&quot;, 11,
            ifelse(surveyData$ppi2 == &quot;No female head/spouse&quot;, 6,
              ifelse(surveyData$ppi2 == &quot;Primary standard 8, or secondary forms 1 to 3&quot;, 6,
                ifelse(surveyData$ppi2 == &quot;Primary standard 7&quot;, 2,
                  ifelse(surveyData$ppi2 == &quot;Primary standards 1 to 6&quot;, 1, 0)))))
  #
  # ppi3: What kind of business (type of industry) is the main occupation of the
  #       male head/spouse connected with?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;Any other&quot;, 9, 
            ifelse(surveyData$ppi3 == &quot;Agriculture, hunting, forestry, fishing, mining, or quarrying&quot;, 7,
              ifelse(surveyData$ppi3 == &quot;No male head/spouse&quot;, 3,
                ifelse(surveyData$ppi3 == &quot;Sixth grade&quot;, 2, 0))))
  #
  # ppi4: How many habitable rooms does this household occupy in its main
  #       dwelling (do not count bathrooms, toilets, storerooms, or gargage)?
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Four or more&quot;, 8,
            ifelse(surveyData$ppi4 == &quot;Three&quot;, 5,
              ifelse(surveyData$ppi4 == &quot;Two&quot;, 2, 0)))
  #
  # ppi5: The floor of the main dwelling is predominantly made of what material?
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;Cement, or tiles&quot;, 3, 0)
  #
  # ppi6: What is the main source of lighting fuel for the household?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Electricity, solar, or gas&quot;, 12,
            ifelse(surveyData$ppi6 == &quot;Paraffin, candles, biogas, or other&quot;, 6, 0))
  #
  # ppi7: Does your household own any irons (charcoal or electric)?
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;Yes&quot;, 4, 0)
  #
  # ppi8: How many mosquito nets does your household own?
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;Two or more&quot;, 4,
		    ifelse(surveyData$ppi8 == &quot;One&quot;, 2, 0))
  #
  # ppi9: How many towels does your household own?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;Two or more&quot;, 10,
            ifelse(surveyData$ppi9 == &quot;One&quot;, 6, 0))
  #
  # ppi10: How many frying pans does your household own?
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;Two or more&quot;, 7,
             ifelse(surveyData$ppi10 == &quot;One&quot;, 3, 0))
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: lookup table
  #
  #ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableKEN.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrixKEN[ppiMatrixKEN[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }




################################################################################
#
# Progress out of Poverty Index (PPI) - Madagascar
#
################################################################################
#
# Check if country is Madagascar
#
if(unique(surveyData$country) == &quot;Madagascar&quot;)
  {
  #
  # ppi1: How many members does the household have 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;One&quot;, 38,
		  ifelse(surveyData$ppi1 == &quot;Two&quot;, 33,
		    ifelse(surveyData$ppi1 == &quot;Three&quot;, 25, 
		      ifelse(surveyData$ppi1 == &quot;Four&quot;, 19,
		        ifelse(surveyData$ppi1 == &quot;Five&quot;, 13,
		          ifelse(surveyData$ppi1 == &quot;Six&quot;, 9,
		            ifelse(surveyData$ppi1 == &quot;Seven&quot;, 6,
		              ifelse(surveyData$ppi1 == &quot;Eight&quot;, 5, 0))))))))
  #
  # ppi2: Can the (oldest) female head/spouse read a simple message?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;No&quot;, 0,
            ifelse(surveyData$ppi2 == &quot;Yes&quot;, 2, 3))
  #
  # ppi3: What is the main material of the floor of the residence?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;Cement, concrete, or fiberglass&quot;, 11, 
            ifelse(surveyData$ppi3 == &quot;Wood, stone, or brick&quot;, 8,
              ifelse(surveyData$ppi3 == &quot;Dirt (with or without mats)&quot;, 5, 0)))
  #
  # ppi4: What is the main permanent ceiling material?
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Bark, leaves, stems, dirt, or mud&quot;, 0,
            ifelse(surveyData$ppi4 == &quot;No ceiling, or other&quot;, 3, 7))
  #
  # ppi5: How many tables does the household have?
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;Two or more&quot;, 6,
            ifelse(surveyData$ppi5 == &quot;One&quot;, 2, 0))
  #
  # ppi6: How many beds does the household have?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Three or more&quot;, 9,
            ifelse(surveyData$ppi6 == &quot;Two&quot;, 4,
              ifelse(surveyData$ppi6 == &quot;One&quot;, 2, 0)))
  #
  # ppi7: Does the household have a radio, radio/cassette player, or hi-fi
  #       stereo system?
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;Yes&quot;, 5, 0)
  #
  # ppi8: Does the household have a television?
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;Yes&quot;, 14, 0)
  #
  # ppi9: Does the household have a bicycle, motorcycle/scooter, tractor or
  #       car of its own (not counting business vehicles)?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;Yes&quot;, 4, 0)
  #
  # ppi10: Does the household have an agricultural storage shed?
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;Yes&quot;, 3, 0)
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: lookup table
  #
  #ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableMDG.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrixMDG[ppiMatrixMDG[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }




################################################################################
#
# Progress out of Poverty Index (PPI) - Zambia
#
################################################################################
#
# Check if country is Zambia
#
if(unique(surveyData$country) == &quot;Zambia&quot;)
  {
  #
  # ppi1: How many members does the household have 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;One or two&quot;, 29,
		  ifelse(surveyData$ppi1 == &quot;Three&quot;, 21,
		    ifelse(surveyData$ppi1 == &quot;Four&quot;, 15, 
		      ifelse(surveyData$ppi1 == &quot;Five&quot;, 11,
		        ifelse(surveyData$ppi1 == &quot;Six&quot;, 9,
		          ifelse(surveyData$ppi1 == &quot;Seven&quot;, 7, 0))))))
  #
  # ppi2: Are all household members ages 7 to 16 currently attending school?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;No&quot;, 0,
            ifelse(surveyData$ppi2 == &quot;Yes&quot;, 3, 6))
  #
  # ppi3: What is the highest grade that a female head/spouse has attained?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;Tenth grade or higher&quot;, 9, 
            ifelse(surveyData$ppi3 == &quot;No female head/spouse&quot;, 5,
              ifelse(surveyData$ppi3 == &quot;Seventh to ninth grade&quot;, 4,
                ifelse(surveyData$ppi3 == &quot;Sixth grade&quot;, 2, 0))))
  #
  # ppi4: What kind of building material is the floor of this dwelling made of?
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Concrete, or covered concrete&quot;, 2, 0)
  #
  # ppi5: What kind of building material is the roof of this dwelling made of?
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;Concrete, asbestos sheets, or asbestos tiles&quot;, 5,
		  ifelse(surveyData$ppi5 == &quot;Iron sheets, or other non-asbestos tiles&quot;, 3, 0))
  #
  # ppi6: What is the main type of energy that your household uses for cooking?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Gas, electricity, solar, or kerosene/paraffin&quot;, 15,
            ifelse(surveyData$ppi6 == &quot;Charcoal&quot;, 4, 0))
  #
  # ppi7: Does your household own any televisions, DVDs/VCRs or home theatres,
  #       or satellite dish/decoders (free to air, or DSTV) or other pay-TV
  #       arrangements?
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;TV, and something else (DVD, dish, etc.&quot;, 10,
            ifelse(surveyData$ppi7 == &quot;TV, but nothing else&quot;, 6,  0))
  #
  # ppi8: Does your household own any non-electric or electric irons?
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;Electric, or both electric and non-electric&quot;, 11,
		  ifelse(surveyData$ppi8 == &quot;Only non-electric&quot;, 4, 0))
  #
  # ppi9: Does your household own any cellular phones?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;No&quot;, 0, 6)
  #
  # ppi10: How many beds and mattresses does your household own?
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;Two or more mattresses (regardless of beds)&quot;, 7,
             ifelse(surveyData$ppi10 == &quot;One mattress (regardless of beds&quot;, 4,
               ifelse(surveyData$ppi10 == &quot;One or more beds, but no mattresses&quot;, 2, 0)))
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: lookup table
  #
  #ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableZMB.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrixZMB[ppiMatrixZMB[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }



################################################################################
#                                                                              #
# Group population by wealth quintiles                                         #
#                                                                              #
################################################################################
#
# Find the quintile cutoffs for PPI
#
qCutOff &lt;- quantile(ppi, probs = c(0.2, 0.4, 0.6, 0.8, 1))
#
# Classify households by wealth quintile
#
pQuintile &lt;- ifelse(ppi &lt;= qCutOff[1], 1,
	ifelse(ppi &gt; qCutOff[1] &amp; ppi &lt;= qCutOff[2], 2,
		ifelse(ppi &gt; qCutOff[2] &amp; ppi &lt;= qCutOff[3], 3,
			ifelse(ppi &gt; qCutOff[3] &amp; ppi &lt;= qCutOff[4], 4, 5))))
#
# Concatenate PPI indicators into single data.frame
#
povertyDF &lt;- data.frame(&quot;uniqueID&quot; = surveyData[ , &quot;uniqueID&quot;],
                        ppi, pQuintile, pPoverty)

</command>
							<property title="Poverty" shape="TRANSFORM"/>
							<option type="com.ef_prime.rflow.node.base.SubflowNodeModel">
								<subflow>
									<graph version="0.8" width="1444" height="513" locationtype="a" offsetx="140" offsety="110">
										<node id="161" date="1510899093930" uid="baba7bdbadb947fa" x="40" y="90">
											<command>

################################################################################
#
# Progress out of Poverty Index (PPI) - Zambia
#
################################################################################
#
# Check if country is Zambia
#
if(unique(surveyData$country) == &quot;Zambia&quot;)
  {
  #
  # ppi1: How many members does the household have 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;One or two&quot;, 29,
		  ifelse(surveyData$ppi1 == &quot;Three&quot;, 21,
		    ifelse(surveyData$ppi1 == &quot;Four&quot;, 15, 
		      ifelse(surveyData$ppi1 == &quot;Five&quot;, 11,
		        ifelse(surveyData$ppi1 == &quot;Six&quot;, 9,
		          ifelse(surveyData$ppi1 == &quot;Seven&quot;, 7, 0))))))
  #
  # ppi2: Are all household members ages 7 to 16 currently attending school?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;No&quot;, 0,
            ifelse(surveyData$ppi2 == &quot;Yes&quot;, 3, 6))
  #
  # ppi3: What is the highest grade that a female head/spouse has attained?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;Tenth grade or higher&quot;, 9, 
            ifelse(surveyData$ppi3 == &quot;No female head/spouse&quot;, 5,
              ifelse(surveyData$ppi3 == &quot;Seventh to ninth grade&quot;, 4,
                ifelse(surveyData$ppi3 == &quot;Sixth grade&quot;, 2, 0))))
  #
  # ppi4: What kind of building material is the floor of this dwelling made of?
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Concrete, or covered concrete&quot;, 2, 0)
  #
  # ppi5: What kind of building material is the roof of this dwelling made of?
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;Concrete, asbestos sheets, or asbestos tiles&quot;, 5,
		  ifelse(surveyData$ppi5 == &quot;Iron sheets, or other non-asbestos tiles&quot;, 3, 0))
  #
  # ppi6: What is the main type of energy that your household uses for cooking?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Gas, electricity, solar, or kerosene/paraffin&quot;, 15,
            ifelse(surveyData$ppi6 == &quot;Charcoal&quot;, 4, 0))
  #
  # ppi7: Does your household own any televisions, DVDs/VCRs or home theatres,
  #       or satellite dish/decoders (free to air, or DSTV) or other pay-TV
  #       arrangements?
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;TV, and something else (DVD, dish, etc.&quot;, 10,
            ifelse(surveyData$ppi7 == &quot;TV, but nothing else&quot;, 6,  0))
  #
  # ppi8: Does your household own any non-electric or electric irons?
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;Electric, or both electric and non-electric&quot;, 11,
		  ifelse(surveyData$ppi8 == &quot;Only non-electric&quot;, 4, 0))
  #
  # ppi9: Does your household own any cellular phones?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;No&quot;, 0, 6)
  #
  # ppi10: How many beds and mattresses does your household own?
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;Two or more mattresses (regardless of beds)&quot;, 7,
             ifelse(surveyData$ppi10 == &quot;One mattress (regardless of beds&quot;, 4,
               ifelse(surveyData$ppi10 == &quot;One or more beds, but no mattresses&quot;, 2, 0)))
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: lookup table
  #
  #ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableZMB.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrixZMB[ppiMatrixZMB[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }

</command>
											<property title="Zambia" shape="TRANSFORM"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<node id="162" date="1510899093930" uid="2896ae87ecf91a07" x="40" y="-70">
											<command></command>
											<property/>
											<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
												<entry key="io">in</entry>
											</option>
										</node>
										<node id="163" date="1510899093930" uid="dc8ce08f87d5454b" x="200" y="90">
											<command>

################################################################################
#
# Progress out of Poverty Index (PPI) - Kenya
#
################################################################################
#
# Check if country is Kenya
#
if(unique(surveyData$country) == &quot;Kenya&quot;)
  {
  #
  # ppi1: How many members does the household have 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;One or two&quot;, 32,
		  ifelse(surveyData$ppi1 == &quot;Three&quot;, 22,
		    ifelse(surveyData$ppi1 == &quot;Four&quot;, 18, 
		      ifelse(surveyData$ppi1 == &quot;Five&quot;, 12,
		        ifelse(surveyData$ppi1 == &quot;Six&quot;, 8,
		          ifelse(surveyData$ppi1 == &quot;Seven or eight&quot;, 5, 0))))))
  #
  # ppi2: What is the highest school grade that the female head/spouse has 
  #       completed?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;Secondary form 4 or higher&quot;, 11,
            ifelse(surveyData$ppi2 == &quot;No female head/spouse&quot;, 6,
              ifelse(surveyData$ppi2 == &quot;Primary standard 8, or secondary forms 1 to 3&quot;, 6,
                ifelse(surveyData$ppi2 == &quot;Primary standard 7&quot;, 2,
                  ifelse(surveyData$ppi2 == &quot;Primary standards 1 to 6&quot;, 1, 0)))))
  #
  # ppi3: What kind of business (type of industry) is the main occupation of the
  #       male head/spouse connected with?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;Any other&quot;, 9, 
            ifelse(surveyData$ppi3 == &quot;Agriculture, hunting, forestry, fishing, mining, or quarrying&quot;, 7,
              ifelse(surveyData$ppi3 == &quot;No male head/spouse&quot;, 3,
                ifelse(surveyData$ppi3 == &quot;Sixth grade&quot;, 2, 0))))
  #
  # ppi4: How many habitable rooms does this household occupy in its main
  #       dwelling (do not count bathrooms, toilets, storerooms, or gargage)?
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Four or more&quot;, 8,
            ifelse(surveyData$ppi4 == &quot;Three&quot;, 5,
              ifelse(surveyData$ppi4 == &quot;Two&quot;, 2, 0)))
  #
  # ppi5: The floor of the main dwelling is predominantly made of what material?
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;Cement, or tiles&quot;, 3, 0)
  #
  # ppi6: What is the main source of lighting fuel for the household?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Electricity, solar, or gas&quot;, 12,
            ifelse(surveyData$ppi6 == &quot;Paraffin, candles, biogas, or other&quot;, 6, 0))
  #
  # ppi7: Does your household own any irons (charcoal or electric)?
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;Yes&quot;, 4, 0)
  #
  # ppi8: How many mosquito nets does your household own?
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;Two or more&quot;, 4,
		    ifelse(surveyData$ppi8 == &quot;One&quot;, 2, 0))
  #
  # ppi9: How many towels does your household own?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;Two or more&quot;, 10,
            ifelse(surveyData$ppi9 == &quot;One&quot;, 6, 0))
  #
  # ppi10: How many frying pans does your household own?
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;Two or more&quot;, 7,
             ifelse(surveyData$ppi10 == &quot;One&quot;, 3, 0))
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: lookup table
  #
  #ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableKEN.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrixKEN[ppiMatrixKEN[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }

</command>
											<property title="Kenya" shape="TRANSFORM"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<node id="164" date="1510899093930" uid="76ad5037f944dc74" x="40" y="240">
											<command></command>
											<property/>
											<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
												<entry key="io">out</entry>
											</option>
										</node>
										<node id="165" date="1510899093930" uid="f8d808312cd187fb" x="120" y="10">
											<command>

################################################################################
#
# Progress out of Poverty Index (PPI) - Ghana
#
################################################################################
#
# Check if country is Ghana
#
if(unique(surveyData$country) == &quot;Ghana&quot;)
  {
  #
  # ppi1: Number of household members 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;One&quot;, 29,
		  ifelse(surveyData$ppi1 == &quot;Two&quot;, 24,
		    ifelse(surveyData$ppi1 == &quot;Three&quot;, 21,
		      ifelse(surveyData$ppi1 == &quot;Four&quot;, 14,
		        ifelse(surveyData$ppi1 == &quot;Five&quot;, 13,
		          ifelse(surveyData$ppi1 == &quot;Six&quot;, 9,
		            ifelse(surveyData$ppi1 == &quot;Seven&quot;, 4, 0)))))))
  #
  # ppi2: Are all household members ages 5 to 17 currently in school?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;Yes&quot;, 2, 
            ifelse(surveyData$ppi2 == &quot;No one ages 5 to 17&quot;, 3, 0))
  #
  # ppi3: Can the male head/spouse read a phrase/sentence in English?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;No male head/spouse&quot;, 2,
            ifelse(surveyData$ppi3 == &quot;Yes&quot;, 5, 0))
  #
  # ppi4: What is the main construction material used for the outer wall?
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Cement/concrete blocks, landcrete, stone, or burnt bricks&quot;, 5, 0)
  #
  # ppi5: What type of toilet facility is usually used by the household?
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;KVIP, or W.C.&quot;, 6,
		  ifelse(surveyData$ppi5 == &quot;Public toilet (e.g., W.C., KVIP, pitpan)&quot;, 4, 
		    ifelse(surveyData$ppi5 == &quot;Pit latrine, bucket/pan&quot;, 4, 0)))
  #
  # ppi6: What is the main fuel used by the household for cooking?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Gas, or electricity&quot;, 22,
            ifelse(surveyData$ppi6 == &quot;Charcoal, or kerosene&quot;, 13,
              ifelse(surveyData$ppi6 == &quot;Wood, crop residue, sawdust, animal waste, or other&quot;, 6, 0)))
  #
  # ppi7: Does any household member own a working box iron or electric iron?
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;Yes&quot;, 4, 0)
  #
  # ppi8: Does any household member own a working television, video player,
  #       VCD/DVD/MP3/MP4 player/iPod, or satellite dish?
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;No&quot;, 0,
		  ifelse(surveyData$ppi8 == &quot;Only television&quot;, 2, 8))
  #
  # ppi9: How many working mobile phones are owned by members of the household?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;None&quot;, 0,
            ifelse(surveyData$ppi9 == &quot;One&quot;, 4,
              ifelse(surveyData$ppi9 == &quot;Two&quot;, 8, 10)))
  #
  # ppi10: Does any household member own a working bicycle, motor cycle, or car?
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;None&quot;, 0,
             ifelse(surveyData$ppi10 == &quot;Only bicycle&quot;, 3, 8))
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: lookup table
  #
  #ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableGHA.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrixGHA[ppiMatrixGHA[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }

</command>
											<property title="Ghana" shape="TRANSFORM"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<node id="166" date="1510899093930" uid="bcef3b53755005f7" x="120" y="90">
											<command>

################################################################################
#
# Progress out of Poverty Index (PPI) - Madagascar
#
################################################################################
#
# Check if country is Madagascar
#
if(unique(surveyData$country) == &quot;Madagascar&quot;)
  {
  #
  # ppi1: How many members does the household have 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;One&quot;, 38,
		  ifelse(surveyData$ppi1 == &quot;Two&quot;, 33,
		    ifelse(surveyData$ppi1 == &quot;Three&quot;, 25, 
		      ifelse(surveyData$ppi1 == &quot;Four&quot;, 19,
		        ifelse(surveyData$ppi1 == &quot;Five&quot;, 13,
		          ifelse(surveyData$ppi1 == &quot;Six&quot;, 9,
		            ifelse(surveyData$ppi1 == &quot;Seven&quot;, 6,
		              ifelse(surveyData$ppi1 == &quot;Eight&quot;, 5, 0))))))))
  #
  # ppi2: Can the (oldest) female head/spouse read a simple message?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;No&quot;, 0,
            ifelse(surveyData$ppi2 == &quot;Yes&quot;, 2, 3))
  #
  # ppi3: What is the main material of the floor of the residence?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;Cement, concrete, or fiberglass&quot;, 11, 
            ifelse(surveyData$ppi3 == &quot;Wood, stone, or brick&quot;, 8,
              ifelse(surveyData$ppi3 == &quot;Dirt (with or without mats)&quot;, 5, 0)))
  #
  # ppi4: What is the main permanent ceiling material?
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Bark, leaves, stems, dirt, or mud&quot;, 0,
            ifelse(surveyData$ppi4 == &quot;No ceiling, or other&quot;, 3, 7))
  #
  # ppi5: How many tables does the household have?
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;Two or more&quot;, 6,
            ifelse(surveyData$ppi5 == &quot;One&quot;, 2, 0))
  #
  # ppi6: How many beds does the household have?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Three or more&quot;, 9,
            ifelse(surveyData$ppi6 == &quot;Two&quot;, 4,
              ifelse(surveyData$ppi6 == &quot;One&quot;, 2, 0)))
  #
  # ppi7: Does the household have a radio, radio/cassette player, or hi-fi
  #       stereo system?
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;Yes&quot;, 5, 0)
  #
  # ppi8: Does the household have a television?
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;Yes&quot;, 14, 0)
  #
  # ppi9: Does the household have a bicycle, motorcycle/scooter, tractor or
  #       car of its own (not counting business vehicles)?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;Yes&quot;, 4, 0)
  #
  # ppi10: Does the household have an agricultural storage shed?
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;Yes&quot;, 3, 0)
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: lookup table
  #
  #ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableMDG.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrixMDG[ppiMatrixMDG[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }

</command>
											<property title="Madagascar" shape="TRANSFORM"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<node id="167" date="1510899093930" uid="c8174f580609b776" x="40" y="170">
											<command>
################################################################################
#                                                                              #
# Group population by wealth quintiles                                         #
#                                                                              #
################################################################################
#
# Find the quintile cutoffs for PPI
#
qCutOff &lt;- quantile(ppi, probs = c(0.2, 0.4, 0.6, 0.8, 1))
#
# Classify households by wealth quintile
#
pQuintile &lt;- ifelse(ppi &lt;= qCutOff[1], 1,
	ifelse(ppi &gt; qCutOff[1] &amp; ppi &lt;= qCutOff[2], 2,
		ifelse(ppi &gt; qCutOff[2] &amp; ppi &lt;= qCutOff[3], 3,
			ifelse(ppi &gt; qCutOff[3] &amp; ppi &lt;= qCutOff[4], 4, 5))))
#
# Concatenate PPI indicators into single data.frame
#
povertyDF &lt;- data.frame(&quot;uniqueID&quot; = surveyData[ , &quot;uniqueID&quot;],
                        ppi, pQuintile, pPoverty)

</command>
											<property title="Calculate PPI" shape="SUMMARY"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<node id="168" date="1510899093930" uid="a106cc55453a8a08" x="200" y="10">
											<command>

################################################################################
#
# Progress out of Poverty Index (PPI) - Mozambique
#
################################################################################
#
# Check if country is Mozambique
#
if(unique(surveyData$country) == &quot;Mozambique&quot;)
  {
  #
  # ppi1: How many members does the household have 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;One&quot;, 34,
		  ifelse(surveyData$ppi1 == &quot;Two&quot;, 30,
		    ifelse(surveyData$ppi1 == &quot;Three&quot;, 23, 
		      ifelse(surveyData$ppi1 == &quot;Four&quot;, 15,
		        ifelse(surveyData$ppi1 == &quot;Five&quot;, 9,
		          ifelse(surveyData$ppi1 == &quot;Six&quot;, 7,
		            ifelse(surveyData$ppi1 == &quot;Seven&quot;, 2, 0)))))))
  #
  # ppi2: What is the main material of the floor of the residence (excluding
  #       kitchen and bathrooms)?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;Uncovered, or other&quot;, 0, 6)
  #
  # ppi3: What is the main material of the walls of the residence?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;Adobe blocks, wattle and daub, cement blocks, or bricks&quot;, 7, 0)
  #
  # ppi4: What toilet arrangement does the household use in its residence?
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Toilet connected to a septic tank&quot;, 14,
	  	  ifelse(surveyData$ppi4 == &quot;Latrine of any kind&quot;, 6, 0))
  #
  # ppi5: What is the main source of energy for lighting in the residence?
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;Electricity, generator, or solar panel&quot;, 5,
		  ifelse(surveyData$ppi5 == &quot;Other&quot;, 3, 
		    ifelse(surveyData$ppi5 == &quot;LPG, oil/paraffin/kerosene, or candles&quot;, 1, 0)))
  #
  # ppi6: Does the household have a non-electric or electric clothes iron?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Yes&quot;, 3, 0)
  #
  # ppi7: Does the household have a clock (wall, wrist, or pocket)?
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;Yes&quot;, 4, 0)
  #
  # ppi8: Does the household have a radio, stereo system, or cassette player?
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;Stereo system or cassette player (regardless of radio)&quot;, 7,
		  ifelse(surveyData$ppi8 == &quot;Radio only&quot;, 5, 0))
  #
  # ppi9: Does the household have a bicycle, motorcycle, or car?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;No&quot;, 0,
            ifelse(surveyData$ppi9 == &quot;Bicycle only&quot;, 5, 15))
  #
  # ppi10: How many beds does the household have (single, double, 
  #        beds, or for children)?
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;None&quot;, 0,
             ifelse(surveyData$ppi10 == &quot;One&quot;, 2, 5))
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: lookup table
  #
  #ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableMOZ.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrixMOZ[ppiMatrixMOZ[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }

</command>
											<property title="Mozambique" shape="TRANSFORM"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<node id="169" date="1510899093930" uid="349f6eb67ef2e883" x="40" y="10">
											<command>
################################################################################
#
# Progress out of Poverty Index (PPI) - Bangladesh
#
################################################################################
#
# Check if country is Bangladesh
#
if(unique(surveyData$country) == &quot;Bangladesh&quot;)
  {
  #
  # ppi1: Number of household members 12-years old or younger 
  #
  ppi1 &lt;- ifelse(surveyData$ppi1 == &quot;None&quot;, 32,
  	       ifelse(surveyData$ppi1 == &quot;One&quot;, 16,
		    ifelse(surveyData$ppi1 == &quot;Two&quot;, 10, 0)))
  #
  # ppi2: Do household members 6-12 years old attend school?
  #
  ppi2 &lt;- ifelse(surveyData$ppi2 == &quot;Yes&quot;, 6, 0)
  #
  # ppi3: In past year, any household member do paid work?
  #
  ppi3 &lt;- ifelse(surveyData$ppi3 == &quot;No&quot;, 8, 0)
  #
  # ppi4: Number of rooms used by household
  #
  ppi4 &lt;- ifelse(surveyData$ppi4 == &quot;Three or more&quot;, 5,
	       ifelse(surveyData$ppi4 == &quot;Two&quot;, 3, 0))
  #
  # ppi5: Main construction material of the walls of the main room
  #
  ppi5 &lt;- ifelse(surveyData$ppi5 == &quot;Brick/cement&quot;, 9,
	       ifelse(surveyData$ppi5 == &quot;Mud brick, or C.I. sheet/wood&quot;, 2, 0))
  #
  # ppi6: Does the household own television?
  #
  ppi6 &lt;- ifelse(surveyData$ppi6 == &quot;Yes&quot;, 7, 0)
  #
  # ppi7: Number of fans the household owns
  #
  ppi7 &lt;- ifelse(surveyData$ppi7 == &quot;Two or more&quot;, 7,
       	  ifelse(surveyData$ppi7 == &quot;One&quot;, 4, 0))
  #
  # ppi8: Number of mobile phones the household owns
  #
  ppi8 &lt;- ifelse(surveyData$ppi8 == &quot;Two or more&quot;, 15,
  	       ifelse(surveyData$ppi8 == &quot;One&quot;, 8, 0))
  #
  # ppi9: Does household own bicycles, motorcycles/scooters, cars?
  #
  ppi9 &lt;- ifelse(surveyData$ppi9 == &quot;Yes&quot;, 4, 0)
  #
  # ppi10: Does the household own/rent/sharecrop/mortgage in or out 51 or more
  #        decimals of cultivable agricultural land
  #
  ppi10 &lt;- ifelse(surveyData$ppi10 == &quot;Yes&quot;, 7, 0)
  #
  # ppi: total score
  #
  ppi &lt;- ppi1 + ppi2 + ppi3 + ppi4 + ppi5 + ppi6 + ppi7 + ppi8 + ppi9 + ppi10
  #
  # Probability of being below poverty line: load lookup table
  #
  #ppiMatrix &lt;- read.csv(file = &quot;data/ppiTableBGD.csv&quot;, header = TRUE, sep = &quot;,&quot;)
  #
  # Create empty vector container for poverty probabilities
  #
  pPoverty &lt;- NULL
  #
  # Cycle through each row of data
  #
  for(i in 1:nrow(surveyData))
    {
    #
    # Populate poverty probabilities vector
    #
    pPoverty &lt;- data.frame(rbind(pPoverty, ppiMatrixBGD[ppiMatrixBGD[&quot;score&quot;] == ppi[i], 2:10]))
    }
  }

</command>
											<property title="Bangladesh" shape="TRANSFORM"/>
											<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
										</node>
										<edge from="167" to="164"/>
										<edge from="166" to="161"/>
										<edge from="169" to="165"/>
										<edge from="162" to="169"/>
										<edge from="168" to="163"/>
										<edge from="161" to="167"/>
										<edge from="165" to="168"/>
										<edge from="163" to="166"/>
									</graph>
								</subflow>
							</option>
						</node>
						<edge from="155" to="151"/>
						<edge from="150" to="156"/>
						<edge from="159" to="157"/>
						<edge from="160" to="150"/>
						<edge from="158" to="159"/>
						<edge from="151" to="153"/>
						<edge from="149" to="158"/>
						<edge from="156" to="154"/>
						<edge from="154" to="149"/>
						<edge from="152" to="160"/>
						<edge from="153" to="152"/>
					</graph>
				</subflow>
			</option>
		</node>
		<node id="170" date="1510899093933" uid="6bc98f1c6e188af1" x="-190" y="320">
			<command>
################################################################################
#
#  Select and read survey data: Accepts CSV data files
#
################################################################################
#
# Prompt user to supply survey data
#
tkmessageBox(title = &quot;Load data&quot;,
             message = &quot;Select survey data&quot;, 
	        icon = &quot;info&quot;, 
	        type = &quot;ok&quot;)
#
# Cycle through survey data selection prompts
#
repeat
  {
  #
  # Cycle through survey data selection prompts when no file is selected
  #
  repeat
    {
    #
    # Select survey data file
    #
    fileName &lt;- tclvalue(tkgetOpenFile())
    #
    # Determine if a survey data file has been selected
    #	
    if(!nchar(fileName)) 
      {
      #
      # Prompt user that no file has been selected
      #
      error1 &lt;- tkmessageBox(title = &quot;Error&quot;,
				         message = &quot;No file was selected! Please try again.&quot;,
				         icon = &quot;error&quot;,
				         type = &quot;retrycancel&quot;)
      }
    #
    # Break repeat once any file has been selected
    #	
    if(nchar(fileName) &gt; 0) break
    #
    # Break repeat if user cancels option to select file
    #
    if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
    } 
  #
  # Break repeat if user cancels option to select file
  #
  if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  #
  # Try to read survey data based on filename provided by user
  #	
  surveyDataX &lt;- try(expr = read.csv(file = fileName, header = TRUE, sep = &quot;,&quot;), 
		           silent = TRUE)
  #
  # Check if survey data file provided is in correct format (CSV file)
  #
  if(exists(&quot;surveyDataX&quot;) &amp;&amp; class(surveyDataX) == &quot;try-error&quot;)
    {
    #
    # Prompt user that file format is incorrect
    #
    error2 &lt;- tkmessageBox(title = &quot;Error&quot;,
			            message = paste(&quot;Problem reading file &apos;&quot;, basename(fileName), &quot;&apos;. Please try again&quot;, sep = &quot;,&quot;),
			            icon = &quot;error&quot;,
			            type = &quot;retrycancel&quot;)
    }
  #
  # Break repeat once selected survey data is in correct format
  #
  if(exists(&quot;surveyDataX&quot;) &amp;&amp; class(surveyDataX) != &quot;try-error&quot;) break
  #
  # Break repeat if user cancels option to retry providing a new file
  #
  if(exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;) break
  }
#
# Determine if user cancels option to select file or cancels option to retry providing a new file
#
if((exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) | (exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;))
  {
  #
  # Prompt user that no file has been loaded
  #
  tkmessageBox(title = &quot;Warning&quot;,
		     message = &quot;You have not loaded any data file&quot;,
		     icon = &quot;warning&quot;,
		     type = &quot;ok&quot;)
  }
#
# Determine user has successfully selected and loaded an appropriate data file
#
if(exists(&quot;surveyDataX&quot;) &amp;&amp; class(surveyDataX) != &quot;try-error&quot;)
  {
  #
  # Prompt use of the filename of the survey data file selected
  #
  tkmessageBox(title = &quot;Success!&quot;,
     		message = paste(&quot;You have loaded the data file named &apos;&quot;, basename(fileName), &quot;&apos;.&quot;, sep = &quot;&quot;),
		     icon = &quot;info&quot;,
		     type = &quot;ok&quot;)
  }
#
# Clean-up filename
#
rm(fileName)
#
# Clean-up error1 if present
#
if(exists(&quot;error1&quot;))
  {
  rm(error1)
  }
#
# Clean-up error2 if present
#
if(exists(&quot;error2&quot;))
  {
  rm(error2)
  }


################################################################################
#
# Function to produce response based on selection
#
################################################################################
#
# 
#
onOK &lt;- function()
  {
  #
  # Extract name of country selected
  #
  cValue &lt;- as.character(tclvalue(choice.value))
  #
  # Close dialog box for country choices
  #
  tkdestroy(choice)
  #
  # Remind user of value chosen
  #
  tkmessageBox(title = &quot;Water Quality Data&quot;,
		     message = ifelse(cValue == &quot;Yes&quot;, &quot;Water quality data is available&quot;, &quot;Water quality data is not available&quot;),
		     icon = &quot;info&quot;,
		     type = &quot;ok&quot;)
  #
  # Return result for cValue
  #
  return(cValue)
  }


################################################################################
#
# Select whether water quality data is available
#
################################################################################
#
# Vector of choices
#
availability &lt;- c(&quot;Yes&quot;, &quot;No&quot;)
#
# Open dialog box
#
choice &lt;- tktoplevel()
#
# Label thh dialog box
#
tkwm.title(choice, &quot;Water Data Availability&quot;)
#
# Cycle through countries
#
for(i in 1:length(availability))
  {
  #
  # Add buttons in dialog box for each country choice
  # 	
  assign(x = paste(&quot;choice$env$choice&quot;, i, sep = &quot;&quot;),
	    value = tk2radiobutton(choice))
  }
#
# Select which radio button is selected by default
#
choice.value &lt;- tclVar(availability[1])
#
# Cycle through countries
#
for(i in 1:length(availability))
  {
  #
  # Configure radio buttons
  #
  tkconfigure(widget = get(paste(&quot;choice$env$choice&quot;, i, sep = &quot;&quot;)),
		    variable = choice.value,
		    value = availability[i])
  }
#
# Add a question prompt for country selection
#
tkgrid(tk2label(parent = choice, text = &quot;Is water quality data available?&quot;),
	           columnspan = 2, padx = 10, pady = c(15, 5))
#
# Cycle through countries
#
for(i in 1:length(availability))
  {
  #
  # Position choices on dialog box
  #    
  tkgrid(tk2label(parent = choice, text = availability[i]),
	    get(paste(&quot;choice$env$choice&quot;, i, sep = &quot;&quot;)),
	    padx = 10, pady = c(0, i + 5))
  }
#
# Create &apos;OK&apos; button
#  
choice$env$butOK &lt;- tk2button(choice, text = &quot;OK&quot;, width = -6, command = onOK)
#
# Define size parameters for dialog box
#
tkgrid(choice$env$butOK, columnspan = 2, padx = 10, pady = c(5, 15))
#
# Focus to the choice dialog box
#
tkfocus(choice)
#
#
#
tkwait.window(choice)



################################################################################
#
#  Select and read water quality data if data is available: Accepts CSV data files
#
################################################################################

if(as.character(tclvalue(choice.value)) == &quot;Yes&quot;)
  {
  #
  # Prompt user to supply survey data
  #
  tkmessageBox(title = &quot;Load data&quot;,
               message = &quot;Select water quality data&quot;, 
	          icon = &quot;info&quot;, 
	          type = &quot;ok&quot;)
  #
  # Cycle through survey data selection prompts
  #
  repeat
    {
    #
    # Cycle through survey data selection prompts when no file is selected
    #
    repeat
      {
      #
      # Select survey data file
      #
      fileName &lt;- tclvalue(tkgetOpenFile())
      #
      # Determine if a survey data file has been selected
      #	
      if(!nchar(fileName)) 
        {
        #
        # Prompt user that no file has been selected
        #
        error1 &lt;- tkmessageBox(title = &quot;Error&quot;,
				           message = &quot;No file was selected! Please try again.&quot;,
				           icon = &quot;error&quot;,
				           type = &quot;retrycancel&quot;)
        }
      #
      # Break repeat once any file has been selected
      #	
      if(nchar(fileName) &gt; 0) break
      #
      # Break repeat if user cancels option to select file
      #
      if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
      } 
    #
    # Break repeat if user cancels option to select file
    #
    if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
    #
    # Try to read survey data based on filename provided by user
    #	
    waterQualityDF &lt;- try(expr = read.csv(file = fileName, header = TRUE, sep = &quot;,&quot;), 
	    	                silent = TRUE)
    #
    # Check if survey data file provided is in correct format (CSV file)
    #
    if(exists(&quot;waterQualityDF&quot;) &amp;&amp; class(waterQualityDF) == &quot;try-error&quot;)
      {
      #
      # Prompt user that file format is incorrect
      #
      error2 &lt;- tkmessageBox(title = &quot;Error&quot;,
			              message = paste(&quot;Problem reading file &apos;&quot;, basename(fileName), &quot;&apos;. Please try again&quot;, sep = &quot;,&quot;),
			              icon = &quot;error&quot;,
			              type = &quot;retrycancel&quot;)
      }
    #
    # Break repeat once selected survey data is in correct format
    #
    if(exists(&quot;waterQualityDF&quot;) &amp;&amp; class(waterQualityDF) != &quot;try-error&quot;) break
    #
    # Break repeat if user cancels option to retry providing a new file
    #
    if(exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;) break
    }
  #
  # Determine if user cancels option to select file or cancels option to retry providing a new file
  #
  if((exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) | (exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;))
    {
    #
    # Prompt user that no file has been loaded
    #
    tkmessageBox(title = &quot;Warning&quot;,
		       message = &quot;You have not loaded any data file&quot;,
		       icon = &quot;warning&quot;,
		       type = &quot;ok&quot;)
    }
  #
  # Determine user has successfully selected and loaded an appropriate data file
  #
  if(exists(&quot;waterQualityDF&quot;) &amp;&amp; class(waterQualityDF) != &quot;try-error&quot;)
    {
    #
    # Prompt use of the filename of the survey data file selected
    #
    tkmessageBox(title = &quot;Success!&quot;,
     		  message = paste(&quot;You have loaded the data file named &apos;&quot;, basename(fileName), &quot;&apos;.&quot;, sep = &quot;&quot;),
		       icon = &quot;info&quot;,
		       type = &quot;ok&quot;)
    }
  #
  # Clean-up filename 
  #
  rm(fileName)
  #
  # Clean-up error1 if present
  #
  if(exists(&quot;error1&quot;))
    {
    rm(error1)
    }
  #
  # Clean-up error2 if present
  #
  if(exists(&quot;error2&quot;))
    {
    rm(error2)
    }
  }
#
# Clean-up
#
rm(choice, choice.value, i, availability)

################################################################################
#
# Function to produce response based on selection
#
################################################################################
#
# 
#
onOK &lt;- function()
  {
  #
  # Extract name of country selected
  #
  cValue &lt;- as.character(tclvalue(choice.value))
  #
  # Close dialog box for country choices
  #
  tkdestroy(choice)
  #
  # Remind user of value chosen
  #
  tkmessageBox(title = &quot;Excreta disposal after emptying&quot;,
		     message = ifelse(cValue == &quot;Yes&quot;, &quot;Excreate disposal after empyting data is available&quot;, &quot;Excreate disposal after empyting data is not available&quot;),
		     icon = &quot;info&quot;,
		     type = &quot;ok&quot;)
  #
  # Return result for cValue
  #
  return(cValue)
  }


################################################################################
#
# Select whether excreta disposal after emptying data is available
#
################################################################################
#
# Vector of choices
#
availability &lt;- c(&quot;Yes&quot;, &quot;No&quot;)
#
# Open dialog box
#
choice &lt;- tktoplevel()
#
# Label thh dialog box
#
tkwm.title(choice, &quot;Excreta Disposal after Emptying Data Availability&quot;)
#
# Cycle through countries
#
for(i in 1:length(availability))
  {
  #
  # Add buttons in dialog box for each country choice
  # 	
  assign(x = paste(&quot;choice$env$choice&quot;, i, sep = &quot;&quot;),
	    value = tk2radiobutton(choice))
  }
#
# Select which radio button is selected by default
#
choice.value &lt;- tclVar(availability[1])
#
# Cycle through countries
#
for(i in 1:length(availability))
  {
  #
  # Configure radio buttons
  #
  tkconfigure(widget = get(paste(&quot;choice$env$choice&quot;, i, sep = &quot;&quot;)),
		    variable = choice.value,
		    value = availability[i])
  }
#
# Add a question prompt for country selection
#
tkgrid(tk2label(parent = choice, text = &quot;Is excreta disposal after emptying data available?&quot;),
	           columnspan = 2, padx = 10, pady = c(15, 5))
#
# Cycle through countries
#
for(i in 1:length(availability))
  {
  #
  # Position choices on dialog box
  #    
  tkgrid(tk2label(parent = choice, text = availability[i]),
	    get(paste(&quot;choice$env$choice&quot;, i, sep = &quot;&quot;)),
	    padx = 10, pady = c(0, i + 5))
  }
#
# Create &apos;OK&apos; button
#  
choice$env$butOK &lt;- tk2button(choice, text = &quot;OK&quot;, width = -6, command = onOK)
#
# Define size parameters for dialog box
#
tkgrid(choice$env$butOK, columnspan = 2, padx = 10, pady = c(5, 15))
#
# Focus to the choice dialog box
#
tkfocus(choice)
#
#
#
tkwait.window(choice)



################################################################################
#
#  Select and read excreta disposal data if data is available: Accepts CSV data files
#
################################################################################

if(as.character(tclvalue(choice.value)) == &quot;Yes&quot;)
  {
  #
  # Prompt user to supply survey data
  #
  tkmessageBox(title = &quot;Load data&quot;,
               message = &quot;Select excreta disposal data&quot;, 
	          icon = &quot;info&quot;, 
	          type = &quot;ok&quot;)
  #
  # Cycle through survey data selection prompts
  #
  repeat
    {
    #
    # Cycle through survey data selection prompts when no file is selected
    #
    repeat
      {
      #
      # Select survey data file
      #
      fileName &lt;- tclvalue(tkgetOpenFile())
      #
      # Determine if a survey data file has been selected
      #	
      if(!nchar(fileName)) 
        {
        #
        # Prompt user that no file has been selected
        #
        error1 &lt;- tkmessageBox(title = &quot;Error&quot;,
				           message = &quot;No file was selected! Please try again.&quot;,
				           icon = &quot;error&quot;,
				           type = &quot;retrycancel&quot;)
        }
      #
      # Break repeat once any file has been selected
      #	
      if(nchar(fileName) &gt; 0) break
      #
      # Break repeat if user cancels option to select file
      #
      if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
      } 
    #
    # Break repeat if user cancels option to select file
    #
    if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
    #
    # Try to read survey data based on filename provided by user
    #	
    excretaDisposalDF &lt;- try(expr = read.csv(file = fileName, header = TRUE, sep = &quot;,&quot;), 
	    	                silent = TRUE)
    #
    # Check if survey data file provided is in correct format (CSV file)
    #
    if(exists(&quot;excretaDisposalDF&quot;) &amp;&amp; class(waterQualityDF) == &quot;try-error&quot;)
      {
      #
      # Prompt user that file format is incorrect
      #
      error2 &lt;- tkmessageBox(title = &quot;Error&quot;,
			              message = paste(&quot;Problem reading file &apos;&quot;, basename(fileName), &quot;&apos;. Please try again&quot;, sep = &quot;,&quot;),
			              icon = &quot;error&quot;,
			              type = &quot;retrycancel&quot;)
      }
    #
    # Break repeat once selected survey data is in correct format
    #
    if(exists(&quot;excretaDisposalDF&quot;) &amp;&amp; class(excretaDisposalDF) != &quot;try-error&quot;) break
    #
    # Break repeat if user cancels option to retry providing a new file
    #
    if(exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;) break
    }
  #
  # Determine if user cancels option to select file or cancels option to retry providing a new file
  #
  if((exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) | (exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;))
    {
    #
    # Prompt user that no file has been loaded
    #
    tkmessageBox(title = &quot;Warning&quot;,
		       message = &quot;You have not loaded any data file&quot;,
		       icon = &quot;warning&quot;,
		       type = &quot;ok&quot;)
    }
  #
  # Determine user has successfully selected and loaded an appropriate data file
  #
  if(exists(&quot;excretaDisposalDF&quot;) &amp;&amp; class(excretaDisposalDF) != &quot;try-error&quot;)
    {
    #
    # Prompt use of the filename of the survey data file selected
    #
    tkmessageBox(title = &quot;Success!&quot;,
     		  message = paste(&quot;You have loaded the data file named &apos;&quot;, basename(fileName), &quot;&apos;.&quot;, sep = &quot;&quot;),
		       icon = &quot;info&quot;,
		       type = &quot;ok&quot;)
    }
  #
  # Clean-up filename 
  #
  rm(fileName)
  #
  # Clean-up error1 if present
  #
  if(exists(&quot;error1&quot;))
    {
    rm(error1)
    }
  #
  # Clean-up error2 if present
  #
  if(exists(&quot;error2&quot;))
    {
    rm(error2)
    }
  }
#
# Clean-up
#
rm(choice, choice.value, i, availability)


################################################################################
#
# Function to produce response based on selection
#
################################################################################
#
# 
#
onOK &lt;- function()
  {
  #
  # Extract name of country selected
  #
  cValue &lt;- as.character(tclvalue(choice.value))
  #
  # Close dialog box for country choices
  #
  tkdestroy(choice)
  #
  # Remind user of value chosen
  #
  tkmessageBox(title = &quot;Handwashing facility at home&quot;,
		     message = ifelse(cValue == &quot;Yes&quot;, &quot;Handwashing facility at home data is available&quot;, &quot;Handwashing facility at home data is not available&quot;),
		     icon = &quot;info&quot;,
		     type = &quot;ok&quot;)
  #
  # Return result for cValue
  #
  return(cValue)
  }


################################################################################
#
# Select whether excreta disposal after emptying data is available
#
################################################################################
#
# Vector of choices
#
availability &lt;- c(&quot;Yes&quot;, &quot;No&quot;)
#
# Open dialog box
#
choice &lt;- tktoplevel()
#
# Label thh dialog box
#
tkwm.title(choice, &quot;Handwashing Facility at Home Data Availability&quot;)
#
# Cycle through countries
#
for(i in 1:length(availability))
  {
  #
  # Add buttons in dialog box for each country choice
  # 	
  assign(x = paste(&quot;choice$env$choice&quot;, i, sep = &quot;&quot;),
	    value = tk2radiobutton(choice))
  }
#
# Select which radio button is selected by default
#
choice.value &lt;- tclVar(availability[1])
#
# Cycle through countries
#
for(i in 1:length(availability))
  {
  #
  # Configure radio buttons
  #
  tkconfigure(widget = get(paste(&quot;choice$env$choice&quot;, i, sep = &quot;&quot;)),
		    variable = choice.value,
		    value = availability[i])
  }
#
# Add a question prompt for country selection
#
tkgrid(tk2label(parent = choice, text = &quot;Is handwashing facility at home data available?&quot;),
	           columnspan = 2, padx = 10, pady = c(15, 5))
#
# Cycle through countries
#
for(i in 1:length(availability))
  {
  #
  # Position choices on dialog box
  #    
  tkgrid(tk2label(parent = choice, text = availability[i]),
	    get(paste(&quot;choice$env$choice&quot;, i, sep = &quot;&quot;)),
	    padx = 10, pady = c(0, i + 5))
  }
#
# Create &apos;OK&apos; button
#  
choice$env$butOK &lt;- tk2button(choice, text = &quot;OK&quot;, width = -6, command = onOK)
#
# Define size parameters for dialog box
#
tkgrid(choice$env$butOK, columnspan = 2, padx = 10, pady = c(5, 15))
#
# Focus to the choice dialog box
#
tkfocus(choice)
#
#
#
tkwait.window(choice)



################################################################################
#
#  Select and read handwashing facility at home data if data is available: Accepts CSV data files
#
################################################################################

if(as.character(tclvalue(choice.value)) == &quot;Yes&quot;)
  {
  #
  # Prompt user to supply survey data
  #
  tkmessageBox(title = &quot;Load data&quot;,
               message = &quot;Select handwashing facility at home data&quot;, 
	          icon = &quot;info&quot;, 
	          type = &quot;ok&quot;)
  #
  # Cycle through survey data selection prompts
  #
  repeat
    {
    #
    # Cycle through survey data selection prompts when no file is selected
    #
    repeat
      {
      #
      # Select survey data file
      #
      fileName &lt;- tclvalue(tkgetOpenFile())
      #
      # Determine if a survey data file has been selected
      #	
      if(!nchar(fileName)) 
        {
        #
        # Prompt user that no file has been selected
        #
        error1 &lt;- tkmessageBox(title = &quot;Error&quot;,
				           message = &quot;No file was selected! Please try again.&quot;,
				           icon = &quot;error&quot;,
				           type = &quot;retrycancel&quot;)
        }
      #
      # Break repeat once any file has been selected
      #	
      if(nchar(fileName) &gt; 0) break
      #
      # Break repeat if user cancels option to select file
      #
      if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
      } 
    #
    # Break repeat if user cancels option to select file
    #
    if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
    #
    # Try to read survey data based on filename provided by user
    #	
    handwdashingFacilityDF &lt;- try(expr = read.csv(file = fileName, header = TRUE, sep = &quot;,&quot;), 
	    	                        silent = TRUE)
    #
    # Check if survey data file provided is in correct format (CSV file)
    #
    if(exists(&quot;handwdashingFacilityDF&quot;) &amp;&amp; class(handwdashingFacilityDF) == &quot;try-error&quot;)
      {
      #
      # Prompt user that file format is incorrect
      #
      error2 &lt;- tkmessageBox(title = &quot;Error&quot;,
			              message = paste(&quot;Problem reading file &apos;&quot;, basename(fileName), &quot;&apos;. Please try again&quot;, sep = &quot;,&quot;),
			              icon = &quot;error&quot;,
			              type = &quot;retrycancel&quot;)
      }
    #
    # Break repeat once selected survey data is in correct format
    #
    if(exists(&quot;handwdashingFacilityDF&quot;) &amp;&amp; class(handwdashingFacilityDF) != &quot;try-error&quot;) break
    #
    # Break repeat if user cancels option to retry providing a new file
    #
    if(exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;) break
    }
  #
  # Determine if user cancels option to select file or cancels option to retry providing a new file
  #
  if((exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) | (exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;))
    {
    #
    # Prompt user that no file has been loaded
    #
    tkmessageBox(title = &quot;Warning&quot;,
		       message = &quot;You have not loaded any data file&quot;,
		       icon = &quot;warning&quot;,
		       type = &quot;ok&quot;)
    }
  #
  # Determine user has successfully selected and loaded an appropriate data file
  #
  if(exists(&quot;handwdashingFacilityDF&quot;) &amp;&amp; class(handwdashingFacilityDF) != &quot;try-error&quot;)
    {
    #
    # Prompt use of the filename of the survey data file selected
    #
    tkmessageBox(title = &quot;Success!&quot;,
     		  message = paste(&quot;You have loaded the data file named &apos;&quot;, basename(fileName), &quot;&apos;.&quot;, sep = &quot;&quot;),
		       icon = &quot;info&quot;,
		       type = &quot;ok&quot;)
    }
  #
  # Clean-up filename 
  #
  rm(fileName)
  #
  # Clean-up error1 if present
  #
  if(exists(&quot;error1&quot;))
    {
    rm(error1)
    }
  #
  # Clean-up error2 if present
  #
  if(exists(&quot;error2&quot;))
    {
    rm(error2)
    }
  }
#
# Clean-up
#
rm(choice, choice.value, i, availability)

</command>
			<property title="Read data" shape="INOUT"/>
			<option type="com.ef_prime.rflow.node.base.SubflowNodeModel">
				<subflow>
					<graph version="0.8" width="1444" height="513" locationtype="a" offsetx="140" offsety="131">
						<node id="171" date="1510899093933" uid="2394b66895d2c0c8" x="310" y="170">
							<command>
################################################################################
#
#  Select and read handwashing facility at home data if data is available: Accepts CSV data files
#
################################################################################

if(as.character(tclvalue(choice.value)) == &quot;Yes&quot;)
  {
  #
  # Prompt user to supply survey data
  #
  tkmessageBox(title = &quot;Load data&quot;,
               message = &quot;Select handwashing facility at home data&quot;, 
	          icon = &quot;info&quot;, 
	          type = &quot;ok&quot;)
  #
  # Cycle through survey data selection prompts
  #
  repeat
    {
    #
    # Cycle through survey data selection prompts when no file is selected
    #
    repeat
      {
      #
      # Select survey data file
      #
      fileName &lt;- tclvalue(tkgetOpenFile())
      #
      # Determine if a survey data file has been selected
      #	
      if(!nchar(fileName)) 
        {
        #
        # Prompt user that no file has been selected
        #
        error1 &lt;- tkmessageBox(title = &quot;Error&quot;,
				           message = &quot;No file was selected! Please try again.&quot;,
				           icon = &quot;error&quot;,
				           type = &quot;retrycancel&quot;)
        }
      #
      # Break repeat once any file has been selected
      #	
      if(nchar(fileName) &gt; 0) break
      #
      # Break repeat if user cancels option to select file
      #
      if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
      } 
    #
    # Break repeat if user cancels option to select file
    #
    if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
    #
    # Try to read survey data based on filename provided by user
    #	
    handwdashingFacilityDF &lt;- try(expr = read.csv(file = fileName, header = TRUE, sep = &quot;,&quot;), 
	    	                        silent = TRUE)
    #
    # Check if survey data file provided is in correct format (CSV file)
    #
    if(exists(&quot;handwdashingFacilityDF&quot;) &amp;&amp; class(handwdashingFacilityDF) == &quot;try-error&quot;)
      {
      #
      # Prompt user that file format is incorrect
      #
      error2 &lt;- tkmessageBox(title = &quot;Error&quot;,
			              message = paste(&quot;Problem reading file &apos;&quot;, basename(fileName), &quot;&apos;. Please try again&quot;, sep = &quot;,&quot;),
			              icon = &quot;error&quot;,
			              type = &quot;retrycancel&quot;)
      }
    #
    # Break repeat once selected survey data is in correct format
    #
    if(exists(&quot;handwdashingFacilityDF&quot;) &amp;&amp; class(handwdashingFacilityDF) != &quot;try-error&quot;) break
    #
    # Break repeat if user cancels option to retry providing a new file
    #
    if(exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;) break
    }
  #
  # Determine if user cancels option to select file or cancels option to retry providing a new file
  #
  if((exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) | (exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;))
    {
    #
    # Prompt user that no file has been loaded
    #
    tkmessageBox(title = &quot;Warning&quot;,
		       message = &quot;You have not loaded any data file&quot;,
		       icon = &quot;warning&quot;,
		       type = &quot;ok&quot;)
    }
  #
  # Determine user has successfully selected and loaded an appropriate data file
  #
  if(exists(&quot;handwdashingFacilityDF&quot;) &amp;&amp; class(handwdashingFacilityDF) != &quot;try-error&quot;)
    {
    #
    # Prompt use of the filename of the survey data file selected
    #
    tkmessageBox(title = &quot;Success!&quot;,
     		  message = paste(&quot;You have loaded the data file named &apos;&quot;, basename(fileName), &quot;&apos;.&quot;, sep = &quot;&quot;),
		       icon = &quot;info&quot;,
		       type = &quot;ok&quot;)
    }
  #
  # Clean-up filename 
  #
  rm(fileName)
  #
  # Clean-up error1 if present
  #
  if(exists(&quot;error1&quot;))
    {
    rm(error1)
    }
  #
  # Clean-up error2 if present
  #
  if(exists(&quot;error2&quot;))
    {
    rm(error2)
    }
  }
#
# Clean-up
#
rm(choice, choice.value, i, availability)

</command>
							<property title="Read handwashing facility at home data" shape="INOUT"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="172" date="1510899093932" uid="f03130faff4cd0d7" x="50" y="10">
							<command>
################################################################################
#
#  Select and read survey data: Accepts CSV data files
#
################################################################################
#
# Prompt user to supply survey data
#
tkmessageBox(title = &quot;Load data&quot;,
             message = &quot;Select survey data&quot;, 
	        icon = &quot;info&quot;, 
	        type = &quot;ok&quot;)
#
# Cycle through survey data selection prompts
#
repeat
  {
  #
  # Cycle through survey data selection prompts when no file is selected
  #
  repeat
    {
    #
    # Select survey data file
    #
    fileName &lt;- tclvalue(tkgetOpenFile())
    #
    # Determine if a survey data file has been selected
    #	
    if(!nchar(fileName)) 
      {
      #
      # Prompt user that no file has been selected
      #
      error1 &lt;- tkmessageBox(title = &quot;Error&quot;,
				         message = &quot;No file was selected! Please try again.&quot;,
				         icon = &quot;error&quot;,
				         type = &quot;retrycancel&quot;)
      }
    #
    # Break repeat once any file has been selected
    #	
    if(nchar(fileName) &gt; 0) break
    #
    # Break repeat if user cancels option to select file
    #
    if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
    } 
  #
  # Break repeat if user cancels option to select file
  #
  if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
  #
  # Try to read survey data based on filename provided by user
  #	
  surveyDataX &lt;- try(expr = read.csv(file = fileName, header = TRUE, sep = &quot;,&quot;), 
		           silent = TRUE)
  #
  # Check if survey data file provided is in correct format (CSV file)
  #
  if(exists(&quot;surveyDataX&quot;) &amp;&amp; class(surveyDataX) == &quot;try-error&quot;)
    {
    #
    # Prompt user that file format is incorrect
    #
    error2 &lt;- tkmessageBox(title = &quot;Error&quot;,
			            message = paste(&quot;Problem reading file &apos;&quot;, basename(fileName), &quot;&apos;. Please try again&quot;, sep = &quot;,&quot;),
			            icon = &quot;error&quot;,
			            type = &quot;retrycancel&quot;)
    }
  #
  # Break repeat once selected survey data is in correct format
  #
  if(exists(&quot;surveyDataX&quot;) &amp;&amp; class(surveyDataX) != &quot;try-error&quot;) break
  #
  # Break repeat if user cancels option to retry providing a new file
  #
  if(exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;) break
  }
#
# Determine if user cancels option to select file or cancels option to retry providing a new file
#
if((exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) | (exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;))
  {
  #
  # Prompt user that no file has been loaded
  #
  tkmessageBox(title = &quot;Warning&quot;,
		     message = &quot;You have not loaded any data file&quot;,
		     icon = &quot;warning&quot;,
		     type = &quot;ok&quot;)
  }
#
# Determine user has successfully selected and loaded an appropriate data file
#
if(exists(&quot;surveyDataX&quot;) &amp;&amp; class(surveyDataX) != &quot;try-error&quot;)
  {
  #
  # Prompt use of the filename of the survey data file selected
  #
  tkmessageBox(title = &quot;Success!&quot;,
     		message = paste(&quot;You have loaded the data file named &apos;&quot;, basename(fileName), &quot;&apos;.&quot;, sep = &quot;&quot;),
		     icon = &quot;info&quot;,
		     type = &quot;ok&quot;)
  }
#
# Clean-up filename
#
rm(fileName)
#
# Clean-up error1 if present
#
if(exists(&quot;error1&quot;))
  {
  rm(error1)
  }
#
# Clean-up error2 if present
#
if(exists(&quot;error2&quot;))
  {
  rm(error2)
  }

</command>
							<property title="Read survey data" shape="INOUT"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="173" date="1510899093933" uid="6976621beb8da3b9" x="400" y="170">
							<command></command>
							<property/>
							<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
								<entry key="io">out</entry>
							</option>
						</node>
						<node id="174" date="1510899093933" uid="1f2cba97d1b1cc5" x="310" y="90">
							<command>################################################################################
#
# Function to produce response based on selection
#
################################################################################
#
# 
#
onOK &lt;- function()
  {
  #
  # Extract name of country selected
  #
  cValue &lt;- as.character(tclvalue(choice.value))
  #
  # Close dialog box for country choices
  #
  tkdestroy(choice)
  #
  # Remind user of value chosen
  #
  tkmessageBox(title = &quot;Handwashing facility at home&quot;,
		     message = ifelse(cValue == &quot;Yes&quot;, &quot;Handwashing facility at home data is available&quot;, &quot;Handwashing facility at home data is not available&quot;),
		     icon = &quot;info&quot;,
		     type = &quot;ok&quot;)
  #
  # Return result for cValue
  #
  return(cValue)
  }


################################################################################
#
# Select whether excreta disposal after emptying data is available
#
################################################################################
#
# Vector of choices
#
availability &lt;- c(&quot;Yes&quot;, &quot;No&quot;)
#
# Open dialog box
#
choice &lt;- tktoplevel()
#
# Label thh dialog box
#
tkwm.title(choice, &quot;Handwashing Facility at Home Data Availability&quot;)
#
# Cycle through countries
#
for(i in 1:length(availability))
  {
  #
  # Add buttons in dialog box for each country choice
  # 	
  assign(x = paste(&quot;choice$env$choice&quot;, i, sep = &quot;&quot;),
	    value = tk2radiobutton(choice))
  }
#
# Select which radio button is selected by default
#
choice.value &lt;- tclVar(availability[1])
#
# Cycle through countries
#
for(i in 1:length(availability))
  {
  #
  # Configure radio buttons
  #
  tkconfigure(widget = get(paste(&quot;choice$env$choice&quot;, i, sep = &quot;&quot;)),
		    variable = choice.value,
		    value = availability[i])
  }
#
# Add a question prompt for country selection
#
tkgrid(tk2label(parent = choice, text = &quot;Is handwashing facility at home data available?&quot;),
	           columnspan = 2, padx = 10, pady = c(15, 5))
#
# Cycle through countries
#
for(i in 1:length(availability))
  {
  #
  # Position choices on dialog box
  #    
  tkgrid(tk2label(parent = choice, text = availability[i]),
	    get(paste(&quot;choice$env$choice&quot;, i, sep = &quot;&quot;)),
	    padx = 10, pady = c(0, i + 5))
  }
#
# Create &apos;OK&apos; button
#  
choice$env$butOK &lt;- tk2button(choice, text = &quot;OK&quot;, width = -6, command = onOK)
#
# Define size parameters for dialog box
#
tkgrid(choice$env$butOK, columnspan = 2, padx = 10, pady = c(5, 15))
#
# Focus to the choice dialog box
#
tkfocus(choice)
#
#
#
tkwait.window(choice)

</command>
							<property title="Check home handwashing facility data" shape="STAR"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="175" date="1510899093933" uid="3f8a5448c3d30b61" x="-30" y="10">
							<command></command>
							<property/>
							<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
								<entry key="io">in</entry>
							</option>
						</node>
						<node id="176" date="1510899093933" uid="9a50e9039dfb1a26" x="50" y="170">
							<command>
################################################################################
#
#  Select and read water quality data if data is available: Accepts CSV data files
#
################################################################################

if(as.character(tclvalue(choice.value)) == &quot;Yes&quot;)
  {
  #
  # Prompt user to supply survey data
  #
  tkmessageBox(title = &quot;Load data&quot;,
               message = &quot;Select water quality data&quot;, 
	          icon = &quot;info&quot;, 
	          type = &quot;ok&quot;)
  #
  # Cycle through survey data selection prompts
  #
  repeat
    {
    #
    # Cycle through survey data selection prompts when no file is selected
    #
    repeat
      {
      #
      # Select survey data file
      #
      fileName &lt;- tclvalue(tkgetOpenFile())
      #
      # Determine if a survey data file has been selected
      #	
      if(!nchar(fileName)) 
        {
        #
        # Prompt user that no file has been selected
        #
        error1 &lt;- tkmessageBox(title = &quot;Error&quot;,
				           message = &quot;No file was selected! Please try again.&quot;,
				           icon = &quot;error&quot;,
				           type = &quot;retrycancel&quot;)
        }
      #
      # Break repeat once any file has been selected
      #	
      if(nchar(fileName) &gt; 0) break
      #
      # Break repeat if user cancels option to select file
      #
      if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
      } 
    #
    # Break repeat if user cancels option to select file
    #
    if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
    #
    # Try to read survey data based on filename provided by user
    #	
    waterQualityDF &lt;- try(expr = read.csv(file = fileName, header = TRUE, sep = &quot;,&quot;), 
	    	                silent = TRUE)
    #
    # Check if survey data file provided is in correct format (CSV file)
    #
    if(exists(&quot;waterQualityDF&quot;) &amp;&amp; class(waterQualityDF) == &quot;try-error&quot;)
      {
      #
      # Prompt user that file format is incorrect
      #
      error2 &lt;- tkmessageBox(title = &quot;Error&quot;,
			              message = paste(&quot;Problem reading file &apos;&quot;, basename(fileName), &quot;&apos;. Please try again&quot;, sep = &quot;,&quot;),
			              icon = &quot;error&quot;,
			              type = &quot;retrycancel&quot;)
      }
    #
    # Break repeat once selected survey data is in correct format
    #
    if(exists(&quot;waterQualityDF&quot;) &amp;&amp; class(waterQualityDF) != &quot;try-error&quot;) break
    #
    # Break repeat if user cancels option to retry providing a new file
    #
    if(exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;) break
    }
  #
  # Determine if user cancels option to select file or cancels option to retry providing a new file
  #
  if((exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) | (exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;))
    {
    #
    # Prompt user that no file has been loaded
    #
    tkmessageBox(title = &quot;Warning&quot;,
		       message = &quot;You have not loaded any data file&quot;,
		       icon = &quot;warning&quot;,
		       type = &quot;ok&quot;)
    }
  #
  # Determine user has successfully selected and loaded an appropriate data file
  #
  if(exists(&quot;waterQualityDF&quot;) &amp;&amp; class(waterQualityDF) != &quot;try-error&quot;)
    {
    #
    # Prompt use of the filename of the survey data file selected
    #
    tkmessageBox(title = &quot;Success!&quot;,
     		  message = paste(&quot;You have loaded the data file named &apos;&quot;, basename(fileName), &quot;&apos;.&quot;, sep = &quot;&quot;),
		       icon = &quot;info&quot;,
		       type = &quot;ok&quot;)
    }
  #
  # Clean-up filename 
  #
  rm(fileName)
  #
  # Clean-up error1 if present
  #
  if(exists(&quot;error1&quot;))
    {
    rm(error1)
    }
  #
  # Clean-up error2 if present
  #
  if(exists(&quot;error2&quot;))
    {
    rm(error2)
    }
  }
#
# Clean-up
#
rm(choice, choice.value, i, availability)</command>
							<property title="Read water quality data" shape="INOUT"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="177" date="1510899093933" uid="22585ef36310a830" x="180" y="170">
							<command>################################################################################
#
# Function to produce response based on selection
#
################################################################################
#
# 
#
onOK &lt;- function()
  {
  #
  # Extract name of country selected
  #
  cValue &lt;- as.character(tclvalue(choice.value))
  #
  # Close dialog box for country choices
  #
  tkdestroy(choice)
  #
  # Remind user of value chosen
  #
  tkmessageBox(title = &quot;Excreta disposal after emptying&quot;,
		     message = ifelse(cValue == &quot;Yes&quot;, &quot;Excreate disposal after empyting data is available&quot;, &quot;Excreate disposal after empyting data is not available&quot;),
		     icon = &quot;info&quot;,
		     type = &quot;ok&quot;)
  #
  # Return result for cValue
  #
  return(cValue)
  }


################################################################################
#
# Select whether excreta disposal after emptying data is available
#
################################################################################
#
# Vector of choices
#
availability &lt;- c(&quot;Yes&quot;, &quot;No&quot;)
#
# Open dialog box
#
choice &lt;- tktoplevel()
#
# Label thh dialog box
#
tkwm.title(choice, &quot;Excreta Disposal after Emptying Data Availability&quot;)
#
# Cycle through countries
#
for(i in 1:length(availability))
  {
  #
  # Add buttons in dialog box for each country choice
  # 	
  assign(x = paste(&quot;choice$env$choice&quot;, i, sep = &quot;&quot;),
	    value = tk2radiobutton(choice))
  }
#
# Select which radio button is selected by default
#
choice.value &lt;- tclVar(availability[1])
#
# Cycle through countries
#
for(i in 1:length(availability))
  {
  #
  # Configure radio buttons
  #
  tkconfigure(widget = get(paste(&quot;choice$env$choice&quot;, i, sep = &quot;&quot;)),
		    variable = choice.value,
		    value = availability[i])
  }
#
# Add a question prompt for country selection
#
tkgrid(tk2label(parent = choice, text = &quot;Is excreta disposal after emptying data available?&quot;),
	           columnspan = 2, padx = 10, pady = c(15, 5))
#
# Cycle through countries
#
for(i in 1:length(availability))
  {
  #
  # Position choices on dialog box
  #    
  tkgrid(tk2label(parent = choice, text = availability[i]),
	    get(paste(&quot;choice$env$choice&quot;, i, sep = &quot;&quot;)),
	    padx = 10, pady = c(0, i + 5))
  }
#
# Create &apos;OK&apos; button
#  
choice$env$butOK &lt;- tk2button(choice, text = &quot;OK&quot;, width = -6, command = onOK)
#
# Define size parameters for dialog box
#
tkgrid(choice$env$butOK, columnspan = 2, padx = 10, pady = c(5, 15))
#
# Focus to the choice dialog box
#
tkfocus(choice)
#
#
#
tkwait.window(choice)

</command>
							<property title="Check excreta disposal data" shape="STAR"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="178" date="1510899093933" uid="6e85b0e813bdf27" x="50" y="90">
							<command>################################################################################
#
# Function to produce response based on selection
#
################################################################################
#
# 
#
onOK &lt;- function()
  {
  #
  # Extract name of country selected
  #
  cValue &lt;- as.character(tclvalue(choice.value))
  #
  # Close dialog box for country choices
  #
  tkdestroy(choice)
  #
  # Remind user of value chosen
  #
  tkmessageBox(title = &quot;Water Quality Data&quot;,
		     message = ifelse(cValue == &quot;Yes&quot;, &quot;Water quality data is available&quot;, &quot;Water quality data is not available&quot;),
		     icon = &quot;info&quot;,
		     type = &quot;ok&quot;)
  #
  # Return result for cValue
  #
  return(cValue)
  }


################################################################################
#
# Select whether water quality data is available
#
################################################################################
#
# Vector of choices
#
availability &lt;- c(&quot;Yes&quot;, &quot;No&quot;)
#
# Open dialog box
#
choice &lt;- tktoplevel()
#
# Label thh dialog box
#
tkwm.title(choice, &quot;Water Data Availability&quot;)
#
# Cycle through countries
#
for(i in 1:length(availability))
  {
  #
  # Add buttons in dialog box for each country choice
  # 	
  assign(x = paste(&quot;choice$env$choice&quot;, i, sep = &quot;&quot;),
	    value = tk2radiobutton(choice))
  }
#
# Select which radio button is selected by default
#
choice.value &lt;- tclVar(availability[1])
#
# Cycle through countries
#
for(i in 1:length(availability))
  {
  #
  # Configure radio buttons
  #
  tkconfigure(widget = get(paste(&quot;choice$env$choice&quot;, i, sep = &quot;&quot;)),
		    variable = choice.value,
		    value = availability[i])
  }
#
# Add a question prompt for country selection
#
tkgrid(tk2label(parent = choice, text = &quot;Is water quality data available?&quot;),
	           columnspan = 2, padx = 10, pady = c(15, 5))
#
# Cycle through countries
#
for(i in 1:length(availability))
  {
  #
  # Position choices on dialog box
  #    
  tkgrid(tk2label(parent = choice, text = availability[i]),
	    get(paste(&quot;choice$env$choice&quot;, i, sep = &quot;&quot;)),
	    padx = 10, pady = c(0, i + 5))
  }
#
# Create &apos;OK&apos; button
#  
choice$env$butOK &lt;- tk2button(choice, text = &quot;OK&quot;, width = -6, command = onOK)
#
# Define size parameters for dialog box
#
tkgrid(choice$env$butOK, columnspan = 2, padx = 10, pady = c(5, 15))
#
# Focus to the choice dialog box
#
tkfocus(choice)
#
#
#
tkwait.window(choice)

</command>
							<property title="Check water quality data" shape="STAR"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="179" date="1510899093933" uid="3e442b7d3e350f92" x="180" y="90">
							<command>
################################################################################
#
#  Select and read excreta disposal data if data is available: Accepts CSV data files
#
################################################################################

if(as.character(tclvalue(choice.value)) == &quot;Yes&quot;)
  {
  #
  # Prompt user to supply survey data
  #
  tkmessageBox(title = &quot;Load data&quot;,
               message = &quot;Select excreta disposal data&quot;, 
	          icon = &quot;info&quot;, 
	          type = &quot;ok&quot;)
  #
  # Cycle through survey data selection prompts
  #
  repeat
    {
    #
    # Cycle through survey data selection prompts when no file is selected
    #
    repeat
      {
      #
      # Select survey data file
      #
      fileName &lt;- tclvalue(tkgetOpenFile())
      #
      # Determine if a survey data file has been selected
      #	
      if(!nchar(fileName)) 
        {
        #
        # Prompt user that no file has been selected
        #
        error1 &lt;- tkmessageBox(title = &quot;Error&quot;,
				           message = &quot;No file was selected! Please try again.&quot;,
				           icon = &quot;error&quot;,
				           type = &quot;retrycancel&quot;)
        }
      #
      # Break repeat once any file has been selected
      #	
      if(nchar(fileName) &gt; 0) break
      #
      # Break repeat if user cancels option to select file
      #
      if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
      } 
    #
    # Break repeat if user cancels option to select file
    #
    if(exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) break
    #
    # Try to read survey data based on filename provided by user
    #	
    excretaDisposalDF &lt;- try(expr = read.csv(file = fileName, header = TRUE, sep = &quot;,&quot;), 
	    	                silent = TRUE)
    #
    # Check if survey data file provided is in correct format (CSV file)
    #
    if(exists(&quot;excretaDisposalDF&quot;) &amp;&amp; class(waterQualityDF) == &quot;try-error&quot;)
      {
      #
      # Prompt user that file format is incorrect
      #
      error2 &lt;- tkmessageBox(title = &quot;Error&quot;,
			              message = paste(&quot;Problem reading file &apos;&quot;, basename(fileName), &quot;&apos;. Please try again&quot;, sep = &quot;,&quot;),
			              icon = &quot;error&quot;,
			              type = &quot;retrycancel&quot;)
      }
    #
    # Break repeat once selected survey data is in correct format
    #
    if(exists(&quot;excretaDisposalDF&quot;) &amp;&amp; class(excretaDisposalDF) != &quot;try-error&quot;) break
    #
    # Break repeat if user cancels option to retry providing a new file
    #
    if(exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;) break
    }
  #
  # Determine if user cancels option to select file or cancels option to retry providing a new file
  #
  if((exists(&quot;error1&quot;) &amp;&amp; tclvalue(error1) == &quot;cancel&quot;) | (exists(&quot;error2&quot;) &amp;&amp; tclvalue(error2) == &quot;cancel&quot;))
    {
    #
    # Prompt user that no file has been loaded
    #
    tkmessageBox(title = &quot;Warning&quot;,
		       message = &quot;You have not loaded any data file&quot;,
		       icon = &quot;warning&quot;,
		       type = &quot;ok&quot;)
    }
  #
  # Determine user has successfully selected and loaded an appropriate data file
  #
  if(exists(&quot;excretaDisposalDF&quot;) &amp;&amp; class(excretaDisposalDF) != &quot;try-error&quot;)
    {
    #
    # Prompt use of the filename of the survey data file selected
    #
    tkmessageBox(title = &quot;Success!&quot;,
     		  message = paste(&quot;You have loaded the data file named &apos;&quot;, basename(fileName), &quot;&apos;.&quot;, sep = &quot;&quot;),
		       icon = &quot;info&quot;,
		       type = &quot;ok&quot;)
    }
  #
  # Clean-up filename 
  #
  rm(fileName)
  #
  # Clean-up error1 if present
  #
  if(exists(&quot;error1&quot;))
    {
    rm(error1)
    }
  #
  # Clean-up error2 if present
  #
  if(exists(&quot;error2&quot;))
    {
    rm(error2)
    }
  }
#
# Clean-up
#
rm(choice, choice.value, i, availability)

</command>
							<property title="Read excreta disposal data" shape="INOUT"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<edge from="176" to="177"/>
						<edge from="174" to="171"/>
						<edge from="172" to="178"/>
						<edge from="175" to="172"/>
						<edge from="177" to="179"/>
						<edge from="178" to="176"/>
						<edge from="171" to="173"/>
						<edge from="179" to="174"/>
					</graph>
				</subflow>
			</option>
		</node>
		<node id="180" date="1510899093929" uid="aed9ea0e235a6b6b" x="-90" y="190">
			<command>
################################################################################
#                                                                              #
# STEP 1: Setup and Configure R                                                #
#                                                                              #
#    This step specifies R properties, libraries and dependencies required by  #
#    this analysis, bespoke functions written specifically for this dataset    #
#    and various utilities and specifications that will be called upon in the  #
#    latter sections of this workflow.                                         #
#                                                                              #
################################################################################</command>
			<property title="Run STEP 1" shape="STAR">
				<comment state="opened" x="60" y="-20">STEP 1: Setup and 
        Configure R      </comment>
			</property>
			<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
		</node>
		<node id="181" date="1510899093927" uid="bc67c59c29ca3331" x="-90" y="720">
			<command>
################################################################################
#                                                                              #
# Step 5a: Classify indicators                                                 #
#                                                                              #
#      This step performs the LQAS analysis on the indicator set using         #
#      the standards specified by the user in the previous step and across     # 
#      three stratifications namely:                                           #
#                                                                              #
#        a. survey area                                                        #
#        b. wealth quintile                                                    #
#        c. overall                                                            #
#                                                                              #
#      The output of this step produces three results table in comma-separated #
#      value (CSV) format which is saved in the &apos;outputTables&apos; folder in the   #
#      current working directory. The files are named:                         #
#                                                                              #
#        a. surveyResultsClassXYZMMMYYYY.csv         - per survey area         #          
#        b. surveyResultsClassWealthXYZMMMYYYY.csv   - per wealth quintile     #
#        c. surveyResultsClassOverallXYZMMMYYYY.csv  - overall                 #
#                                                                              #
#      where                                                                   #
#                                                                              #
#         XYZ  - is the three character country code of the country to which   #
#                the results are from.                                         #
#                                                                              #
#         MMM  - is the three character abbreviation of the month in which     #
#                the survey was conducted (month of the starting day)          #
#                                                                              #
#         YYYY - is the four digit year in which the survey was conducted      #
#                (year of the starting day)                                    #
#                                                                              #
################################################################################</command>
			<property title="Run STEP 4a" shape="STAR">
				<comment state="opened" x="60" y="-10">STEP 4a: Classify        </comment>
			</property>
			<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
		</node>
		<edge from="35" to="0"/>
		<edge from="48" to="20"/>
		<edge from="12" to="181"/>
		<edge from="27" to="12"/>
		<edge from="148" to="144"/>
		<edge from="1" to="180"/>
		<edge from="24" to="26"/>
		<edge from="27" to="35"/>
		<edge from="170" to="46"/>
		<edge from="22" to="45"/>
	</graph>
	<task>
		<taskgroup>
			<taskproperty/>
		</taskgroup>
	</task>
</rflow>
